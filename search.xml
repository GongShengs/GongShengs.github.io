<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何使用VS Code写MD</title>
    <url>/2021/07/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VS_Code%E5%86%99MD/</url>
    <content><![CDATA[<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>语法：<a href="https://www.runoob.com/markdown/md-tutorial.html">MarkDown</a></p>
<p>编写平台：vs code</p>
<p>插件：Markdown Preview Enhanced<br>Better Markdown &amp; Latex Shortcuts</p>
<p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/366596949">https://zhuanlan.zhihu.com/p/366596949</a></p>
]]></content>
  </entry>
  <entry>
    <title>Maya 插件开发学习</title>
    <url>/2021/07/23/Maya_%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Maya-插件开发学习"><a href="#Maya-插件开发学习" class="headerlink" title="Maya 插件开发学习"></a>Maya 插件开发学习</h1><ul>
<li>环境配置<ul>
<li>vs code</li>
<li>maya 脚本编辑器</li>
</ul>
</li>
<li>语言分类<ul>
<li>mel</li>
<li>python</li>
<li>QT</li>
</ul>
</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="maya-脚本编辑器配置"><a href="#maya-脚本编辑器配置" class="headerlink" title="maya 脚本编辑器配置"></a>maya 脚本编辑器配置</h3><p>如图所示，对脚本编辑器进行配置</p>
<p><img src="Maya_Editor_Set.png" alt="d"></p>
<h3 id="vs-code-环境配置"><a href="#vs-code-环境配置" class="headerlink" title="vs code 环境配置"></a>vs code 环境配置</h3><p>相关参考链接：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Cz4y1R7MC?from=search&seid=14150298653133706761">Python开发Maya脚本插件 开发环境详细配置</a></li>
</ul>
<h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><h3 id="mel"><a href="#mel" class="headerlink" title="mel"></a>mel</h3><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>  maya.cmds——这是一个把MEL命令用python包装（ wrappers）的库，可以用于替代MEL命令，因为绝大多数的MEL命令都能查找得到一一对应的maya.cmds命令。只适合面向过程编程。</p>
<p>  pymel.core——该pymel库将许多最常用的MEL命令和API的方法重组到类的层次结构中，这样的设计让你的编程更简单易懂，更具有pythonic化，因为它是具有真正意义上的面向对象特性。由于该pymel库是第三方开发的，Autodesk公司并不提供技术上的支持帮助。</p>
<p>  maya.OpenMaya——这是Maya C++ API的Python包装（ wrappers）的库，称之为Python API 1.0， 适合开发插件和需要MEL未公开的功能的其他任务。</p>
<p>  maya.api.OpenMaya——这是Maya C++ API的Python包装（ wrappers）的库，称之为Python API 2.0。</p>
<h3 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h3><p>为了通用性，GUI选择QT。</p>
]]></content>
  </entry>
  <entry>
    <title>Autodesk FBX SDK 介绍</title>
    <url>/2021/07/23/Autodesk_FBX_SDK/</url>
    <content><![CDATA[<h1 id="Autodesk-FBX-SDK-介绍"><a href="#Autodesk-FBX-SDK-介绍" class="headerlink" title="Autodesk FBX SDK 介绍"></a>Autodesk FBX SDK 介绍</h1><p><a href="https://www.autodesk.com/products/fbx/overview">Autodesk FBX</a>是Autodesk公司出品的一款用于跨平台的免费三维创作与交换格式的软件，通过FBX用户能访问大多数三维供应商的三维文件。FBX 文件格式支持所有主要的三维数据元素以及二维、音频和视频媒体元素。</p>
<p>官方提供了相对应的SDK提供给开发者使用，有C++，C#，Python等多个版本。相关的<a href="https://www.autodesk.com/products/fbx/overview">下载地址</a>。<br>不同环境安装方案：</p>
<ul>
<li>Unity中，如果安装了了Fbx Exporter插件，会自动内置FBX的SDK库。</li>
<li>Houdini中，请看<a href="https://zhuanlan.zhihu.com/p/144349799">Houdini 对于fbx sdk python的简单应用</a></li>
</ul>
<h3 id="相关学习途径"><a href="#相关学习途径" class="headerlink" title="相关学习途径"></a>相关学习途径</h3><ul>
<li>通过阅读Fbx Exporter的源代码来学习Fbx SDK的使用</li>
<li><a href="https://banexdevblog.wordpress.com/2014/06/23/a-quick-tutorial-about-the-fbx-ascii-format/">A QUICK TUTORIAL ABOUT THE FBX ASCII FORMAT</a></li>
<li><a href="https://www.gamedev.net/tutorials/programming/graphics/how-to-work-with-fbx-sdk-r3582/">How to Work with FBX SDK</a></li>
<li><a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_welcome_to_the_fbx_sdk_html">Welcome to the FBX SDK</a></li>
</ul>
<h3 id="Fbx的数据结构"><a href="#Fbx的数据结构" class="headerlink" title="Fbx的数据结构"></a>Fbx的数据结构</h3><p>Fbx是节点式的数据结构，如下图所示：<br><img src="v2-d9e57228d64b062291395dfbc6f84025_720w.jpg" alt="Fbx结构图"></p>
<h3 id="Fbx-SDK-的使用，以Python为例"><a href="#Fbx-SDK-的使用，以Python为例" class="headerlink" title="Fbx SDK 的使用，以Python为例"></a>Fbx SDK 的使用，以Python为例</h3><p>这是修改Fbx Mesh 属性的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2.7</span></span><br><span class="line"><span class="keyword">import</span> fbx</span><br><span class="line"><span class="keyword">from</span> fbx <span class="keyword">import</span> FbxVector2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Run</span>():</span></span><br><span class="line">    node = hou.pwd()</span><br><span class="line">    fileName=node.parm(<span class="string">&quot;file&quot;</span>).<span class="built_in">eval</span>()</span><br><span class="line">    csv_path = node.parm(<span class="string">&#x27;csv_path&#x27;</span>).<span class="built_in">eval</span>()</span><br><span class="line">    directory = node.parm(<span class="string">&#x27;directory&#x27;</span>).<span class="built_in">eval</span>()</span><br><span class="line">    num =<span class="number">1</span></span><br><span class="line">    <span class="comment">#birth_data = []</span></span><br><span class="line">    <span class="comment">#birth_data.append(fileName)</span></span><br><span class="line">    birth_data = DuplicateArray(ReadCsvByPath(csv_path,num))</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> birth_data:</span><br><span class="line">        </span><br><span class="line">        fileName = os.path.basename(path)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;@&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> fileName:</span><br><span class="line">            <span class="built_in">print</span> path</span><br><span class="line">            <span class="built_in">iter</span>=<span class="number">0</span></span><br><span class="line">            fbxManager = fbx.FbxManager.Create()</span><br><span class="line">            fbxScene = fbx.FbxScene.Create(fbxManager, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            fbxImporter = fbx.FbxImporter.Create(fbxManager, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            fbxImporter.Initialize(path)</span><br><span class="line">            fbxImporter.Import(fbxScene)</span><br><span class="line">            fbxRoot = fbxScene.GetRootNode() </span><br><span class="line">            <span class="keyword">if</span> IsCollider(fileName) == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> GetFbxNodeList(fbxRoot,<span class="built_in">list</span> = []):</span><br><span class="line">                    <span class="comment">#i.GetMesh().ClearLayers()</span></span><br><span class="line">                    <span class="keyword">if</span> i.GetMesh()!= <span class="literal">None</span>:</span><br><span class="line">                        i.GetMesh().ClearLayers()</span><br><span class="line">                        <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> GetFbxNodeList(fbxRoot,<span class="built_in">list</span> = []):</span><br><span class="line">                <span class="comment">#i.GetMesh().ClearLayers()</span></span><br><span class="line">                <span class="keyword">if</span> i.GetMesh()!= <span class="literal">None</span>:</span><br><span class="line">                    mesh = i.GetMesh()</span><br><span class="line">                    LayerCount = mesh.GetLayerCount()</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LayerCount):</span><br><span class="line">                        Layer = mesh.GetLayer(j)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(Layer.GetVertexColors()!=<span class="literal">None</span>):</span><br><span class="line">                            Layer.SetVertexColors(<span class="literal">None</span>)</span><br><span class="line">                            <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> LayerCount&gt;=<span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LayerCount):</span><br><span class="line">                            <span class="keyword">if</span> j==<span class="number">1</span> <span class="keyword">or</span> j==<span class="number">2</span>:</span><br><span class="line">                                Layer = mesh.GetLayer(j)</span><br><span class="line">                                uv = Layer.GetUVs()</span><br><span class="line">                                DirectArray = uv.GetDirectArray()</span><br><span class="line">                                DirectArray.SetCount(<span class="number">1</span>)</span><br><span class="line">                                DirectArray.SetAt(<span class="number">0</span>,FbxVector2(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">                                <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line">                            <span class="keyword">elif</span> j&gt;<span class="number">3</span>:</span><br><span class="line">                                Layer = mesh.GetLayer(j)</span><br><span class="line">                                Layer.SetUVs(<span class="literal">None</span>)</span><br><span class="line">                                <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> LayerCount&lt;<span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LayerCount):</span><br><span class="line">                            <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                                Layer = mesh.GetLayer(j)</span><br><span class="line">                                Layer.SetUVs(<span class="literal">None</span>)</span><br><span class="line">                                <span class="built_in">iter</span>+=<span class="number">1</span>            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">iter</span>!=<span class="number">0</span>:</span><br><span class="line">                ExportFbx(fbxManager,path,fbxScene)    </span><br><span class="line">            fbxScene.Destroy()</span><br><span class="line">            fbxImporter.Destroy()</span><br><span class="line">            fbxManager.Destroy()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFbxNodeList</span>(<span class="params">fbxRoot,<span class="built_in">list</span> = []</span>):</span></span><br><span class="line">    num = fbxRoot.GetChildCount()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fbxRoot.GetChildCount()):</span><br><span class="line">        fbxChildRoot = fbxRoot.GetChild(i)</span><br><span class="line">        <span class="built_in">list</span>.append(fbxChildRoot)</span><br><span class="line">        <span class="keyword">if</span> fbxChildRoot.GetChildCount()&gt;<span class="number">0</span> :</span><br><span class="line">            GetFbxNodeList(fbxChildRoot,<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExportFbx</span>(<span class="params">fbxManager,fileName,fbxScene</span>):</span></span><br><span class="line">    fbxExporter = fbx.FbxExporter.Create(fbxManager, <span class="string">&quot;Exporter&quot;</span>)</span><br><span class="line">    fileFormat = -<span class="number">1</span></span><br><span class="line">    fbxExporter.Initialize(fileName,fileFormat,fbxManager.GetIOSettings())</span><br><span class="line">    fbxExporter.Export(fbxScene)</span><br><span class="line">    fbxExporter.Destroy()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#获取输入路径下的指定类型的文件路径列表       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFbxListInDirectory</span>(<span class="params">filepath,file_type,<span class="built_in">list</span>=[]</span>):</span></span><br><span class="line">    path_list = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> f1 <span class="keyword">in</span> path_list:</span><br><span class="line">        f1_path = os.path.join(filepath,f1)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(f1_path):</span><br><span class="line">            suffix = os.path.splitext(f1_path)[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> suffix.lower() == file_type:</span><br><span class="line">                f1_path.replace(<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                <span class="built_in">list</span>.append(f1_path)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(f1_path):</span><br><span class="line">            GetFbxListInDirectory(f1_path,file_type,<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span> </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsCollider</span>(<span class="params">fileName</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;Collider&quot;</span> <span class="keyword">in</span> fileName <span class="keyword">or</span> <span class="string">&quot;collider&quot;</span> <span class="keyword">in</span> fileName:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DuplicateArray</span>(<span class="params">Imported_Array</span>):</span>     </span><br><span class="line">    <span class="type">List</span> = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Imported_Array:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">            <span class="type">List</span>.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">List</span></span><br><span class="line"><span class="comment">#读取csv的列信息，并返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadCsvByPath</span>(<span class="params">csv_path,num</span>):</span></span><br><span class="line">    birth_data = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(csv_path) <span class="keyword">as</span> csvfile:</span><br><span class="line">        csv_reader = csv.reader(csvfile)  <span class="comment"># 使用csv.reader读取csvfile中的文件</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  <span class="comment"># 将csv 文件中的数据保存到birth_data中</span></span><br><span class="line">            birth_data.append(<span class="built_in">str</span>(row[num]))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> birth_data</span><br></pre></td></tr></table></figure>
<h3 id="FBX-SDK-的学习总结"><a href="#FBX-SDK-的学习总结" class="headerlink" title="FBX SDK 的学习总结"></a>FBX SDK 的学习总结</h3><ul>
<li>SDK使用的结构<ul>
<li>FbxManager </li>
<li>FbxScene </li>
<li>FbxImporter</li>
<li>FbxExporter</li>
</ul>
</li>
<li>关于Fbx 属性修改<br>Fbx的Node存在Layer的概念，Layer用于存储各种Mesh的数据，mesh本身的基础数据(如：法线，切线，顶点位置，uv，顶点色)都存储在Layer0上，当模型增加uv2,uv3等数据时，会增加新的Layer层级并存储在对应层级下</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Houdini Digital Assets 学习笔记</title>
    <url>/2021/07/24/Houdini%20Digital%20Assets%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Houdini-Digital-Assets-学习笔记"><a href="#Houdini-Digital-Assets-学习笔记" class="headerlink" title="Houdini Digital Assets 学习笔记"></a>Houdini Digital Assets 学习笔记</h1><p>Digital assets let you create reusable nodes and tools from existing networks.</p>
<p>可以创建复用的节点和工具。 </p>
<p>存储格式：.hda(.otl是旧版本)</p>
<h2 id="创建的方法"><a href="#创建的方法" class="headerlink" title="创建的方法"></a>创建的方法</h2><ol>
<li>Subnetwork 右键  Create digital asset    </li>
<li>资产命名<ul>
<li>Operator Name 命名空间的名字</li>
<li>Operator Label tab管理器的名称</li>
<li>Save to library 存储位置，建议制作自己的资产库，便于个人管理。</li>
</ul>
</li>
<li>编辑面板属性，脚本等细节</li>
<li>4.完成创建</li>
</ol>
<h2 id="面板参数介绍"><a href="#面板参数介绍" class="headerlink" title="面板参数介绍"></a>面板参数介绍</h2><h3 id="Operator-Type-window-资产的编辑窗口"><a href="#Operator-Type-window-资产的编辑窗口" class="headerlink" title="Operator Type window 资产的编辑窗口"></a>Operator Type window 资产的编辑窗口</h3><p>此窗口可以编辑资产除子节点之外的所有数据（参数面板，label and icon，嵌入文件，自定义脚本）</p>
<p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00.png" alt="资产的编辑窗口"></p>
<ul>
<li>Operator Type 就是上文提到的Operator Name，此时的状态是不可更改的。</li>
<li>Save to Library 存储位置。</li>
<li>Install Library to 安装到哪，统一适用packages管理，我觉得更好些。</li>
<li>Switch to Definition 切换定义</li>
</ul>
<h4 id="Basic-tab基础标签"><a href="#Basic-tab基础标签" class="headerlink" title="Basic tab基础标签"></a>Basic tab基础标签</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="Basic"></p>
<ul>
<li>Label 标签名 显示在tab</li>
<li>Icon 图标 建议使用houdini内置的图标，其他处理方式请查看帮助。</li>
<li>Version 版本 版本号提醒</li>
<li>Minimum Inputs 最小输入端口数量</li>
<li>Maximum Inputs 最大输入端口数量</li>
<li>Maximum Outputs 最大输出端口数量</li>
</ul>
<h4 id="Parameters-tab-参数标签"><a href="#Parameters-tab-参数标签" class="headerlink" title="Parameters tab 参数标签"></a>Parameters tab 参数标签</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.png" alt="Parameters"></p>
<ul>
<li><p>创建参数</p>
<ul>
<li>将子节点属性直接拖入Existing Parameters</li>
<li>从create Parameters 中拖入Existing Parameters，然后进行和子节点的关联</li>
</ul>
</li>
<li><p>create Parameters 创建属性</p>
</li>
<li><p>Existing Parameters 已有的参数</p>
</li>
<li><p>Parameter Description参数说明</p>
<ul>
<li>Name 是 参数的名称，当脚本或者其他方式调用时使用此名称， Label 是面板上显示的名称。</li>
<li>Callback Script 回调脚本 当参数有所变化就会触发，经常用于button</li>
<li>Tags 标签 可以存储一些参数属性，例如opengl实时显示材质之类。</li>
</ul>
</li>
<li><p>Channels中存储属性的默认值，但是ramp类型的不在这里设置 它的属性参数中有一项叫 get from  Parameter</p>
</li>
</ul>
<h4 id="Node-Tabs-节点面板"><a href="#Node-Tabs-节点面板" class="headerlink" title="Node Tabs 节点面板"></a>Node Tabs 节点面板</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03.png" alt="Node"></p>
<p>Enitble Nodes 是目前我最常用的，为了能编辑内部节点</p>
<h4 id="Input-Output-tab"><a href="#Input-Output-tab" class="headerlink" title="Input/Output tab"></a>Input/Output tab</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04.png" alt="Input/Output"></p>
<p>输入输出 可以进行一些输入输出的信息描述</p>
<h4 id="Help-Tabs"><a href="#Help-Tabs" class="headerlink" title="Help Tabs"></a>Help Tabs</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05.png" alt="Help"></p>
<p>可以使用wiki 进行节点帮助的创建，我认为在大规模使用的情况下 是很有用的。</p>
<h4 id="Code-Tabs"><a href="#Code-Tabs" class="headerlink" title="Code Tabs"></a>Code Tabs</h4><p>适用于其他类型的资产，现在不讨论。</p>
<h4 id="Scripts-tab"><a href="#Scripts-tab" class="headerlink" title="Scripts tab"></a>Scripts tab</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06.png" alt="Scripts"></p>
<p>触发脚本的标签<br>当有一些自定义的触发操作，批处理之类就可以使用该标签进行创建。</p>
<h4 id="Interactive-tab"><a href="#Interactive-tab" class="headerlink" title="Interactive tab"></a>Interactive tab</h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07.png" alt="Interactive"></p>
<p>交互标签 用于hda 和用户交互的操作<br>例如 hda的菜单位置，界面交互，热键之类</p>
<p>菜单设置    在    shelf Tools-Context- NetWork Plane - TAB Submenu Path</p>
<h4 id="IExtra-Files-tab"><a href="#IExtra-Files-tab" class="headerlink" title="IExtra Files tab"></a>IExtra Files tab</h4><p>内嵌文件标签</p>
<p>用于将一些纹理 bgeo文件嵌入hda 中,嵌入后使用opdef 在资产中进行调用。</p>
<h4 id="Save-Tab"><a href="#Save-Tab" class="headerlink" title="Save Tab"></a>Save Tab</h4><p>保存 目前还未涉及到，感觉默认就行。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>关于私有资产保护问题<ul>
<li>可以创建黑盒，在你不想公开的情况下。</li>
<li>方法：<ol>
<li>选择需要创建黑盒的hda</li>
<li>Assets - Create Black Boxed Asset from Selection </li>
<li>选择存储位置，完成创建。    </li>
</ol>
</li>
</ul>
</li>
<li>当想修改官方的资产但不想影响资产的默认的问题<ol>
<li>打开资产管理面板，右键资产 show in Asset Manager </li>
<li>右键点击资产中的hda 选择duplicate 进行修改创建。</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Houdini Engine for Unity-Plugin API</title>
    <url>/2021/07/24/Houdini%20Engine%20For%20Unity-Plugin%20API/</url>
    <content><![CDATA[<h1 id="Houdini-Engine-for-Unity-Plugin-API"><a href="#Houdini-Engine-for-Unity-Plugin-API" class="headerlink" title="Houdini Engine for Unity-Plugin API"></a>Houdini Engine for Unity-Plugin API</h1><p><a href="http://www.sidefx.com/docs/unity/pluginapi.html">官方文档</a></p>
<p>HEU分为三部分：</p>
<ul>
<li>Asset layer</li>
<li>Utility layer</li>
<li>HAPI layer</li>
</ul>
<h2 id="Asset-layer"><a href="#Asset-layer" class="headerlink" title="Asset layer"></a>Asset layer</h2><p>即资产创建以及参数获取和修改的操作，包含以下几个类：</p>
<ul>
<li>HEU_HoudiniAssetRoot这是Unity中Houdini Engine资产的根组件。它是轻量级的，仅充当层次结构的根并提供用户界面。</li>
<li>HEU_HoudiniAsset这是主要的资产组件，其中包含资产的所有元数据，以及构建，烹饪，查询和修改资产的功能。</li>
<li>HEU_ParameterUtility包含便利功能，用于查询和修改资产上的参数。</li>
</ul>
<p>官方提供了一个相关的实例文档<br>Plugins / HoudiniEngineUnity / Scripts / Examples / HEU_ExampleEvergreenQuery.cs</p>
<h3 id="文档阅读笔记"><a href="#文档阅读笔记" class="headerlink" title="文档阅读笔记"></a>文档阅读笔记</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using HoudiniEngineUnity;</span><br><span class="line"></span><br><span class="line">HEU_AssetDatabase.GetAssetFullPath</span><br><span class="line"></span><br><span class="line">//Manages the asset database to store persistent assets such as materials, textures, asset data, etc. Wraps around Unity AssetDatabase. Only available in Editor. Probably not needed at runtime as data probably does not need to persist past session.</span><br><span class="line">//Given relative path to an asset (with Assets/ in the path), this returns the full path to it.</span><br><span class="line"></span><br><span class="line">HEU_SessionBase </span><br><span class="line">//Base class for a Houdini Engine session. Contains functionality to interface with the Houdini Engine for a particular session.</span><br><span class="line"></span><br><span class="line">HEU_SessionManager.GetOrCreateDefaultSession()</span><br><span class="line">//Manages a session for Houdini Engine. Supports all types of sessions.</span><br><span class="line">//获取或者创建有效会话</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEU_HAPIUtility.InstantiateHDA(evergreenFullPath, Vector3.zero, session, true);</span><br><span class="line">//houdini引擎的工作，如创建hda，cook等。</span><br><span class="line">//Load and instantiate an HDA asset in Unity and Houdini, for the asset located at given path.创建指定路径的hda</span><br><span class="line"></span><br><span class="line">public static GameObject InstantiateHDA(string filePath, Vector3 initialPosition, HEU_SessionBase session, bool bBuildAsync)</span><br><span class="line">FilePath文件路径	 initialPosition 初始位置  获取会话 是否重载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEU_EditorUtility.SelectObject(rootGO);</span><br><span class="line">//Wrapper around Unity Editor functions.Unity编辑器函数的包装。</span><br><span class="line">//选择物体 返回数组</span><br><span class="line"></span><br><span class="line">HEU_HoudiniAsset houdiniAsset = QueryHoudiniAsset(rootGO);</span><br><span class="line">//HEU_HoudiniAsset 资产组件</span><br><span class="line">//QueryHoudiniAsset Shows how to get the HEU_HoudiniAsset component from a HDA root gameobject.</span><br><span class="line"></span><br><span class="line">// Make sure the HDA is cooked before querying or changing its properties.</span><br><span class="line">CookAsset(houdiniAsset);</span><br><span class="line"></span><br><span class="line">// Example of querying and changing parms.</span><br><span class="line">ChangeParmsAndCook(houdiniAsset);</span><br><span class="line"></span><br><span class="line">// This will query objects, geometry, parts, and attributes in the asset.</span><br><span class="line">QueryObjects(houdiniAsset);</span><br><span class="line"></span><br><span class="line">// This will query the gravity attribute.</span><br><span class="line">QueryAttribute(houdiniAsset, &quot;EvergreenGenerator&quot;, &quot;EvergreenGenerator1&quot;, 0, &quot;Cd&quot;);</span><br><span class="line"></span><br><span class="line">HEU_HoudiniAssetRoot</span><br><span class="line">//The root object of a Houdini Engine asset. Used for organizing hierarchy, and more importantly displaying custom UI.</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Houdini 引擎面板功能介绍</title>
    <url>/2021/07/24/Houdini%20Engine%20For%20Unity%20%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Houdini-引擎面板功能介绍"><a href="#Houdini-引擎面板功能介绍" class="headerlink" title="Houdini 引擎面板功能介绍"></a>Houdini 引擎面板功能介绍</h1><h2 id="Houdini-资产UI面板"><a href="#Houdini-资产UI面板" class="headerlink" title="Houdini 资产UI面板"></a>Houdini 资产UI面板</h2><p><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D0.png" alt="Houdini 资产UI面板"></p>
<ul>
<li>Rebuild Assest 重建资产。强制重建资产，并保留最新参数。</li>
<li>Recook Assesrt 重新cook资产。 重新输出资产</li>
<li>Keep Only Output 仅保持输出。删除资产，保留输出的结果。</li>
<li>Duplicate Assest 复制资产</li>
<li>Reset Asset 重置资产。将参数重置为默认值。</li>
<li>Bake GameObject 烘焙GameObject</li>
<li>Bake Prefab 烘焙预制体。</li>
<li>Bake Update 烘焙更新 更新之前烘焙的GameObject和预制体。如果计划烘焙更新，请不要修改物体名称。<h2 id="Asset-Options-资产选项"><a href="#Asset-Options-资产选项" class="headerlink" title="Asset Options 资产选项"></a>Asset Options 资产选项</h2><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D1.png" alt="Asset Options 资产选项"></li>
</ul>
<ol>
<li>Auto-Cook On Parameter Change 当参数变化时自动cook</li>
<li>Push Tranform To Houdini 变换传递至houdini</li>
<li>Transform Change Triggers Cooks 位移的变化触发cook</li>
<li>Cooking Triggers Downsteam Cooks 烘焙时触发其他关联的资产进行烘焙</li>
<li>Generate UVs 创建UV</li>
<li>Generate Tangents 创建切线</li>
<li>Generate Normals 创建法线</li>
<li>Generate Mesh Using Points 使用点创建mesh，但所有的属性都在点上而非顶点上。</li>
<li>Use LOD Groups 使用LOD组</li>
<li>Ignore NonDisplay Nodes 忽略不可显示的节点</li>
<li>Split Geos By Group 通过组分离geo </li>
<li>Save HDA Preset 保存hda预设</li>
<li>Load HDA Preset 导入 hda预设</li>
<li>Reset Material Overrides 重置材质替代<h2 id="导入节点"><a href="#导入节点" class="headerlink" title="导入节点"></a>导入节点</h2><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D2.png" alt="导入节点"></li>
<li>Input Type 输入类型 Unity_Mesh unity的gameObject或者预制体  hda houdini资产</li>
<li>Keep World Transform 保持世界空间位移</li>
<li>Pack Geometry Before Mergi 在合并前物体打包。仅适用于unity物体</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>转载：Ice Shader in UE4</title>
    <url>/2021/10/03/Ice-Shader-in-UE4/</url>
    <content><![CDATA[<h1 id="Ice-Shader-in-UE4"><a href="#Ice-Shader-in-UE4" class="headerlink" title="Ice Shader in UE4"></a>Ice Shader in UE4</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post01.jpg" alt="post01"></p>
<p>So i’ve been meaning to do this for a while, but unfortunately finding time was tricky, but I’ve managed to sneak in some free time in-between assignments to make this write-up. Now, Full disclosure, I am no pro, this was a result of me researching/experimenting trying to get a result, lots of googling etc. So it may not be perfect, feel free to leave some feedback or any changes you may suggest. Anyway lets get started.</p>
<h2 id="Material-Preview"><a href="#Material-Preview" class="headerlink" title="Material Preview"></a><strong>Material Preview</strong></h2><p>Here is a preview of what the material looks like along with the entire material graph, if you’d rather not read through all my ramblings/explanation</p>
<p>My goal with this project was to create a “Genereal Purpose” ice material. Something that could be tweaked with parameters to work decently for any kind of use.</p>
<p><img src="IceShowcase_Gif.gif" alt="IceShowcase_Gif"></p>
<p><img src="Opaque_Ice.png" alt="Opaque_Ice"></p>
<p><img src="ICe_Floor_Showcase.gif" alt="ICe_Floor_Showcase"></p>
<p><img src="FullGraph.JPG" alt="FullGraph"></p>
<h2 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a><strong>Textures</strong></h2><p>This material makes use of 4-5 textures depending on whether you choose to add a baked normal map for a mesh, 3 of them will contain patterns in each channel and one will be a general purpose noisy normal map. I used Substance designer to generate these patterns and I thin I also found one or two wit on gogle. The images below show you how the textures are set up.</p>
<h2 id="BubbleMask-tga"><a href="#BubbleMask-tga" class="headerlink" title="BubbleMask.tga"></a><strong>BubbleMask.tga</strong></h2><p><img src="BubbleMask_BD.jpg" alt="BubbleMask_BD"></p>
<h2 id="ColorMask-Crack-Roughness-tga"><a href="#ColorMask-Crack-Roughness-tga" class="headerlink" title="ColorMask-Crack-Roughness.tga"></a><strong>ColorMask-Crack-Roughness.tga</strong></h2><p><img src="ColorMask-Crack-Roughness_BD.jpg" alt="ColorMask-Crack-Roughness_BD"></p>
<h2 id="Subsurface-Height-Speckle-tga"><a href="#Subsurface-Height-Speckle-tga" class="headerlink" title="Subsurface-Height-Speckle.tga"></a><strong>Subsurface-Height-Speckle.tga</strong></h2><p><img src="Subsurface-Height-Speckle.jpg" alt="Subsurface-Height-Speckle.jpg"></p>
<h2 id="NormalMap"><a href="#NormalMap" class="headerlink" title="NormalMap"></a><strong>NormalMap</strong></h2><p><img src="Ice_Substance_BaseNormal.jpg" alt="Ice_Substance_BaseNormal"></p>
<h2 id="BumpOffset-Node"><a href="#BumpOffset-Node" class="headerlink" title="BumpOffset Node:"></a><strong>BumpOffset Node:</strong></h2><p>This node in the UE4 Material Editor, basically helps us make use of parallax mapping, this is waht we use to fake the “depth” in this material. The basic explanation of how it works is this, you feed it a Coordinate value, a height value and a height ratio value. The Height Value determines the base or plane from which your heightratio is measured, so if you feed a height value 0 with a height ratio value of -1.0, pixels will appear as though they are “under” the surface, where as if you have a height value of 0 and a height ratio value of 1.0, pixels will appear to bulge above the surface (This can look very bad unless you use subtle values). <a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/HowTo/BumpOffset/">Here’s</a> the documentation page for the node</p>
<p><img src="BumpOffsetNode.JPG" alt="BumpOffsetNode"></p>
<h2 id="Creating-Masks-for-Surface-Coloration"><a href="#Creating-Masks-for-Surface-Coloration" class="headerlink" title="Creating Masks for Surface Coloration"></a><strong>Creating Masks for Surface Coloration</strong></h2><p>In this step, we are going to mix and match some of the textures we made to create some masks that we will use to control the shader’s coloration and expose some useful variables as parameters so that we can use it to tweak the shader’s appearance with Instances. You can see the network below:</p>
<p>First we create a scalar parameter, “Master Tiling”, we will use this to control the global tiling value for the entire material.</p>
<p><img src="Master_Tiling_Parameter.JPG" alt="Master_Tiling_Parameter"></p>
<p>1: Next we create the basic setup that will repeat for all the textures that we use in the shader, we set up a scalar parameter to control the tiling for each TextureSample and multiply it by the Global Tiling parameter , we also setup the bumpOffset Node and the values for it’s inputs to be use.</p>
<p><img src="SurfaceColoration_Mask.JPG" alt="SurfaceColoration_Mask"></p>
<p>We do some basic value adjustments to each texture sample with a power node, we do this to create some variation in the masks as we will be re-using the same textures many times in the shader. WIth this network set up we have 3 mask outputs ready to be used (labeled in the image). We will make use of these later.</p>
<h2 id="Bubble-Cracks-Surface-Masks"><a href="#Bubble-Cracks-Surface-Masks" class="headerlink" title="Bubble,Cracks,Surface Masks"></a><strong>Bubble,Cracks,Surface Masks</strong></h2><p>This part of the graph creates surface masks to control areas where the bubbles are visible.</p>
<p>![Crack and SurfaceMasks](Crack and SurfaceMasks.JPG)</p>
<p>In this section we are going to set up the the masks for the bubbles and surface cracks, see the node Graph below:</p>
<p><img src="BubbleMask.JPG" alt="BubbleMask"></p>
<p>In the graph above we repeat the process of setting up tiling parameters for the textures for each texturesample.</p>
<p>1.) This will be the upper most layer of bubbles,we will sue the Blue Channel of the texture as that is where we stored the blobby bubble pattern. We set a height ratio value of -0.2, so the bubbles appear just below the surface.</p>
<p>2.) This section will be bubbles that are deeper inside the surface. FIrst we set up two scalar parameters and add it to the texture coordinate, this will let us add some offsets in the U and V directions to create some variation. Next we repeat the procedure for setting up tiling values,We set a higher tiling value to make the bubbles appear smaller, to help improve the fake depth effect, In the Bump offset node we set a heihgt ratio of -1.0.</p>
<p>We multiply the end result of this network with the an the inverted result of Mask_01 from the previous section. This is done so the bubbles are not visible if they are under the Opaque sections of the ice surface. The gif below shows what the result of this network looks like.</p>
<p><img src="BubbleMask_GIF.gif" alt="BubbleMask_GIF"></p>
<h2 id="Material-Roughness"><a href="#Material-Roughness" class="headerlink" title="Material Roughness"></a><strong>Material Roughness</strong></h2><p>This section of the graph deals with how we set up the roughness input for the material, we do the same process as before and set up the tiling properties for the texture with the speckle pattern in the Blue channel, we use this as the mask to Lerp between a min an max roughness value. We expose these values as parameters so they can be tweaked. Finally we do a final lerp with the crack pattern mask from Mask_01, this is to give the cracked areas a different roughness than the rest of the surface.</p>
<p><img src="Roughness_Graph.PNG" alt="Roughness_Graph"></p>
<p>This will serve as the roughness output for the material, if we preview it, it will look something like this:</p>
<p><img src="Roughness_Output.gif" alt="Roughness_Output"></p>
<h2 id="Opacity-Subsurface-Masking"><a href="#Opacity-Subsurface-Masking" class="headerlink" title="Opacity/Subsurface Masking"></a><strong>Opacity/Subsurface Masking</strong></h2><h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1:"></a>Part 1:</h3><p>In the following sections we will set up the Opacity output for the material, this part of the graph affect the material in two ways.</p>
<p>1.) It controls teh amount of subsurface scattering that occurs on the surfae of the mesh</p>
<p>2.) With translucency enabled,it controls how opaque/Translucent the material is.</p>
<p>So, this will affect how the Opacity output is used depending on whether we enable translucency or not</p>
<p>(Note: The translucent version of the material is quite expensive, use carefully, ideally any objects that use this shader should mip out to a cheaper version of the material quickly)</p>
<p>It is important to note that Opacity serves two purposes in this material, since our material uses a subsurface shading model, the opacity controls how much subsurface scattering happens on the surface of the object, in the opacity map, white areas = more scattering black areas= less scattering.</p>
<p>With translucency on the other hand, white areas = opaque, black areas = completely transparent. We need to keep this in mind as we build the opacity graph, so that we adress both these needs correctly</p>
<p>This first section just makes a basic mask using the texture we created earlier, but we also add some fresnel, so that the edges of the object do not become completely transparent as this can make the object feel floaty, and not very grounded in the world.</p>
<p><img src="Opacity.PNG" alt="Opacity"></p>
<p>If you preview the node commented as opacity, you’ll see something like this:</p>
<p><img src="Opacity-SubsurfaceMaskGif.gif" alt="Opacity-SubsurfaceMaskGif"></p>
<h3 id="Part-2-Camera-Distance-Mask"><a href="#Part-2-Camera-Distance-Mask" class="headerlink" title="Part 2: Camera Distance Mask"></a>Part 2: Camera Distance Mask</h3><p>Here we set up a camera distance based mask, so that the translucency becomes visible only when we are closer than a specified distance from the object (in thi s case 512 units). This was a personal choice for me, I didn’t like the way objects looked translucent from afar and wanted it to happend only when the viewer was close to the object.</p>
<p><img src="Camera_Distance.PNG" alt="Camera_Distance"></p>
<p>Here’s a gif showing what this network does, As you can see, the mask gets darker(i.e more transparent) the closer the camera is to the object.</p>
<p><img src="CameraMask.gif" alt="CameraMask.gif"></p>
<h2 id="Final-Opacity-Mask-Blending"><a href="#Final-Opacity-Mask-Blending" class="headerlink" title="Final Opacity Mask Blending"></a><strong>Final Opacity Mask Blending</strong></h2><p>In this part we bring together all the previous masks we made and blend them together to get the final output that goes into the Opacity Input of the material:</p>
<p><img src="OpacityMask_Blending.PNG" alt="OpacityMask_Blending.PNG"></p>
<p>If you preview the output of all these blends, it will look something like this.</p>
<p><img src="Opacity_Mask_Gif.gif" alt="Opacity_Mask_Gif.gif"></p>
<h2 id="BaseColor-Pass"><a href="#BaseColor-Pass" class="headerlink" title="BaseColor Pass"></a><strong>BaseColor Pass</strong></h2><p>The section below shows how we combine all the masks we have created in the previous sections to make the basecolor pass for the material. I used Adobe’ Kuler to pick an Analogous Color palette of light and deep blues, we expose all these colors as Texture Parameters so that it can be tweaked to any artists desires. I’ve commented which Mask goes to which lerp node.</p>
<p><img src="ColorPalette.PNG" alt="ColorPalette.PNG"></p>
<p>In the end we run everything through a Fuzzy shading Material Function, it works very similar to a fresnel but we are able to control the core darkness and the edge brightness, this function was commonly used when creating moss, cloth(before th release of the new shading model) and grass materials, but it provides an effect that I think works welll with Ice as well.</p>
<p><img src="Final_Color_Comp.PNG" alt="Final_Color_Comp.PNG"></p>
<p>If you preview the fuzzy shading node you will see something that looks like this. The output from this FuzzyShading Node will go into the BaseColor input of the material. This result will also be used to create the subsurface color in the next section.</p>
<p><img src="FinalColorPreview.gif" alt="FinalColorPreview.gif"></p>
<h2 id="Subsurface-Color"><a href="#Subsurface-Color" class="headerlink" title="Subsurface Color"></a><strong>Subsurface Color</strong></h2><p>The subsurface color output is generated by multiplying the Final Color Output with a parameterized color hue, and scaling factor to control how bright the color is. the output of this multiply node will go into the materials subsurface color input.</p>
<p><img src="SubSurface_Color.PNG" alt="SubSurface_Color.PNG"></p>
<h2 id="Normal-Map"><a href="#Normal-Map" class="headerlink" title="Normal Map"></a><strong>Normal Map</strong></h2><p>For the materials normal, the setup is simple, we use the normal texture, with uv coordinates from the Surface Masks section, we also add a static switch parameter to control whether we want to combine it with a baked object normal map. This option is made so that when we apply this material to an object with baked normal maps, we blend the ice normals with the objects baked normal map.</p>
<p><img src="NormalMap.PNG" alt="NormalMap.PNG"></p>
<h2 id="Performance-optimization-Final-Thoughts"><a href="#Performance-optimization-Final-Thoughts" class="headerlink" title="Performance, optimization/Final Thoughts"></a><strong>Performance, optimization/Final Thoughts</strong></h2><p>When you create an instance of this material, you will have the option, of using it as a either a translucent-Subsurface material or as an opaque subsurface material. Using the translucency is quite expensice and ideally you’d want to mip to a cheaper material pretty quickly. The opaque-subsurface version on the other hand is not as beefy and is quite performant.</p>
<p>If you look at the shader complexity comparison between a <strong>transparent-subsurface</strong> and an <strong>Opaque-subsurface</strong> version of the material you will there is quite a big difference. For proper estimation of performance of course you want to use the GPU profiler to get accurate information on exactly what is going on in the scene.</p>
<p><img src="Shader.jpg" alt="Shader.jpg"></p>
<p><img src="ShaderComplexity.jpg" alt="ShaderComplexity.jpg"></p>
<p><img src="Translucent_Subsurface.PN" alt="Translucent_Subsurface.PN"></p>
<p><img src="Opaque_Subsurface.PNG" alt="Opaque_Subsurface.PNG"></p>
<p>The image below shows all the parameters that are exposed to the material instance, these settings can be tweaked to achieve different looks with the same material.</p>
<p><img src="Parameters.PNG" alt="Parameters.PNG"></p>
<p><strong>Thank you for reading and I hope you find this useful!Cheers!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Flowmapped-Burn-Shader</title>
    <url>/2021/10/03/Flowmapped-Burn-Shader/</url>
    <content><![CDATA[<h1 id="Flowmapped-Burn-Shader"><a href="#Flowmapped-Burn-Shader" class="headerlink" title="Flowmapped-Burn-Shader"></a>Flowmapped-Burn-Shader</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post14.gif" alt="post14.gif"></p>
<p>This was a small shader that came about while I was thinking of different uses for Flowmaps, there are plenty of transition/dissolve effects out there, but most tend to look pretty static since they use static Textures. Here I’ve flowmapped the noise that drives the dissolve to achieve a location based burn shader. It is far from perfect, but the flowing motion makes it visually appealing as a burning dissolve effet.</p>
<p>The shader itself is extremely straight forward, I will detail a small breakdown below of my process. As with most of my other shaders. I’ve wrapped this into a Material Function, so that it can be used with any pre-existing materials.</p>
<p><font color=red>Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<h2 id="Textures"><a href="#Textures" class="headerlink" title="Textures:"></a><strong>Textures:</strong></h2><p>I used the following textures in my shader, the first is a simple noise generated in Substance designer, the second is a swirly flowmap that I painted using <a href="http://teckartist.com/?page_id=107">Flowmap Painter</a></p>
<h2 id="Noise-Texture"><a href="#Noise-Texture" class="headerlink" title="Noise Texture"></a><strong>Noise Texture</strong></h2><p><img src="T_Noise_Cloud.png" alt="T_Noise_Cloud.png"></p>
<h2 id="Flowmap-Texture"><a href="#Flowmap-Texture" class="headerlink" title="Flowmap Texture"></a><strong>Flowmap Texture</strong></h2><p><img src="T_Swirlmap.pn" alt="T_Swirlmap.pn"></p>
<h2 id="Flowmap-setup"><a href="#Flowmap-setup" class="headerlink" title="Flowmap setup"></a><strong>Flowmap setup</strong></h2><p>Flowmapping is a technique by which we use 2D Vectors stored in the form of a texture to distort of the UV’s of a texture over time. This distortion animation is then looped to give the illusion of flow, it’s commonly used in realtime water shaders to give the look of water flowing around rocks etc, but it can of course be used for lots of other things. In my shader I use it to create a material burning effect. If you would like a better understanding of flowmapping I reccomend reading the <a href="http://wiki.polycount.com/wiki/Flow_map">Polycount Wiki Entries</a> also check out <a href="https://youtu.be/tEr3NE_XLbc">Simonschreibt’s Flowmap Tutorial</a> as he does a great job of explaining it.</p>
<p>You can see my flowmap setup below</p>
<p><img src="flowmap_nodes.png" alt="flowmap_nodes.png"></p>
<p>As you can see we have parameters to control distortion strength, Tiling of the Different Textures as well as flow direction.</p>
<p>I use the Red channel’s output from the flowmapped noise to drive my effect, if you preview the Lerp Node, you will see this result</p>
<p><img src="flowmap_nodes.gif" alt="flowmap_nodes.gif"></p>
<h2 id="SphereMask"><a href="#SphereMask" class="headerlink" title="SphereMask"></a><strong>SphereMask</strong></h2><p>This next step can be handled multiple ways, in the end all it needs to be is a scaling gradient value to drive the effect. In this case, I am using a spheremask driven by blueprint location to drive the mask, this way I can move the blueprint around to affect what areas get burnt, and I can animate the sphere radius to create a burn away cycle. If you would liek to know how to setup a Material Parameter collection to pipe in the BP’s location into the shader I reccomend checking out my <a href="https://deepspacebanana.github.io/">Wormhole Shader Breakdown</a>. As I explain it i ndetail there, and I am usign the exact same setup here.</p>
<p>Creating a spheremask is easy as UE4 comes with an in-built function that lets us do jsut that</p>
<p><img src="spheremask.png" alt="spheremask.png"></p>
<p>The radius in this case is in World Space Units, so try sscrubbing the radius value and you’ll see this. By default, the location of the sphere mask is {o,o,o}, so you’ll notice the sphere growing from the center of the mesh.</p>
<p><img src="spheremask.gif" alt="spheremask.gif"></p>
<p>The next step is to create subtract the result from the flowmapped noise from the spheremask so we get a burn like pattern as the mask scales.</p>
<p><img src="subtract.png" alt="subtract.png"></p>
<p>Note that you can adjsut the <strong>spheremask hardness</strong> parameter to control the amount of spread in the transition</p>
<h2 id="Hardness-0-2"><a href="#Hardness-0-2" class="headerlink" title="Hardness:0.2"></a><strong>Hardness:0.2</strong></h2><p><img src="subtract.gif" alt="subtract.gif"></p>
<h2 id="Hardness-0-5"><a href="#Hardness-0-5" class="headerlink" title="Hardness:0.5"></a><strong>Hardness:0.5</strong></h2><p><img src="subtract_02.gif" alt="subtract_02.gif"></p>
<p>We can now take the result from this network and multiply it by the Opacity Mask input from thet Function input reads to get the Final Opacity Mask</p>
<p><img src="materialattributes.png" alt="materialattributes.png"></p>
<p><img src="opacitymask.png" alt="opacitymask.png"></p>
<p>It is good to know that, you could jsut as easily do this effect without the flowmap setup using jsut a static texture, the difference is that the flowmapped version has more motion and has a nice almost anime-esque visual flair. You can see the difference in the mask below.</p>
<h2 id="With-flowmap"><a href="#With-flowmap" class="headerlink" title="With flowmap"></a><strong>With flowmap</strong></h2><p><img src="finalopacitymask.gif" alt="finalopacitymask.gif"></p>
<h2 id="Without-flowmap"><a href="#Without-flowmap" class="headerlink" title="Without flowmap"></a><strong>Without flowmap</strong></h2><p><img src="finalopacitymasknoflow.gif" alt="finalopacitymasknoflow.gif"></p>
<h2 id="Edge-Glow-and-Charring"><a href="#Edge-Glow-and-Charring" class="headerlink" title="Edge Glow and Charring"></a><strong>Edge Glow and Charring</strong></h2><p>To make the Burning edges glow and to have the charred blackish outline, we use a technique that I’ve used in a lot of my shaders previously, where we sample the mask gradient at 0 and create an edge mask using the distance function.</p>
<p>You can see the setup below. The only thing to note here is that in this case we sample at <strong>0.45 for the glow outline</strong> and at <strong>0.5 for the charring outline</strong>, this is so that they are offset from each other and the charring appears around the glow, we also set a higher width for the charring outline so that it appears outside the glow Outline. We then expose the width inputs as parameters so that we can control the spread as needed.</p>
<p><img src="edgesample.png" alt="edgesample.png"></p>
<p>If you preview the outputs from each of these respectively you should see the following</p>
<p><img src="glowsample.gif" alt="glowsample.gif"></p>
<p><img src="charsample.gif" alt="charsample.gif"></p>
<p>Now we can simply take the result from the emberglow section, multiply it by a flame color and add it to the Emissive color from the Function Input to account for any pre-existing emissive color in whatever shader we use this function in, and use that as our final emissive color.</p>
<p><img src="emissive.png" alt="emissive.png"></p>
<p>You could alternatively, use the result from the emberglow section as input to map colors based on the gradient. A technique called gradient mapping, and UE4 now has a CurveAtlass feature which lets you define color curves and access them inside the shader, the feature is still a little finicky as I experienced a couple crashes trying to use it in my shader, so i will refrain from using it now, perhaps i’ll cover it in a future post.</p>
<p><img src="edgeglow.gif" alt="edgeglow.gif"></p>
<p>Next we take the result from the Charring section and multiply it with the Basecolor from the function input to get the Final Basecolor value</p>
<p><img src="basecolor.png" alt="basecolor.png"></p>
<p>Now you’ll see the edges turn black before they glow and burn</p>
<p><img src="charring.gif" alt="charring.gif"></p>
<p>And that’s it we are done.</p>
<p>The really cool part is now we can move the Blueprint around to create the burn area, in a game you could use the location of the players torch or something to drive the effect to make it look like they are burning things away. And we can play with the <strong>spheremask hardness</strong> and <strong>Radius</strong> to get the exact look and spread we want. Here’s what it looks like with different settings</p>
<h2 id="Mask-Radius-512-Spheremask-Hardness-0"><a href="#Mask-Radius-512-Spheremask-Hardness-0" class="headerlink" title="Mask Radius: 512 , Spheremask Hardness:0"></a><strong>Mask Radius: 512 , Spheremask Hardness:0</strong></h2><p><img src="loc_01.gif" alt="loc_01.gif"></p>
<h2 id="Mask-Radius-92-Spheremask-Hardness-0-5"><a href="#Mask-Radius-92-Spheremask-Hardness-0-5" class="headerlink" title="Mask Radius: 92 , Spheremask Hardness:0.5"></a><strong>Mask Radius: 92 , Spheremask Hardness:0.5</strong></h2><p><img src="loc_02.gif" alt="loc_02.gif"></p>
<p>Additionally you can animate the Radius to make it look like it’s burning away over time.</p>
<img src="https://media.giphy.com/media/8mwz2qnDRoOqBxYhzk/giphy.gif" width="512">

<img src="https://media.giphy.com/media/8PabF69ZHsjBbqCbZn/giphy.gif" width="512">

<p>Hope you found this useful.Cheers!</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Glitch Effects</title>
    <url>/2021/10/03/Glitch-Effects/</url>
    <content><![CDATA[<h1 id="Glitch-Effects"><a href="#Glitch-Effects" class="headerlink" title="Glitch Effects"></a>Glitch Effects</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post10.gif" alt="post10.gif"></p>
<p>This little project was spawned from being inspired by a video I saw showcasing all the cool Glitch Effects from Horizon Zero Dawn</p>
<p>I decided to try and make some form of a general purpose glitch shader that could be applied to any piece of geometry, I made two variations, one was a simple random distortiony glitch and the other used the same idea and combined it with my previous sphere mask based apparition effect to create a new type of apparition shader. You can see them both below.</p>
<p><font color=red>Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<h2 id="Glitch-Effect"><a href="#Glitch-Effect" class="headerlink" title="Glitch Effect"></a><strong>Glitch Effect</strong></h2><p><img src="Glitch_01.gif" alt="Glitch_01.gif"></p>
<h2 id="Apparition"><a href="#Apparition" class="headerlink" title="Apparition"></a><strong>Apparition</strong></h2><p><img src="Glitch_02.gif" alt="Glitch_02.gif"></p>
<h2 id="Breakdown"><a href="#Breakdown" class="headerlink" title="Breakdown"></a><strong>Breakdown</strong></h2><p>Like some of my previous posts, I encapsulated this entire shader into a material function so that it can be easily layered into any existing shader. So the first step is to create a Material Function.</p>
<p>The next step is to generate a psuedorandom CellNoise, this is what we will use to drive the color and Vertex Deformation of the glitch. You can see the netwrok below</p>
<p><img src="Nodes_01.png" alt="Nodes_01.png"></p>
<p>Now you may be wondering, but UE4 already has a “Noise” Function, why don’t you jsut use that? I could have..but I’m weird like that, also for some reason my custom network has less instructions</p>
<p>What this network is doing is essentially taking the localized WorldPosition of the object &gt; adding a time based psuedo-random scalar value to each channel &gt; running it through a custom function <strong>MF_Vec3Noise3</strong> which generates a psuedorandom Vector 3 value, which is our cell noise.</p>
<p>I add 0.1 and bias it because my function outputs values from -1 to 1, and i want values tht go from 0-1 instead, the 0.1 is to avoide any complete 0 values.</p>
<p>The output from this network will look like this</p>
<p><img src="output_01.gif" alt="output_01.gif"></p>
<h2 id="Noise-Functions"><a href="#Noise-Functions" class="headerlink" title="Noise Functions"></a><strong>Noise Functions</strong></h2><p>The two noise functions <strong>MF_Noise1D</strong> and <strong>MF_Vec3Noise3</strong> generate psuedo-random values based on inputs that are fed to them, the only difference between them being 1D takes a scalar input and outputs a random scalar value, the Vec3 one takes a Vector3 Input and outputs a Vector3 Psuedorandom Value.</p>
<p>If you would like to learn more about noise, I highly reccommend checking out <a href="https://thebookofshaders.com/11/">The Book of Shaders</a>, they do a great job of explaining it as well as it’s many uses.</p>
<p>Here’s what the node network for my functions looks like:</p>
<h2 id="MF-Vec3Noise3"><a href="#MF-Vec3Noise3" class="headerlink" title="MF_Vec3Noise3"></a><strong>MF_Vec3Noise3</strong></h2><p><img src="Noise3D.png" alt="Noise3D.png"></p>
<h2 id="MF-Noise1D"><a href="#MF-Noise1D" class="headerlink" title="MF_Noise1D"></a><strong>MF_Noise1D</strong></h2><p><img src="Noise1D.png" alt="Noise1D.png"></p>
<h2 id="Opacity-Mask"><a href="#Opacity-Mask" class="headerlink" title="Opacity Mask"></a><strong>Opacity Mask</strong></h2><p>The next step is to create a mask that will drive the Opacity</p>
<p><img src="Nodes_02.png" alt="Nodes_02.png"></p>
<p>For this too, I calculate the localized worldposition of the object and then isolate the vector along which I want the mask effect to work. In my case I mask out the redChannel which is the X Vector of the object(You could convert this to a parameter so that you can pick along which axis the effect occurs)</p>
<p>We also have input parameters to enter the objects Length etc so that the shader can be customized to work with any object(in the future I will update this post to show how we can procuderally get these values without having to manually enter them).</p>
<p>If you preview the subtract node commented as <strong>BaseopacityMask</strong> you will see this</p>
<p><img src="basemask.gif" alt="basemask.gif"></p>
<p>As you can see we have a black and white mask that travels along the x axis of the object, we will combine this with some other outptus to get the final opacity mask.</p>
<p>The <strong>Edge Mask from Sample Gradient</strong> does exactly what it says, it samples the mask gradient and generates an Edge Mask, we use this to mask out the edge Fx as well as apply VertexDeformation for the Final Shader Effect. If you preview the out put from there you will see this. More on this soon.</p>
<p><img src="edgemask.gif" alt="edgemask.gif"></p>
<h2 id="Final-Opacity-Mask"><a href="#Final-Opacity-Mask" class="headerlink" title="Final Opacity Mask"></a><strong>Final Opacity Mask</strong></h2><p>To generate the final opacity mask we isolate the redChannel from our psuedorandom cell noise&gt;multiply it by a scaling factor(This controls the falloff of the transition,higher value = more falloff and vice versa), and subtract it from the baseopacitymask gradient to generate a cell pattern falloff. As shown below, this will be the input for the OpacityMask in the shader.</p>
<p><img src="finalopacity.png" alt="finalopacity.png"></p>
<p><img src="finalopacity.gif" alt="finalopacity.gif"></p>
<h2 id="Vertex-Deformation-WorldPosition-Offset"><a href="#Vertex-Deformation-WorldPosition-Offset" class="headerlink" title="Vertex Deformation/WorldPosition Offset"></a><strong>Vertex Deformation/WorldPosition Offset</strong></h2><p>For the worldposition offset we take the output result from the psuedorandom cell noise &gt; Multiply it with the vertex Normals &gt; multiply it with scaling Factor(Deformation Strength) and then Linear interpolate it with a NULL value using the out put from the Gradient Sample Edge Mask as the alpha. This final result goes into the shader’s WorldPositionOffset Input</p>
<p><img src="wponodes.png" alt="wponodes.png"></p>
<p>if you preview the shader with just the WPO input, it’ll look like this</p>
<p><img src="wpo.gif" alt="wpo.gif"></p>
<h2 id="Color-Blending-Emissive"><a href="#Color-Blending-Emissive" class="headerlink" title="Color Blending/Emissive"></a><strong>Color Blending/Emissive</strong></h2><p>For the Final Color we just create a fresnel from the object’s normal map and multiply it by the Psuedorandom cell noise input. Then we blend between this value and the object’s base color using the Gradient Sampled Edge Mask Output. We do the same for the emissive, blending between the Emissive Input, using the Gradient Sampled Edge Mask Output.</p>
<p><img src="colorblending.png" alt="colorblending.png"></p>
<h2 id="BaseColor"><a href="#BaseColor" class="headerlink" title="BaseColor"></a><strong>BaseColor</strong></h2><p><img src="basecolor.gif" alt="basecolor.gif"></p>
<h2 id="Emissive"><a href="#Emissive" class="headerlink" title="Emissive"></a><strong>Emissive</strong></h2><p><img src="Emissive.gif" alt="Emissive.gif"></p>
<p>And that’s it! the entire functions node network should look something like this:</p>
<p><img src="FullFunction.png" alt="FullFunction.png"></p>
<p>The Function Node will look like this when you use it in your material, it’ll take your entire material as an input and apply the shader effect on top of your existing shader</p>
<p><img src="FunctionNode.png" alt="FunctionNode.png"></p>
<h2 id="Randomized-Glitch"><a href="#Randomized-Glitch" class="headerlink" title="Randomized Glitch"></a><strong>Randomized Glitch</strong></h2><p><img src="Glitch_01.gif" alt="Glitch_01.gif"></p>
<p>To make make a randomized glitch effect like the one shown above, it’s jsut a matter of swapping out the sine gradient part of network with a netwrok that creates a spheremask with a time based randomised position, which can be done with the following. </p>
<p><img src="RandomPos.gif" alt="RandomPos.gif"></p>
<p>If you preview the result from this, you will see that it is basically a sphere mask that get moved around the model randomly</p>
<p><img src="Glitch_Combo.gif%22" alt="Glitch_Combo.gif&quot;"></p>
<p>And that’s it! Hope you found this breakdown useful! Feel free to email me if you have any questions.</p>
<p><img src="Final.gif" alt="Final.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Procedural Hologram Shader</title>
    <url>/2021/10/03/Hologram-Shader-V1/</url>
    <content><![CDATA[<h1 id="Procedural-Hologram-Shader"><a href="#Procedural-Hologram-Shader" class="headerlink" title="Procedural Hologram Shader"></a>Procedural Hologram Shader</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="Post12.gif" alt="Post12.gif"></p>
<p>This was a quick little effect I came up with, to try and test some ideas I had for some Procedural Vertex Animation and a hacky technique for generating psuedorandom Vectors per face in the Shader. This would probably be infinitely easier to do if Unreal gave us access to Triangle,Vertex and Poly data in the Material Editor. But here’s what I did.</p>
<p><font color=red>Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<p><strong>The main goal with this effect was to try and make the shader fully procedural</strong>.It would probably be quite easy to recreate using textures.</p>
<p><img src="HoloSphere_01.gif" alt="HoloSphere_01.gif"></p>
<p><img src="HoloSphere_02.gif" alt="HoloSphere_02.gif"></p>
<h2 id="The-Setup"><a href="#The-Setup" class="headerlink" title="The Setup"></a><strong>The Setup</strong></h2><p>This effect uses a simple sphere mesh with Split Edges as the base object. This is not really a reusable effect, as I was jsut experimenting.</p>
<p><img src="sphere.png" alt="sphere.png&quot;"></p>
<p><img src="sphere.gif" alt="sphere.gif"></p>
<h2 id="Shader-Setup"><a href="#Shader-Setup" class="headerlink" title="Shader Setup"></a><strong>Shader Setup</strong></h2><p>I n a nutshell, the shader basically displaces each face along it’s normal, and the animation is driven by some math in the Shader. We also procedurally generate some psuedorandom Vec2 values per face of the object, we then use these per face values to have each face have some randommness in how muc hthey displace.</p>
<h2 id="Generating-Random-Values-Per-Face"><a href="#Generating-Random-Values-Per-Face" class="headerlink" title="Generating Random Values Per Face"></a><strong>Generating Random Values Per Face</strong></h2><p>The Network below uses the VertexNormal with the <strong>MF_Vec2Noise2D</strong> function to generate some psuedorandom vec2 values per face on the model, Time is used in the Seed value so that the vec2 values randomly change over time. This Technique only works on simple concave/convex shapes which is why the shader, is not reusable. Perhaps there is some way to access some kind of PolygonID value using the Custom Node in unreal but I’m not familiar enough with Unreal’s Rendering API to figure out how to do it.</p>
<p><img src="Randomperface.png" alt="Randomperface.png"></p>
<p>The preview result looks like this</p>
<p><img src="Randomperface.gif" alt="Randomperface.gif"></p>
<p><strong>MF_Vec2Noise2D</strong> takes in a vec2 input and outputs a psuedorandom vec2 value from it. THe node network for the function can be seen below</p>
<p><img src="MF_Vec2Noise2D.png" alt="MF_Vec2Noise2D.png"></p>
<h2 id="World-Position-Offset"><a href="#World-Position-Offset" class="headerlink" title="World Position Offset"></a><strong>World Position Offset</strong></h2><p>The network below uses a sphere mask, to drive displacement alongthe Vertex normal, using the Red Channel from the psuedorandom value generated previosuly to create soem variation in the displacement. The SineWave is jsut being used to preview, in the end we can jsut replace it with a scalar Parameter.</p>
<p><img src="WPO.png" alt="WPO.png"></p>
<p>If you wire the result from this into the world position output, you should see this result</p>
<p><img src="WPO.gif" alt="WPO.gif"></p>
<h2 id="Look-development"><a href="#Look-development" class="headerlink" title="Look development"></a><strong>Look development</strong></h2><h2 id="Generate-Procedural-Grid-using-UV-Coordinate"><a href="#Generate-Procedural-Grid-using-UV-Coordinate" class="headerlink" title="Generate Procedural Grid using UV Coordinate"></a><strong>Generate Procedural Grid using UV Coordinate</strong></h2><p>The tricky part here was getting the grid lines to line up perfectly with the edges on the mesh so that when each poly was dispalced outward they would have a perfect outline around them</p>
<p><img src="grid.png" alt="grid.png"></p>
<p>Multiplying the R and G channels of the UV coords iwth the X and Y subdivision of the sphere mesh, makes the grid lines match the number of edges on the mesh.If you preview the result form this network you will see it does.</p>
<p><img src="gridpre.png" alt="gridpre.png"></p>
<h2 id="Horizontal-Paning-Bar"><a href="#Horizontal-Paning-Bar" class="headerlink" title="Horizontal Paning Bar"></a><strong>Horizontal Paning Bar</strong></h2><p>This is done in localized world Space, could have jsut as easily used a Texture or used UV Coords to generate it.</p>
<p><img src="HorizontalPanningBar.png" alt="HorizontalPanningBar.png"></p>
<p>The result from this network</p>
<p><img src="panningbar.gif" alt="panningbar.gif"></p>
<h2 id="Combining-grid-and-Panning-Bar"><a href="#Combining-grid-and-Panning-Bar" class="headerlink" title="Combining grid and Panning Bar"></a><strong>Combining grid and Panning Bar</strong></h2><p>Next the Panning bar and Grid Results are combine together, by doing the following little bit of math</p>
<p><img src="combine.png" alt="combine.png"></p>
<p>If you preview the result from the power node, you wil lsee this</p>
<p><img src="grid.gif" alt="grid.gif"></p>
<p>If you wire in the results from this network into their respective shader inputs, you will get something that looks like this.</p>
<p><img src="gridresult.gif" alt="gridresult.gif"></p>
<h2 id="Random-Opacity-Curve"><a href="#Random-Opacity-Curve" class="headerlink" title="Random Opacity Curve"></a><strong>Random Opacity Curve</strong></h2><p>This section of the shader creates the opacity curve so that the ppoly’s appear randomly as the form the sphere</p>
<p><img src="baseopacity.png" alt="baseopacity.png"></p>
<p>Wire this into the opacity and you’ll get this result</p>
<p><img src="baseopacity.gif" alt="baseopacity.gif"></p>
<h2 id="Creating-an-Opacity-Curve-for-glow"><a href="#Creating-an-Opacity-Curve-for-glow" class="headerlink" title="Creating an Opacity Curve for glow"></a><strong>Creating an Opacity Curve for glow</strong></h2><p>If you look at the effect, you’ll notice that the glow does something interesting, each face glows bright before it becomes fully visible</p>
<p><img src="HoloSphere_V2.gif" alt="HoloSphere_V2.gif"></p>
<p>This is done by tweaking the opacity curve to have a quick bump as it almost reaches full value of 1.</p>
<p>If we think of the opacity curve as a linear gradient over time, it’ll look something like this.</p>
<p><img src="grad_01.png" alt="grad_01.png"></p>
<p>So what I we do is add a small bump around the 0.75 area where the value quickly climbs to 1</p>
<p><img src="grad_02.png" alt="grad_02.png"></p>
<p>Now if we add these two curves together we will get a gradient that has a bump right before it hits a value of one</p>
<p><img src="grad_03.png" alt="grad_03.png"></p>
<p>so here’s how we achieve that</p>
<p><img src="glowcurve.png" alt="glowcurve.png"></p>
<p>If you preview the result from this network you will see this.</p>
<p><img src="glowcurve.gif" alt="glowcurve.gif"></p>
<p>As you can see it uses the result from the sinewave and the RandomFacevalue to isolate gradient curve as it hits a value of 0.85, and adds a quick bump to the curve</p>
<p>The result from this network then gets added to the Opacity and Emissive sections as shown below to get teh final Effect.</p>
<h2 id="Opacity"><a href="#Opacity" class="headerlink" title="Opacity"></a><strong>Opacity</strong></h2><p><img src="Opacity_Final.png" alt="Opacity_Final.png"></p>
<h2 id="Emissive"><a href="#Emissive" class="headerlink" title="Emissive"></a><strong>Emissive</strong></h2><p><img src="Emissive_Final.png" alt="Emissive_Final.png"></p>
<p>And that gives us the final Effect, we can replace the sinewave with a Scalar Parameter and now we have a single Scalar parameter that controls the entire effect, the glow,opacity etc all work automatically.</p>
<p>To conclude here is a variation of the effect, in this one I force all the Random face values to go from 0-1 so that the sphere is fully formed and isn’t jsut partially formed.</p>
<p><img src="HoloSphere_01.gif" alt="HoloSphere_01.gif"></p>
<p><img src="HoloSphere_02.gif" alt="HoloSphere_02.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Post Process Glitch</title>
    <url>/2021/10/03/Post-Process-Glitch/</url>
    <content><![CDATA[<h1 id="Post-Process-Glitch"><a href="#Post-Process-Glitch" class="headerlink" title="Post Process Glitch"></a>Post Process Glitch</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post15.gif" alt="post15.gif"></p>
<p>This Post-Process effect came about after I saw this <a href="https://twitter.com/klemen_lozar/status/1017116328539217920">Tweet</a> from Klemen Lozar, it was neat little glitch effect, So I decided to take it a little further and try and make a Post0Process Glitch shader.</p>
<p><font color=red>Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h2><p>The Entire Shader is created procedurally and makes use of some of my Custom Noise Functions that I feature in my previous Glitch Effects breakdown, so be sure to read through that before following along with this one.</p>
<p>The effect basically has three layers</p>
<ol>
<li><p>Pixellation</p>
<p> <img src="pixellate.gif" alt="pixellate.gif"></p>
</li>
<li><p>RGB Offset</p>
<p> <img src="offset.gif" alt="offset.gif"></p>
</li>
<li><p>Color noise (Vertical/Horizontal)</p>
<p> <img src="colornoise.gif" alt="colornoise.gif"></p>
</li>
</ol>
<h2 id="Pixellation"><a href="#Pixellation" class="headerlink" title="Pixellation"></a><strong>Pixellation</strong></h2><p>This is a pretty common effect, it’s basically a UV trick where we multiple the UV’s with a resolution amount, round the values down so that each cell determined by resolution value only samples a single pixel to create the pixellated look, the lower the “Resolution” the more low-res it looks. We add one extra step to this we multiple the Resolution value by a psuedorandom scalar value, so that the resolution value varies over time to feel more glitch like. We also create a Psuedorandom cell mask to mask out the glitch so that it only appears at certain times on certain parts of the screen.</p>
<p><img src="pixellation_Whole.png" alt="pixellation_Whole.png"></p>
<p>Make sure the <strong>Scene Texture</strong> Node is set to use PostProcessInput0</p>
<p><img src="scenetexturesettings.png" alt="scenetexturesettings.png"></p>
<p>If you wire the result from the <strong>Node Marked 1</strong> directly into the Scene Textuer node you can see what the fully pixellated result looks like.</p>
<p><img src="pixellate.gif" alt="pixellate.gif"></p>
<p>The Pixellate Mask section basically uses the 2D Noise Function to create an Animated Black and White cell Mask in ScreenSpace that then Interpolates between regular Screen UV’s and the Pixellated Screen UV’s. If you plug the result from <strong>Round Node Marked 3</strong> directly into the emissive, You ucan see what the mask looks like</p>
<p><img src="pixellatemask.gif" alt="pixellatemask.gif"></p>
<p>Note that you can control the tiling of the mask by multiplying a scalar value with the U and V of the screen Coordinates, in this case I jsut left a default value of 3 for both, but you can create a parameter to control that as well.</p>
<p>We then use it to Interpolate between the Regular Screen UV’s and the Pixellated Screen Uv’s and feed that to the SceneTexture UV Input, for the Final Result:</p>
<p><img src="pixellate02.gif" alt="pixellate02.gif"></p>
<h2 id="RGB-Offset"><a href="#RGB-Offset" class="headerlink" title="RGB Offset"></a><strong>RGB Offset</strong></h2><p>The RGB offset is basically the same as what Klemen does in his shader, but instead of using a texture we use a psuedorandom cell noise function to drive the offset.</p>
<p><img src="RGB_Offset.png" alt="RGB_Offset.png"></p>
<p>The network of nodes under the section <strong>Offset Noise</strong> basically uses the Screen UV’s as input for the <strong>MF_Vec2Noise2D</strong> Function to generate some animated psuedorandom screenspace 2D CellNoise, we use this noise to offset the pixels of the screen, you can preview what this noise looks like by plugging in the result from <strong>MF_Vec2Noise2D</strong> into the emissive output:</p>
<p><img src="cellnoise.gif" alt="cellnoise.gif"></p>
<p>We take the result from the Noise Function and then multiple it by 3 different values for the Red , Green and Blue Channles respectively, we then add each of these to the Result from the Pixellated Screen UVs to get three different Uv results that will drive the Red,Green and Blue Channel of the Screen Buffer. If you preview the result from the <strong>MakeFlaot3</strong> you’ll see this.</p>
<p><img src="offset_02.gif" alt="offset_02.gif"></p>
<p>The section under <strong>Pixellate Offset Mask</strong> is basically the same thing that we did in the previous section, we are using the Noise function to generate a black an white cell mask which we will use to Interpolate between the Pixel Effect and the Offset Effect</p>
<p><img src="offsetmask.gif" alt="offsetmask.gif"></p>
<p>The last thing to do in this section is to just interpolate between the Pixellated Scene Texture Result and the Offset Scene Texture result using the PixelOffset Mask</p>
<p><img src="pixeloffset.gif" alt="pixeloffset.gif"></p>
<h2 id="RGB-Color-Noise"><a href="#RGB-Color-Noise" class="headerlink" title="RGB Color Noise"></a><strong>RGB Color Noise</strong></h2><p>This last section deals with adding some horizontal and vertical color streaks to try and mimic the glitchy effects you would see in old cable TV’s when the signal was messy. Here too we make use of our handy Custom Noise Functions</p>
<p><img src="colornoise.png" alt="colornoise.png"></p>
<p>The <strong>ColorGlitchMask</strong> section does the same thing as teh previous two sections it creates a black and white cell mask, that we will use later to mask out the areas where the RGB Color Streaks show.</p>
<p><img src="mask03.gif" alt="mask03.gif"></p>
<p>The two sections at the bottom <strong>CellNoise</strong> and <strong>HorizontalStreak</strong> use the <strong>MF_Vec3Noise3</strong> function to generate some screen space color(Vector3) noise as shown below respectively</p>
<p><img src="cellnoiseanimated.gif" alt="cellnoiseanimated.gif"></p>
<p><img src="horizontalnoise.gif" alt="horizontalnoise.gif"></p>
<p>The <strong>VerticalMsk and Horizaontal Mask</strong> sections are very similar to the previous mask we have created, in that they generate animated screen space Masks, in this case we isolate the V and U respectively to get Vertical Lines and Horizontal Lines as shown below</p>
<p><img src="verticalline.gif" alt="verticalline.gif"></p>
<p><img src="horizontalline.gif" alt="horizontalline.gif"></p>
<p>We then multiple the VerticleLine Mask with the result from cellnoise, and the result from the HorizontalLine Mask with the result from the horizontal Streak section and add both together before multiplying it with the overall <strong>GlitchColorMask</strong> which gives us the Final Result for the color Streaking</p>
<p><img src="streaking.gif" alt="streaking.gif"></p>
<p>The Last thing to do is take the result from the RGB Color Noise Section and Add it to the result from the last two sections to give us the Final Result, You can see the Entire Network Below</p>
<p><img src="Fullnetwork.png" alt="Fullnetwork.png"></p>
<p>And the Final Result</p>
<p><img src="Final.gif" alt="Final.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Post Process Scan Effect</title>
    <url>/2021/10/03/Post-Process-Scan-Effect/</url>
    <content><![CDATA[<h1 id="Post-Process-Scan-Effect"><a href="#Post-Process-Scan-Effect" class="headerlink" title="Post Process Scan Effect"></a>Post Process Scan Effect</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post04.gif" alt="post04.gif"></p>
<p>I got some free time this weekend in between school-work, and I decided to go back to doing some shader doodles, I came up with the Post-Process Scan Effect. I imagine it being used in a game as some sort distance based scan Effect.And we also use some simple noise distortion to make the scan effect look a little more interesting</p>
<p><font color=red>Note:If any of the images are not clear you can right-click and open in a new tab to view a Higher Resolution Version</font></p>
<p>In this section I’m going to breakdown how this effect was made in UE4, now there are multiple ways you could approach creating an effect like this, this jsut happens to be the method that I chose</p>
<h2 id="High-Level-Components"><a href="#High-Level-Components" class="headerlink" title="High Level Components"></a><strong>High Level Components</strong></h2><p>The basic idea behind this effect is to create a sobel-edge/modified version of the scene render and then blend it between the regular scene render based on a World-Space Sphere mask, and this mask is animated to create the scanning effect.</p>
<p>This effect is primarily a combination of 3 main pieces</p>
<ul>
<li><p>A Scaling Distance Field Sphere Mask</p>
</li>
<li><p>Sobel-Edge Post PRocess Function(I wont be expalining how this function works as it is a topic of its own, but I shall link the code I referenced)</p>
</li>
<li><p>World Projected Grid Texture Overlay</p>
</li>
</ul>
<h2 id="Scaling-Distance-Field-Sphere"><a href="#Scaling-Distance-Field-Sphere" class="headerlink" title="Scaling Distance Field Sphere"></a><strong>Scaling Distance Field Sphere</strong></h2><p>This deals with how we create the scaling sphere mask, we make use of a simple distance Field equation to create a sphere, here’s how it works.  </p>
<p><img src="DF_01_Nodes.JPG" alt="DF_01_Nodes.JPG"></p>
<p>Plug in the result of the clamp into the emissive output of your Post-Process Material, and u will see something like this in your viewport. </p>
<p><img src="DF_01.JPG" alt="DF_01.JPG"></p>
<p>“TexLoc” is a vector3 that defines the location of the origin of the sphere, in my case I have it being read from a Parameter Collection, so that it can be read from gmeplay to use for eg the Player Position, but this value basically represents the location of the center of the sphere mask.</p>
<p>The bbove bit of “Node-Code” basically defines a Distance Field Sphere with a radius of 1024 units, I used the clamp jsut to show the result in the viewport as the actualy values go muc hHigher than 1. If you would like a deepdive on distance Fields and their uses I highly reccomend checking out <a href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">Inigo Quillez’s website</a></p>
<p>Now we are going to use a Time Variable to Scale this Sphere Over Times</p>
<p><img src="DF_Scaling_Nodes" alt="DF_Scaling_Nodes"></p>
<p>This will result in something like this</p>
<p><img src="DF_Scaling.gif" alt="DF_Scaling.gif"></p>
<p>Frac(time) basically gives us a constant period that keeps going 0-1,0-1,0-1. We multiply time by a small number 0.25 to control the scaling speed and then we multiple ply the Fraction result with the radius of the sphere, this makes the radius go from 0-1024, tus giving us an animated sphere mask.</p>
<p>This is good progress, but this does not work for out effect, we need a scaling ring. This can be easily accomplished with a little bit of math on our current result.</p>
<p><img src="Edge_Mask.png" alt="Edge_Mask.png"></p>
<p>This will give us what we want, basically a growing ring, with a nice gradient falloff which can be controlled. </p>
<p><img src="Edge_Mask.gif" alt="Edge_Mask.gif"></p>
<p>The bit of math under “Edge Mask” basically samples a positon in the gradient of the distance Field, in this case 0.5 and defines an edge mask from that position with a specified width, this is what gives us a nice scaling ring. I will not go into too much detail aboutthis technique of edge masking, maybe I’ll cover it in mroe detail in another post.</p>
<p>As you can see whe have complete control over how wide the ring is with out scalar parameter, and if we wantedwe could even control the falloff with a power node, but that is not required forthis effect</p>
<p>The nest step is to use some noise, to create some interesting variation to the ring</p>
<p>For this we make use of UE4’s “Vector Noise Node”, you can read more about it <a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/ExpressionReference/Vector/#vectornoise">here</a>, you could alternatively just use a custom noise texture that has WorldALigned UV COordinates</p>
<p>In my Shader I set the Vector Noise Node to use “CellNoise”, feel free to experiment with other nosie types to get you own unique effect</p>
<p><img src="DF_Noise.png" alt="DF_Noise.png"></p>
<p>The result will look something like this </p>
<p><img src="DF_Noise.gif" alt="DF_Noise.gif"></p>
<p>This concludes the First Step of our shader, next we will look at the Implementing the Sobel-Edge Function</p>
<h2 id="Sobel-Edge-Function"><a href="#Sobel-Edge-Function" class="headerlink" title="Sobel Edge Function"></a><strong>Sobel Edge Function</strong></h2><p>There are many different variations of this function, some more optimized than others, I am not explain this function as it is a topic of it’s own, but a simple google search should give you an abundance of resources</p>
<p>The basic idea behind Sobel-Edge Detection is this, we take the scene RenderTarget(Imagine this as a texture that holds what you currently see in your viewport)and compare each pixel with all the neighbouring pixels around it, and we compare the difference in brightness, if the brightness difference is above a certain threshold, we mark it as an edge, and in this process we get a black and white mask texture of the scene rendertarget, that has the edges masked out.</p>
<p>The code below is a simple example of a sobelEdge Function made in Shadertoy by <a href="https://www.shadertoy.com/view/4t3XDM">RebelMoogle</a>(I think this one isn’t fully optimized, maybe try another one), we will recreate it in UE4 with the Material Nodes</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fragColor = 4.*abs(fwidth(texture(iChannel0, uv)));</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> TL = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> TM = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> TR = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> ML = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">0</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> MR = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">0</span>)/ iResolution.xy).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> BL = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">-1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> BM = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">-1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> BR = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">-1</span>)/ iResolution.xy).rgb;</span><br><span class="line">                         </span><br><span class="line">    <span class="type">vec3</span> GradX = -TL + TR - <span class="number">2.0</span> * ML + <span class="number">2.0</span> * MR - BL + BR;</span><br><span class="line">    <span class="type">vec3</span> GradY = TL + <span class="number">2.0</span> * TM + TR - BL - <span class="number">2.0</span> * BM - BR;</span><br><span class="line">   	</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* vec2 gradCombo = vec2(GradX.r, GradY.r) + vec2(GradX.g, GradY.g) + vec2(GradX.b, GradY.b);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    fragColor = vec4(gradCombo.r, gradCombo.g, 0, 1);*/</span></span><br><span class="line">    </span><br><span class="line">    fragColor.r = <span class="built_in">length</span>(<span class="type">vec2</span>(GradX.r, GradY.r));</span><br><span class="line">    fragColor.g = <span class="built_in">length</span>(<span class="type">vec2</span>(GradX.g, GradY.g));</span><br><span class="line">    fragColor.b = <span class="built_in">length</span>(<span class="type">vec2</span>(GradX.b, GradY.b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In UE4 it looks like this:</p>
<p><img src="SobelEdge_Nodes.png" alt="SobelEdge_Nodes.png"></p>
<p>A few notes about this setup make sure that your “SceneTexture” nodes are set to use “PostProcessInput0”</p>
<p><img src="SceneTexture_Settings.png" alt="SceneTexture_Settings.png"></p>
<p>The two Custom Nodes GradX and Grady, use the following:</p>
<p><img src="Sobel_Edge_Custom.png" alt="Sobel_Edge_Custom.png"></p>
<ul>
<li>GradX:</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> -TL + TR - <span class="number">2.0</span> * ML + <span class="number">2.0</span> * MR - BL + BR;</span><br></pre></td></tr></table></figure>
<ul>
<li>GradY:</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> TL + <span class="number">2.0</span> * TM + TR - BL - <span class="number">2.0</span> * BM - BR;</span><br></pre></td></tr></table></figure>

<p>This does not necessarily have to be done with a custom node, i used it merely for convenience sake, as otherwise it would have been too much node spaghetti.</p>
<p>If you plug in the end result of this Node Network to the emissive channel, you will see somthing like this in your Viewport</p>
<p><img src="SobelEdge.png" alt="SobelEdge.png"></p>
<p><img src="EdgeTinted.jpg" alt="EdgeTinted.jpg"></p>
<p>We also multiply this result with a simple Vector3 so that we can tint the edges whatever color we want</p>
<p><img src="EdgeTint.png" alt="EdgeTint.png"></p>
<h2 id="World-Aligned-Grid-Texture"><a href="#World-Aligned-Grid-Texture" class="headerlink" title="World-Aligned Grid Texture"></a><strong>World-Aligned Grid Texture</strong></h2><p>This part is easy we just use a simple grid texture and make it world aligned, and later combine it with the sobel-edge fucntion to get a cool BluePrint graph type effect</p>
<p><img src="WorldAlignedGrid.png" alt="WorldAlignedGrid.png"></p>
<p>If you plug this into the emissive, it looks like this</p>
<p><img src="WorldGrid.png" alt="WorldGrid.png"></p>
<h2 id="Bringing-it-All-Together"><a href="#Bringing-it-All-Together" class="headerlink" title="Bringing it All Together!"></a><strong>Bringing it All Together!</strong></h2><p>Now we will bring all three parts together, for the final Effect!</p>
<p>First we will combine the Sobel-Edge function and the World-Aligned Grid Function by adding them together</p>
<p><img src="SW.png" alt="SW.png"></p>
<p>Next we create a sceneTexture Node and add the result from the sobeledge and World Grid to it</p>
<p>Then we Interpolate between the regular sceneTexture and the Added one, using the result of the scaling ring mask we created in the first part</p>
<p><img src="FinalCombine.png" alt="FinalCombine.png"></p>
<p>And voila we are done, The end result will look something like this. You can of course tweak the parameters and try changing some values to get different results</p>
<p><img src="FinalResult.gif" alt="FinalResult.gif"></p>
<p>I hope you found this informative, cheers</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Rainy Surface Shader Part 1</title>
    <url>/2021/10/03/Rainy-Surface-Shader-Part-1/</url>
    <content><![CDATA[<h1 id="Rainy-Surface-Shader-Part-1"><a href="#Rainy-Surface-Shader-Part-1" class="headerlink" title="Rainy Surface Shader Part 1"></a>Rainy Surface Shader Part 1</h1><p><img src="post08.gif" alt="post08.gif"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h2><p>So this is going to be part 1 of a two parter that will cover how I created my <strong>Slope Aware Rainy Surface</strong> Material Function in UE4. This part is going to cover how to create rainy ripples/patters on surface that are hit directly by rain, so without further ado, lets get started!</p>
<h2 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a><strong>Textures</strong></h2><p>There are 2 main textures we need to author for this Maerial Function, the first one is an RGB Channel Packed Msk Texture for the droplet,streaks and streak gradient. It is important to author this texture with proper gradient values for the shader to work accurately.</p>
<p>You can grab my Texture <a href="RainPattern_basecolor.tga">here</a></p>
<p><img src="Texture_Packing.jpg" alt="Texture_Packing.jpg"></p>
<p>In this part, we are priamrily only going to be using the Red Channel with the droplet mask, in part 2 will make use of the other two channels to create the streaking effect</p>
<p>The other texture will be a normal map for the water droplets</p>
<p>Grab the normal texture <a href="RainPattern_normal.tga">here</a></p>
<p><img src="Droplet_Normal.jpg" alt="Droplet_Normal.jpg"></p>
<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a><strong>Basic Concept</strong></h2><p>The basic idea is to use <a href="https://www.youtube.com/watch?v=724ZMiQx200"><strong>Alpha Erosion</strong></a> on the Pattern in the Red Channel of our channel packed texture, with some additional math to create the ripples</p>
<p>So lets get started, create a new Material Function in UE4 and name it whatever you want, I called mine “MF_Ripples”(this is a temporary function, later in part 2 of this article we will combine what we create in this article) and set up the nodes as shown below</p>
<p><img src="nodes_01.png" alt="nodes_01.png"></p>
<p>The Above network creates a basic Alpha Erosion setup, since we are making a material function, I’ve also setup two Function Inputs to Control <strong>Tiling</strong> and <strong>Rain Speed</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">TextureSample2D.x - (<span class="number">1.0</span> - frac(time*RainSpeed));</span><br></pre></td></tr></table></figure>

<p>The above equation gives us a simple period going 0-1, 0-1, we subtract this value from the <strong>Red Channel</strong> of our Texture, which gives us the Aplha erosion Effect Seen below</p>
<p><img src="nodes_01_vis.gif" alt="nodes_01_vis.gif"></p>
<p>Now we can use some math to create a simple edge mask to that the expanding dot’s look like ripples instead. Take the result from the Subtract node and do the following:</p>
<p><img src="nodes_02.png" alt="nodes_02.png"></p>
<p>This will result in the edges of the dots getting masked out to give us something that looks like and expanding ripple</p>
<p><img src="nodes_02_vis.gif" alt="nodes_02_vis.gif"></p>
<p>This is pretty good, but the ripples appear and disappear too abruptly, we need to make them fade-in and fade-out over time to make it look more natural. We can achieve this with a little bit of math:</p>
<p><img src="nodes_03.png" alt="nodes_03.png"></p>
<p>The Time is multiplied by the <strong>RainSpeed</strong> variable we made earlier.</p>
<p>What we are doing is multiplying the result from the <strong>Edge Mask</strong> with a absolute sine-wave i.e without the negative part, it has a period that goes [1,0,1] instead of[1,0,-1,0,1]. We have also remapped the time in this sine-wave so that it goes [0,1,0] in the same time that it takes our alpha erosion Time Function to go from [0-1]. This is visualized in the graph below.</p>
<p>The Equation that we multiply is</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(<span class="built_in">sin</span>((Time*RainSpeed)*<span class="number">0.5</span>));</span><br></pre></td></tr></table></figure>

<p><img src="Time_Graph.gif" alt="Time_Graph.gif"></p>
<p>This result’s in a nice Fade-out of the ripples as they reach their maximum size, as shown below</p>
<p><img src="nodes_03_vis.gif" alt="nodes_03_vis.gif"></p>
<h2 id="Hiding-the-Time-Loop"><a href="#Hiding-the-Time-Loop" class="headerlink" title="Hiding the Time Loop"></a><strong>Hiding the Time Loop</strong></h2><p>This looks pretty good, but one big issue at the moment is that the rippling isn’t continuos, there is hard period where the ripples reset and start, we need to find a way to hide this effect, this can be achieved by creating a Time-Offset version of this current setup and combining the two together:</p>
<p>So copy and past the current node network and place it above so that current one make these small changes marked in the image</p>
<p><img src="nodes_04.png" alt="nodes_04.png"></p>
<p><font color=red>Note:Do not copy and paste the Input variables, just connect the existing ones to the second network of nodes:</font></p>
<p><font color=red>Note:I’ve also used a single time variable for both equations, so that the time offset is universal, and we don’t have to repeat it for each time node we use</font></p>
<p>So we’ve done two things, first we’ve offset the UV’s by 0.1 so that the second set of ripples aren’t in the same spot as our first group.</p>
<p>Next we add a time offset of 0.5, so that these ripples start and end with a 0.5s frequency offset compared to the first network.</p>
<p>You can see the two time frequencies visualized in the graph below</p>
<p><img src="Time_Offset.gif" alt="Time_Offset.gif"></p>
<p>Now we can blend between these two sets of ripples, with a Time function that is at exactly the same frequency to hide the abrupt starts and a get seamless ripples.</p>
<p><img src="Interp_Nodes.png" alt="Interp_Nodes.png"></p>
<p><font color=red>Note: Time is multiplied by the <strong>RainSpeed Variable</strong>.</font></p>
<p><img src="nodes_04_v2.png" alt="nodes_04_v2.png"></p>
<p>Now we use this Interpolation TIme Function as the alpha to Lerp between the two sets of ripples, which gives us seamless ripples.</p>
<p><img src="nodes_04_vis.gif" alt="nodes_04_vis.gif"></p>
<h2 id="Ripple-Normals"><a href="#Ripple-Normals" class="headerlink" title="Ripple Normals"></a><strong>Ripple Normals</strong></h2><p>The Normals for the ripples are starightforwad to set up, we just use the texture coordinates from the two sets of ripples and feed them to two seperate TextureSamples of teh same Normal Texture that I linked earlier, then we blend between these two normals, with the same Time Interpolation Function.</p>
<p><img src="Ripple_Normal.png" alt="Ripple_Normal.png"></p>
<h2 id="Wet-Surface-Water-LookDev-Inputs-from-Base-Materials"><a href="#Wet-Surface-Water-LookDev-Inputs-from-Base-Materials" class="headerlink" title="Wet Surface, Water LookDev, Inputs from Base Materials"></a><strong>Wet Surface, Water LookDev, Inputs from Base Materials</strong></h2><p>All the basic setups for the ripples are done, now we jsut need to setup ways to get Inputs from a base material(BaseColor,normal,metallic,roughness) so that we can blend in the ripples and wetness.The following sections will cover how to do that.</p>
<h2 id="BaseColor"><a href="#BaseColor" class="headerlink" title="BaseColor"></a><strong>BaseColor</strong></h2><p>For the BaseColor, we need to add a Function Input to Recieve the basecolor from the base material so that we can overlay the water color. We then overlay a water color and blend it using the ripplemask that we just created.</p>
<p>First add 4 Function Inputs <strong>WaterBrightness(Scalar),BaseColor(Vector3),WaterColor(Vector3),Metallic(Scalar)</strong></p>
<p><img src="nodes_05.png" alt="nodes_05.png"></p>
<p>We take the BaseColor Input and multiply it with the watercolor and then with the water brightness, this creates teh basecolor for the ripples.</p>
<p>We also take the basecolor and multiply it by 0.5 to make it darker in color, we do this becasue most surfaces become darker in color when wet, there are some exceptions mostly metals/non porous materials.This is why we use the Metallic input to lerp between the regular basecolor and the one that is multiplied to be darker.</p>
<p>We the ninterpolate between these to results with teh Ripple mask to create the final baseColor output.</p>
<p>Create a Function Output called <strong>Basecolor</strong> and plug it into that</p>
<p><img src="BaseColor_Output.png" alt="BaseColor_Output.png"></p>
<h2 id="Normal-Blending"><a href="#Normal-Blending" class="headerlink" title="Normal Blending"></a>Normal Blending</h2><p>In this section we create a function input to read the base material Normal Information and then overlay the ripple normals on top of it.</p>
<p><img src="nodes_06.png" alt="nodes_06.png"></p>
<p>We take the ripple normals we created earlier, and combine it with the base material normal info using the handy <strong>Blend Angle Corrected Normals Function</strong>, we then lerp between the base material normal and the overlayed normal using the ripplemask</p>
<p>We then create a Function Output called Normal and plug the result into it.If you preview the result, you will see that the ripple nomrals are overlayed:</p>
<p><img src="Normal_Output.png" alt="Normal_Output.png"></p>
<p><img src="nodes_05_vis.gif" alt="nodes_05_vis.gif"></p>
<h2 id="Metallic-Roughness"><a href="#Metallic-Roughness" class="headerlink" title="Metallic,Roughness"></a><strong>Metallic,Roughness</strong></h2><p>The metallic and roughness setups are pretty straight forward:</p>
<p>For Metallic we set up a function Input to read the Base Material Metallic value and we linear interpolate it with a value of 0.0(I’m not sure what the correct metallic value to use for water is but I liked 0.0,since..well water isn’t metal)using, again the ripplemask as the alpha and then plug it into a function output called Metallic.</p>
<p><img src="nodes_07.png%22" alt="nodes_07.png&quot;"></p>
<p>For the roughness as well we set up an Input function to read the Values from the Base Material, multiply it by a value of 0.5(because once a surface is wet, it tends to be shinier), and then Lerp it with a value of 0.0 using the ripplemask for the alpha.Then same as before we create Function Output for Roughness and plug it into that.</p>
<p><img src="nodes_08.png" alt="nodes_08.png"></p>
<p>And that’s pretty much all we need in our function for now, we can off create more ripple networks to add more variation, but for now this is enough, another thing we could do is add refraction options so that, the water actaully refracts and bends the light on the surface, this is something I’ll cover in part-2 when we look at streaking and slope awareness.</p>
<p>We could also blend between ripples and patters based on vertex painted puddles so that the ripples only appear in areas with puddles and it patters on solid surfaces. Again stuff that will be covered in part-2.</p>
<h2 id="Using-the-Function"><a href="#Using-the-Function" class="headerlink" title="Using the Function"></a><strong>Using the Function</strong></h2><p>Now in the detail’s panel we can expose the function to the library and access it in any of our other shaders, and alyer it.</p>
<p><img src="Expose.png" alt="Expose.png"></p>
<p>Below you can see how I’ve added teh function to one of epic’s default tile materials, jsut feed in teh appropraite inputs and use the outputs from teh function as inputs forthe base shader.</p>
<p><img src="MF_Ripple.png" alt="MF_Ripple.png"></p>
<p><img src="final_01.gif" alt="final_01.gif"></p>
<p><img src="final_02.gif" alt="final_02.gif"></p>
<p>I hope you found this useful, part 2 will cover slope awareness and streaking, and potentially creating a BP controlled Wind Actor to dynamically update streaking direction etc based on it. Coming Soon-ish!</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Rainy SurfaceShader in UE4 Part 2</title>
    <url>/2021/10/03/Rainy-Surface-Shader-Part-2/</url>
    <content><![CDATA[<h1 id="Rainy-SurfaceShader-in-UE4-Part-2"><a href="#Rainy-SurfaceShader-in-UE4-Part-2" class="headerlink" title="Rainy SurfaceShader in UE4 Part 2"></a>Rainy SurfaceShader in UE4 Part 2</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="Cam1_opt.gif" alt="Cam1_opt"></p>
<p>This is a continuation of the <a href="">first part</a>, so if you havn’t read that I recommend going through that first since this will continue where that left off, and you will need to be aware of that setup, so that you know how to combine both at the end..</p>
<p>Just as a side not, as I was writing this post, i actually came up with an even simpler and easier to use solution for this rain system, using just one Post-Process Material, I will cover that some other time</p>
<h2 id="Slope-Awareness"><a href="#Slope-Awareness" class="headerlink" title="Slope Awareness"></a><strong>Slope Awareness</strong></h2><p>So making the Function “slope aware” is actually incredibly simple, all we are doing is using a Z-gradient to blend betweek the Ripples Effect and the Streaking Effect that we create in this post.</p>
<p><img src="RainTest_T3.gif" alt="RainTest_T3"></p>
<p><img src="post05.gif" alt="post05"></p>
<p>Below you can see simple way to get a z-gradient</p>
<p><img src="z-gradient.png" alt="z-gradient"></p>
<p>The result looks like this</p>
<p><img src="z-gradient.gif" alt="z-gradient"></p>
<p>We use this result later to blend betweek the ripples and the water streaks</p>
<h2 id="Texture-Setup"><a href="#Texture-Setup" class="headerlink" title="Texture Setup"></a><strong>Texture Setup</strong></h2><p>So, if you remember the previous post, the texture setup we use is shown below, in this part we are going to make use of the Green and Blue Channels to make the water appear to drip.</p>
<p><img src="Texture_Packing.jpg" alt="Texture_Packing"></p>
<p>And the Normal Map</p>
<p><img src="texturenormal.png" alt="texturenormal"></p>
<h2 id="Droplet-Streaking-Setup"><a href="#Droplet-Streaking-Setup" class="headerlink" title="Droplet Streaking Setup"></a><strong>Droplet Streaking Setup</strong></h2><p>For the streaking, all we are actually doing is setting the texture to be World Aligned along the xz and yz axis, and then panning the gradient texture in the blue channel to create some simple alpha eroision, that makes the drops appear to streak.</p>
<p>First we create two input parameters, <strong>Streaks_Tiling</strong> and <strong>Streak_Length. RainSpeed</strong> was created in the last part, but it will be used for the streaking as well</p>
<p><img src="input_parameters.png" alt="input_parameters"></p>
<p>Next we set up the rain streaking texture to be world aligned along the xz and yz plane. We use the <strong>Green Channel</strong> which contains the streak pattern.</p>
<p><img src="worldalign.png" alt="worldalign"></p>
<p>We use the same <strong>RB</strong> and <strong>GB</strong> outputs as the uv input for the normal map as well.</p>
<p><img src="normal.png" alt="normal"></p>
<p>The result will look like this</p>
<p><img src="worldalign.gif" alt="worldalign"></p>
<p>Next we set up the world aligned panning setup for the gradient texture in the <strong>Blue Channel</strong></p>
<p><img src="gradientworldalign.png" alt="gradientworldalign"></p>
<p>The result has the texture mapped in world space and panning along the z-axis.</p>
<p><img src="gradientworldalign.gif" alt="gradientworldalign"></p>
<p>Now we take the result from the panning gradient texture, do some math operations to it and then subtract it from the original world aligned streak texture in the Green channel.</p>
<p>We also use the result from this to blend between a default normal color value and the World Aligned Normal Result</p>
<p><img src="streaking.png" alt="streaking"></p>
<p>If you preview the result from the <strong>StreakMask</strong> and the <strong>Normal</strong> you will see the following results respectively</p>
<p><img src="streakmask.gif" alt="streakmask"><img src="streaknormal.gif" alt="streaknormal"></p>
<p>The panning gradient creates an alpha erosion effect, that creates the illusion of dripping water</p>
<p>Note:There is a better solution for the Dripping water, I will cover that in one of my future posts.</p>
<h2 id="Combining-with-Ripple-Effect"><a href="#Combining-with-Ripple-Effect" class="headerlink" title="Combining with Ripple Effect"></a><strong>Combining with Ripple Effect</strong></h2><p>Now all that’s left to do is blend between this streaking effect and the ripple effect using the z-gradient we created earlier in the post</p>
<p>This is the part where you will need to refer to the previous blog post, as we are essentially just adding a lerp for all the function outputs from the previous blog post, you can read it here</p>
<p>Find the normal output taht was setup in the previous Post and add a linear interpolation between the ripple normal and the streak normal</p>
<p><img src="normalblend.png" alt="normalblend"></p>
<p>Do the same for the mask as well</p>
<p><img src="maskblend.png" alt="maskblend"></p>
<p>Note: The result from this output will now take the place of all hte places where the ripple mask was being used to blend, like <strong>Basecolor,Metallic etc</strong></p>
<p><img src="result.gif" alt="result"></p>
<p>And that’s it now you ahve a material function that can be layered to any existing shader to make it look like the surface is being rained on, with parameters to control ripple size, rainspeed etc.</p>
<p><img src="MaterialFunction.png" alt="MaterialFunction"></p>
<p>Here’s a small test Environment I put together to show how the shader looks in a scene. All the materials used in the scene have the RainySurfaceMaterial function layered on them.</p>
<p><img src="Cam1_opt.gif" alt="Cam1_opt"></p>
<p><img src="Cam3_opt.gif" alt="Cam3_opt"></p>
<p><img src="Cam4_opt.gif" alt="Cam4_opt"></p>
<p><img src="Cam5_opt.gif" alt="Cam5_opt"></p>
<p><img src="Cam6_opt.gif" alt="Cam6_opt"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Star Wars Inspired Hologram Shader and Blueprint System</title>
    <url>/2021/10/03/Star-Wars-Hologram/</url>
    <content><![CDATA[<h1 id="Star-Wars-Inspired-Hologram-Shader-and-Blueprint-System"><a href="#Star-Wars-Inspired-Hologram-Shader-and-Blueprint-System" class="headerlink" title="Star Wars Inspired Hologram Shader and Blueprint System"></a>Star Wars Inspired Hologram Shader and Blueprint System</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post11.gif" alt="post11.gif"></p>
<p>I wanted to do this little shader because I had been watching a lot of the <strong>The Clone Wars</strong> animated show lately, and I wanted to recreate the holograms from the show, I really like the iconic star wars hologram effect, it’s very simple yet effective.</p>
<p>I decided to try and make my system easily re-usable within a game development context, so I created a blueprint system to encapsulate the hologram system, which lets you assign any asset you want to be shown as a hologram. The Majority of the effect is handled by two shaders, and the blueprint setup is a convenient way to make the system re-usable as a game object.</p>
<p><font color=red>Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<p><img src="post11_V2.gif" alt="post11_V2.gif"></p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a><strong>Setup</strong></h2><p>The system makes use of two meshes:</p>
<h2 id="Base-Cylinder"><a href="#Base-Cylinder" class="headerlink" title="Base Cylinder"></a><strong>Base Cylinder</strong></h2><p><img src="cylinder.gif" alt="cylinder.gif"></p>
<p>The base cylinder is jsut a cylinder with no caps, and the pivot aligned to the bottom center(This is important). We use this as the hologram base projection, using a shader we will reshape it an animate it.</p>
<h2 id="Hologram-Asset"><a href="#Hologram-Asset" class="headerlink" title="Hologram Asset"></a><strong>Hologram Asset</strong></h2><p><img src="scope.png" alt="scope.png"></p>
<p>This can be any asset, in my case I’m using a scope I modelled a while back as my asset.</p>
<p>Each of these objects will get a unique shader with similar look-dev and some shared parameters so that they work together.</p>
<h2 id="Setting-up-the-Parameter-Collection"><a href="#Setting-up-the-Parameter-Collection" class="headerlink" title="Setting up the Parameter Collection"></a><strong>Setting up the Parameter Collection</strong></h2><p>First we setup an MPC for the shared parameters</p>
<p><img src="MPC.png" alt="MPC.png"></p>
<ul>
<li><strong>Activation</strong>:Scalar parameter that controls the hologram’s on/off status.</li>
<li><strong>Turbulance_Amt</strong>:Scalar parameter that controls how much turbulance/distortion affects the hologram.</li>
<li><strong>Turbulance_Displacement</strong>:Scalar parameter that controls the amount of dispalcement in the turbulance.</li>
</ul>
<h2 id="Hologram-Shader-1-Assigned-to-Cylinder-Mesh"><a href="#Hologram-Shader-1-Assigned-to-Cylinder-Mesh" class="headerlink" title="Hologram Shader 1: Assigned to Cylinder Mesh"></a><strong>Hologram Shader 1: Assigned to Cylinder Mesh</strong></h2><p>Generate Z-Gradient to drive Scaling of the mesh in the shader, for activation/deactivation.</p>
<h2 id="Node-Network-to-generate-z-gradient"><a href="#Node-Network-to-generate-z-gradient" class="headerlink" title="Node Network to generate z-gradient"></a><strong>Node Network to generate z-gradient</strong></h2><p><img src="zgradient_nodes.png" alt="zgradient_nodes.png"></p>
<h2 id="Node-Network-to-control-scaling-Expansion"><a href="#Node-Network-to-control-scaling-Expansion" class="headerlink" title="Node Network to control scaling/Expansion"></a><strong>Node Network to control scaling/Expansion</strong></h2><p><img src="dimensionscaling_nodes.png" alt="dimensionscaling_nodes.png"></p>
<p>The result from the z-gradient is used to drive the WorldPosition offset logic that controls the height and expansion of the cylinder.</p>
<p>The <strong>Activation</strong> parameter is a scalar value that controls the height of the cylinder (0 = squished, 1 = fully expanded height)</p>
<p>The <strong>spreadfactor</strong> parameter is a scalar value that controls the radius spread of the top part of the cylinder(Ths is in world units)</p>
<p>You can see the result from tweaking these two parameters below</p>
<p><img src="gradientscaling.gif" alt="gradientscaling.gif"></p>
<h2 id="Adding-Turbulance-to-WorldPosition-Offset-for-Glitchiness"><a href="#Adding-Turbulance-to-WorldPosition-Offset-for-Glitchiness" class="headerlink" title="Adding Turbulance to WorldPosition Offset for Glitchiness"></a><strong>Adding Turbulance to WorldPosition Offset for Glitchiness</strong></h2><p>Next we generate psuedorandom noise in screen space and use it to add some Turbulance to the WorldPosition Offset to create some glitchiness. The setup is shown below</p>
<p><img src="turbulance_nodes.png" alt="turbulance_nodes.png"></p>
<p><strong>TurbulanceAmt</strong> is a scalar parameter that controls how much turbulance is present(0=no turbulance, 1 = full turbulance)</p>
<p><strong>Turbulance_Dispalcement</strong> controls how extreme the dispalcement is.(This value is in world units)</p>
<p>The result from this gets added to the resut from Scaling/Expansion and that creates teh final output for the WorldPositionOffset of the Shader.</p>
<h2 id="ScreenSpace-2D-Noise-Visualized"><a href="#ScreenSpace-2D-Noise-Visualized" class="headerlink" title="ScreenSpace 2D Noise Visualized"></a><strong>ScreenSpace 2D Noise Visualized</strong></h2><p><img src="2DNoiseVisualize.gif" alt="2DNoiseVisualize.gif"></p>
<h2 id="Final-WorldPositionOffset-Result"><a href="#Final-WorldPositionOffset-Result" class="headerlink" title="Final WorldPositionOffset Result"></a><strong>Final WorldPositionOffset Result</strong></h2><p><img src="WPO.gif" alt="WPO.gif"></p>
<p>It looks weird now, but once we add the look-dev, it works quite well</p>
<h2 id="Look-Development"><a href="#Look-Development" class="headerlink" title="Look Development"></a><strong>Look Development</strong></h2><h2 id="Screen-Space-Parallel-Bars"><a href="#Screen-Space-Parallel-Bars" class="headerlink" title="Screen Space Parallel Bars"></a><strong>Screen Space Parallel Bars</strong></h2><p>We use a little bit of UV math to create screen space panning parallel bars, we also do some math with the camera position and object position to make sure that the screen space bar’s continue tiling consistently regardless of distance from the screen</p>
<p><img src="ScreenSpaceBars.png" alt="ScreenSpaceBars.png"></p>
<p>If you preview the result from this network, it will look like this(I preview it by wiring it into the basecolor,opacity and emissive)</p>
<p><img src="bars.gif" alt="bars.gif"></p>
<h2 id="Fresnel-and-CameraFade"><a href="#Fresnel-and-CameraFade" class="headerlink" title="Fresnel and CameraFade"></a><strong>Fresnel and CameraFade</strong></h2><p>Next we setup a fresnel and CameraFade that will later be used to drive the opacity.</p>
<p><img src="fresnelcamerafade.png" alt="fresnelcamerafade.png"></p>
<h2 id="Fresnel-Result"><a href="#Fresnel-Result" class="headerlink" title="Fresnel Result"></a><strong>Fresnel Result</strong></h2><p><img src="fresnel.gif" alt="fresnel.gif"></p>
<h2 id="CameraFade-Result"><a href="#CameraFade-Result" class="headerlink" title="CameraFade Result"></a><strong>CameraFade Result</strong></h2><p><img src="camerafade.gif" alt="camerafade.gif"></p>
<h2 id="Color-and-Opacity"><a href="#Color-and-Opacity" class="headerlink" title="Color and Opacity"></a><strong>Color and Opacity</strong></h2><p>Next we create the main graph network for the color, Emissive and Opacity, this is driven primarily by the result from the z-gradient and Activation Parameter, I combine it with the results from <strong>ScreenSpace bars, Fresnel and CameraFade</strong> for the final color,Emissive and Opacity.</p>
<p><img src="coloropacity.png" alt="coloropacity.png"></p>
<p>The result from the DepthFade(DepthFade is to prevent hard clips through geometry) node goes into Opacity, and the result from the color multiply drives the emissive and the base color.</p>
<p>The end result is this, with parameters to control activation,turbulance and spread.</p>
<p><img src="cylinderresult.gif" alt="cylinderresult.gif"></p>
<h2 id="Hologram-Shader-2-Assigned-to-Game-Mesh"><a href="#Hologram-Shader-2-Assigned-to-Game-Mesh" class="headerlink" title="Hologram Shader 2: Assigned to Game Mesh"></a><strong>Hologram Shader 2: Assigned to Game Mesh</strong></h2><p>This shader will be pretty identical to the previous one assigned to the cylinder but with a few changes so that it works with complex meshes</p>
<h2 id="WorldPosition-Offset-Setup-for-Activation"><a href="#WorldPosition-Offset-Setup-for-Activation" class="headerlink" title="WorldPosition Offset Setup for Activation"></a><strong>WorldPosition Offset Setup for Activation</strong></h2><p>The setup below controls the scaling and Opacity</p>
<p><img src="WPO_scope.png" alt="WPO_scope.png"></p>
<p>The result from the z-gradient drives the opacity and the result from the WorldPosition Math drives the scaling of the Mesh.</p>
<p>In this case when I generate the z-gradient I add 160(Height of the cylinder mesh) to the z-channel, this is so that the scaling happens within the scale of the base cylinder.</p>
<p>by sliding the value of <strong>Activation</strong> from 0 - 2 you will see the following result.</p>
<p><img src="WPO_scope.gif" alt="WPO_scope.gif"></p>
<h2 id="Turbulance"><a href="#Turbulance" class="headerlink" title="Turbulance"></a><strong>Turbulance</strong></h2><p><font color=red>Note: The Rotation is handled in the BLueprint and is covered in the last section, doing the rotation in the shader resulted in some errors when doing the look development,because vertex normals weren’t recalculated for the fresnel. More on that later.</font></p>
<p>Next I add some math to create some turbulance.</p>
<p>The turbulance section is very similar to what was done in the previous shader, we generate some screen space noise, and use it to distort the WorldPosition of the mesh.</p>
<p><img src="turbulancerotation.png" alt="turbulancerotation.png"></p>
<p>The Function <strong>MF_FloatNoise2D</strong> takes a vec2 and returns a psuedorandom float as the result.The node network for it is shown below.</p>
<p><img src="MF_FloatNoise2D.png" alt="MF_FloatNoise2D.png"></p>
<h2 id="Screen-Space-Noise-Visualized"><a href="#Screen-Space-Noise-Visualized" class="headerlink" title="Screen Space Noise Visualized"></a><strong>Screen Space Noise Visualized</strong></h2><p><img src="turbulancevisualize.gif" alt="turbulancevisualize.gif"></p>
<p>Wiring the result from this network into the WorldPositionoffset, will look like this, we also have the <strong>Turbulance_Amt</strong> parameter which can be used to animate/control the turbulance as shown below</p>
<p><img src="turbulancerotate.gif" alt="turbulancerotate.gif"></p>
<p>The result from the <strong>Turbulance</strong>section and the initial <strong>z-gradient WorldPositonOffset</strong> result gets added together to give us the final output that get’s wired into the WorldPositionOffset input for the shader.</p>
<p>Now, we have a setup with parameters to control activation as well as turbulance</p>
<p><img src="finalwpo.gif" alt="finalwpo.gif"></p>
<h2 id="Look-Development-1"><a href="#Look-Development-1" class="headerlink" title="Look Development"></a><strong>Look Development</strong></h2><p>This part is identical to what we did in the previous shader.</p>
<p>One thing we could have done here, is used the <strong>object’s baked Normal Map</strong> and used that to calculate the fresnel,this is nice because the baked normal gives us more surface details to work with, and thus results in a much more detailed fresnel, but I have avoided this here because I found it difficult to make this work with a re-usable Blueprint System, especially when sometimes meshes have multiple material ID’s with multiple normal maps. So for now we just stick to using the <strong>Vertex Normals</strong>.</p>
<p><img src="lookdev.png" alt="lookdev.png"><br><img src="//lookdev.png" width="1024"></p>
<p>The results from these networks gives us our Emissive Color and our opacity outputs.Now we have a shader with parameters to control <strong>activation,turbulance and color.</strong>&gt;As you can see below.</p>
<p><img src="lookdevscope.gif" alt="lookdevscope.gif"></p>
<p><img src="lookdevactivation.gif" alt="lookdevactivation.gif"></p>
<p><img src="lookdevturbulance.gif" alt="lookdevturbulance.gif"></p>
<p><img src="lookdevcolor.gif" alt="lookdevcolor.gif"></p>
<p>Put both meshes together in the scene and try tweaking the activation parameter in the MPC.</p>
<p><img src="comp1.gif" alt="comp1.gif"></p>
<h2 id="Encapsulating-into-a-Blueprint"><a href="#Encapsulating-into-a-Blueprint" class="headerlink" title="Encapsulating into a Blueprint"></a><strong>Encapsulating into a Blueprint</strong></h2><p>Now i just set up a simple blueprint for ease of use.</p>
<p>The BP has two parts, the <strong>construction script</strong> which handles bulk of the work, choosing meshes,materials,postioning etc and the Event Graph which will handle rotation during runtime.</p>
<h4 id="Components-and-Variables"><a href="#Components-and-Variables" class="headerlink" title="Components and Variables"></a><strong>Components and Variables</strong></h4><p>I expose certain variables, so that they can be tweaked in the editor</p>
<p><img src="viewport.png" alt="viewport.png"></p>
<h2 id="Construction-Script"><a href="#Construction-Script" class="headerlink" title="Construction Script"></a><strong>Construction Script</strong></h2><p>The first part of the construction script creates the Dynamic Material Instances and assigns the material to the Cylinder Mesh</p>
<p><img src="cs_p1.png" alt="cs_p1.png"></p>
<p>I wanted the BP to have the ability to pick between using a skeletal mesh with animation or a regular static mesh, the following sections set up the Mesh part</p>
<p><img src="cs_p2.png" alt="cs_p2.png"></p>
<p>Continueing from the last section, sometimes meshes have multiple material id’s, so we use a For Loop to cycle through all the Material Indexes and assign the Hologram Material to Each Part</p>
<p><img src="cs_p3.png" alt="cs_p3.png"></p>
<p>Objects tend to have pivot inconsistant pivot locations, so we have a parameter available so that we can compensate for any offsets manually. We also use the objectbounds to calculate the <strong>SpreadFactor</strong> that is fed into the cylinder’s Hologram Shader</p>
<p><img src="cs_p4.png" alt="cs_p4.png"></p>
<h2 id="Event-Graph"><a href="#Event-Graph" class="headerlink" title="Event Graph"></a><strong>Event Graph</strong></h2><p>The event graph is only used if we enable mesh rotation, it is used to rotation the object at runtime.</p>
<p><img src="eventgraph.png" alt="eventgraph.png"></p>
<p>Now if we drop the Blueprint into the level and select it it should have all these parameters</p>
<p><img src="parameters.png" alt="parameters.png"></p>
<p>Now we have a blueprint that we can use to assign any mesh we have to use in the hologram system, we can choose to use a skeletal mesh with animations or just a regular StaticMesh. As well as parameters to control activation,turbulance etc.</p>
<p><img src="SkelHolo_opt.gif" alt="SkelHolo_opt.gif"></p>
<p><img src="holoskull.gif" alt="holoskull.gif"></p>
<p><img src="SM_Holo1_opt.gif" alt="SM_Holo1_opt.gif&quot;"></p>
<p><img src="SM_Holo2_opt.gif" alt="SM_Holo2_opt.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Teleportation Shader</title>
    <url>/2021/10/03/Teleportation-Shader/</url>
    <content><![CDATA[<h1 id="Teleportation-Shader"><a href="#Teleportation-Shader" class="headerlink" title="Teleportation Shader"></a>Teleportation Shader</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post13.gif" alt="post13"></p>
<p>This small shader effect came out of another shader I was making that was inspired by this <a href="https://twitter.com/phi6/status/989638191949975552">Fog of War Effect</a> I came across on twitter. I then modified the Material Function to work as Teleportation Shader Effect</p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a><strong>Setup</strong></h2><p>Like a lot of my other Fx Shaders, this one is also wrapped into a Material Function for easy Re-usability. This one is actually quite similar to the glitch effect and use a lot of the same concepts.The basic idea for this effect is to use a linear gradient along the z-Axis of the object to create an opacity Mask, we combine the mask with some Noise Patterns to make it look more interesting, then we add some Vertex Deformation to add some more interest to the effect.</p>
<p><font color=red>Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<p>This is what the initial setup for the material function looks like, we take an entire Base Material as the input and we add shader effects on top of it.</p>
<p><img src="MF_Setup.png" alt="MF_Setup"></p>
<h2 id="Localized-Z-Gradient-mask"><a href="#Localized-Z-Gradient-mask" class="headerlink" title="Localized Z-Gradient mask"></a><strong>Localized Z-Gradient mask</strong></h2><p>First we create a localized linear z-gradient based on the object bounds, please note this setup assumes that the object’s pivot is located at it’s base, if not you would need to add the necessary offset value for the offset input.</p>
<p><img src="z-gradient_01.png" alt="z-gradient_01"></p>
<p>Previewing this result, will result in a linear gradient from top to bottom.</p>
<p><img src="gradient_01.gif" alt="gradient_01"></p>
<p>Next we create an inverted version of the gradient which we will use later to drive vertex Deformation, and we also subtract a scalar Parameter that we can use to drive the effect. Note that I am using a Sine wave to preview the result, in the end the effect is controlled with a Scalar Parameter value going from 0-1</p>
<p><img src="z-gradient_02.png" alt="z-gradient_02"></p>
<p>If you preview A and B respectively you will see the following results, as you can see we are using the “Transition” Scalar input(0-1) to drive the gradient, which in turn will drive the Opacity mask and the Vertex Deformation later.</p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a><strong>A</strong></h2><p><img src="gradient_A.gif" alt="gradient_A"></p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a><strong>B</strong></h2><p><img src="gradient_B.gif" alt="gradient_B"></p>
<h2 id="Noise-Pattern"><a href="#Noise-Pattern" class="headerlink" title="Noise Pattern"></a><strong>Noise Pattern</strong></h2><p>Next we setup an animated cell noise pattern to drive the effect, <strong>MF_Vec3Noise3</strong> is a Material Function that generates a psuedorandom Vector given an input, I cover this in a previous post you can read it <a href="https://deepspacebanana.github.io/">here</a>.We also create an Input varaible <strong>Number_Tiling</strong> so that we can control the tiling of the noise in the Base Shader. Note that this setup can be repalced with any kind of world Aligned Noise Pattern Texture to achieve different effects. I will show some examples at the end of teh blog.</p>
<p><img src="Noise_01.png" alt="Noise_01"></p>
<p>if you preview the results from the Red or Green Channel, you will see similar results, we use the green channel to drive the emissive later, and we will use the red channel to distort the opacity result</p>
<p><img src="Noise_G.gif" alt="Noise_G"></p>
<h2 id="Opacity-Mask"><a href="#Opacity-Mask" class="headerlink" title="Opacity Mask"></a><strong>Opacity Mask</strong></h2><p>To get the final Opacity Mask, we take the <strong>Result from A</strong> and subtract the result from the <strong>Red Channel</strong> of the Noise Pattern, and round to the highest value. This result gets plugged into the Opacity Mask Output.</p>
<p><img src="opacity.png" alt="opacity"></p>
<p>Previweing this result will show the following</p>
<p><img src="opacity_p_01.gif" alt="opacity_p_01"></p>
<h2 id="Vertex-Deformation"><a href="#Vertex-Deformation" class="headerlink" title="Vertex Deformation"></a><strong>Vertex Deformation</strong></h2><p>Next we use the result from <strong>z-gradient B</strong> to displace the meshes Vertices Along the z-Axis to create the effect of being beamed up, we also use some noise to distort the deformation to add some visual interest, once again this noise can be repalced with different patterns to achieve different effects, we use Vector(0,0,1) to control the direction of the displacement. The result from this network goes into the WorldPositionOffset output.</p>
<p><img src="VertexDeformation.png" alt="VertexDeformation"></p>
<p>We have two input variabes <strong>Noise_Tiling</strong> to control the tiling of the noise pattern and <strong>Displacement_Amt</strong> to control how far along the z-axis the Vertices get Displaced.The result looks like this</p>
<p><img src="VertexDeformation.gif" alt="VertexDeformation"></p>
<h2 id="Emissive"><a href="#Emissive" class="headerlink" title="Emissive"></a><strong>Emissive</strong></h2><p>In this last section we use the Noise Pattern to add some emissive to the effect to finish it off. We use a seperate scalar Parameter called <strong>GlowPatternControl</strong> to control the emissive Transition, I did this so that we can have more artistic control over the timings of the effect, we could just as easily have this controlled by the <strong>z-gradient</strong> or the <strong>Transition Scalar Parameter</strong>. We also have a another input variable <strong>Glow_Color</strong> to control the color of the emissive glow.</p>
<p><img src="emissive.png" alt="emissive"></p>
<p>Previweing the result from this network</p>
<p><img src="emissive.gif" alt="emissive"></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>And there you have it, now you should have a material function with the following inputs that you can add to any shader</p>
<p><img src="MF_Node.png" alt="MF_Node"></p>
<p>Here’s the full Material Graph for reference</p>
<p><img src="completegraph.png" alt="completegraph"></p>
<p>Here are some variations using different patterns.</p>
<p><img src="Line_01.gif" alt="Line_01"></p>
<p><img src="ManCube_01.gif" alt="ManCube_01"></p>
<p><img src="ManNumbers.gif" alt="ManNumbers"></p>
<p><img src="ManTriangle.gif" alt="ManTriangle"></p>
<p><img src="Tesseract_Gif_01.gif" alt="Tesseract_Gif_01"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：UE4 Apparition Material</title>
    <url>/2021/10/03/UE4-Apparition-Material/</url>
    <content><![CDATA[<h1 id="UE4-Apparition-Material"><a href="#UE4-Apparition-Material" class="headerlink" title="UE4 Apparition Material"></a>UE4 Apparition Material</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post06.gif" alt="post06.gif"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h2><p>This was a simple apparition material I came up with when I was messing around with Inigo Quillez’s distance field functions. This shader uses a scaling Distance Field Sphere as a mask transition the opacity, then we use some vdb textures to make the transition look interesting.</p>
<h2 id="The-Sphere-Mask"><a href="#The-Sphere-Mask" class="headerlink" title="The Sphere Mask"></a><strong>The Sphere Mask</strong></h2><p>This part is basically the same as what I did in my Post-Process Scan Effect Article with only one difference, please refer to that post for an explanation of how we set up the animated distance field,</p>
<p><img src="DistanceFieldSphere.png" alt="DistanceFieldSphere.png"></p>
<p>As you can see the only big difference is that here we use the objects position instead of a Vector3 Paramter, technically you can add or subtract values from the object position to position the Distance Field Sphere as you like.</p>
<p>If you plug in the result from this network to the material’s <strong>Opacity Mask</strong> input, you will see something like this</p>
<p><img src="DF_Masking.gif" alt="DF_Masking.gif"></p>
<p>As you can see the Distance Field Sphere creates a spherical Apparition shape forthe mesh, you can technicaly use any kind of Distance Field Function you want, so any kind of shape is possible, the sphere is the simples and cheapest i nterms of instruction count</p>
<p>In the next step we are going to use some pattern textures to make the effect look more interesting, and then finally we will combine it with some emissives for the finishing touch</p>
<h2 id="Pattern-Texture"><a href="#Pattern-Texture" class="headerlink" title="Pattern Texture"></a><strong>Pattern Texture</strong></h2><p>I am using a Texture with three different greyscale patterns packed into each channel to drive the effect, here is what my setup looks like:</p>
<h2 id="Binary-Generator-tga"><a href="#Binary-Generator-tga" class="headerlink" title="Binary_Generator.tga"></a><strong>Binary_Generator.tga</strong></h2><p><img src="TextureSetup.jpg%22" alt="TextureSetup.jpg&quot;"></p>
<p>Now we will combine the gresycale information from the Pattern to modify the mask as shown below:</p>
<p><img src="Noise_Combine.png" alt="Noise_Combine.png"></p>
<p>As you can see we subtract the Red channel of the pattern texture from the result of the Distance Field Function to create the value difference at the edges that brings in the pattern, into the mask function. We also multiply the red channel by a scalar Parameter <strong>MaskSpread</strong>(note:As you increase the spread value, you will also need to increase the radius of the DF Sphere to compensate for the spread so that the entire mesh is covered in the transition, i.8 mutliple the objectradius by a higher value.), which controls the spread of teh noise values from the edges, if we increase this value, you will get more noise spread</p>
<p>If we preview the clamp node, we will get a preview of what the mask looks like now:</p>
<p><img src="MaskNoisePre.gif" alt="MaskNoisePre.gif"></p>
<h2 id="Edge-Masking-for-Emissive"><a href="#Edge-Masking-for-Emissive" class="headerlink" title="Edge Masking for Emissive"></a><strong>Edge Masking for Emissive</strong></h2><p>In this section we will create and edge mask, so that the edges of the transition can be highlighted with an emissive color, this setup is also borrowed from my Post-Process Scan Effect Article so read about it there for a full explanation.</p>
<p><img src="EdgeMask.png" alt="EdgeMask.png"></p>
<p>What I have done here is basically take the Mask Field (Result of the Subtract node) and run it through an Edge Mask Function,This basically masks the edges of the Distance Field Sphere ,this gives us the result shown below wich we will sue to lerp with an emissive value for the edges</p>
<p><img src="EdgeMask.gif" alt="EdgeMask.gif"></p>
<h2 id="Final-Touches"><a href="#Final-Touches" class="headerlink" title="Final Touches"></a><strong>Final Touches</strong></h2><p>Now we just plug in the emissive mask and Opacity Mask to their respective inputs</p>
<p><br>All we have to do now is multiply the emissive mask with an Emissive Color Value and plug that output into the Emissive input of the material, and plug our Opacity Mask output to the opacity input of the material, and Voila we are done!</p>
<p><img src="Final_Nodes.png" alt="Final_Nodes.png"></p>
<p><img src="CubeGif_02.gif" alt="CubeGif_02.gif"></p>
<p>You can of course, swap out the patterns used to get different effects as well as tweak teh different parameters in the shader to get variations, here’s a couple I made with just adjusting values and changing patterns.</p>
<p><img src="NumberGif_02.gif" alt="NumberGif_02.gif"></p>
<p><img src="NumbersGif_01.gif" alt="NumbersGif_01.gif"></p>
<p>I hope you found this articel useful! Cheers!</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Wormhole Shader Effect</title>
    <url>/2021/10/03/Wormhole-Shader-Effect/</url>
    <content><![CDATA[<h1 id="Wormhole-Shader-Effect"><a href="#Wormhole-Shader-Effect" class="headerlink" title="Wormhole Shader Effect"></a>Wormhole Shader Effect</h1><p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post07.gif" alt="post07.gif"></p>
<p>This effect is actually just a re-working of one of my old doodles, the effects is quite simple, but it seemed like a really nice use-case. I’ve seen similar effects being used for “Loot Pickup Effects” in games. It is a basic Vertex Deformation Shader under the hood</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>This effect basically uses a Vector3 input(Location of wormhole i.e area that sucks in geometry) to generate a Distance Gradient, then the pixels that are inside this sphere get sucked towards the center with a falloff controlled by the gradient strength. we will be creating this as a material Function inside UE4 so that it can be easily applied to any existing material that we have. So let’s get started!</p>
<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a><strong>Basic Concept</strong></h2><p>The basic concept behind this effect is to use a world space Distance Field Sphere Mask to blend between two different WorldPosition Offsets, one is the central location of the mask i.e center of the wormhole and the other is the regular location of the pixels in the world</p>
<h2 id="Initial-Setup"><a href="#Initial-Setup" class="headerlink" title="Initial Setup"></a><strong>Initial Setup</strong></h2><p>First there are a couple setups we need to make, so that we can feed the location of the wormhole from a Gameplay object or a Blueprint. In my case I use a <strong>Material Parameter Collection(MPC)</strong> to store the location value and then use it in the shader.</p>
<p><img src="MPC_Setup.png" alt="MPC_Setup.png"></p>
<p>So in your content browser right-click&gt;Materials &amp; Textures&gt;MaterialParameterCollection to create a new MPC Asset,give it a name(I named mine “M_Bhole_Collection”..seemed like a good idea at the time..),then double click to open it up and click on the “+” sign next to vector Parameters to add a new Vector Parameter to the collection. Name it “Texloc” or anything you want really, but this is the parameter we will store the location from the blueprint.</p>
<p><img src="MPC_Setup_01.png" alt="MPC_Setup_01.png"></p>
<p><img src="MPC_Setup_02.png" alt="MPC_Setup_02.png"></p>
<h2 id="Setting-up-Blueprint-Actor-to-Feed-Wormhole-Location"><a href="#Setting-up-Blueprint-Actor-to-Feed-Wormhole-Location" class="headerlink" title="Setting up Blueprint Actor to Feed Wormhole Location"></a><strong>Setting up Blueprint Actor to Feed Wormhole Location</strong></h2><p>In this section we will set up a basic blueprint actor that we will use as our gameplay object whose location we will feed into the shader to serve as the Wormhole’s global Location</p>
<p>Create a new Blueprint Asset type Actor, give it a name(I called mine BP_Texture_Locator), open up the event graph and set it up as shown below:</p>
<p><img src="BP_TextureLocator.png" alt="BP_TextureLocator.png"></p>
<p><img src="BP_Setup_01.png" alt="BP_Setup_01.png"></p>
<p>On the “Set Vector Parameter node”, when you click on the collection Paramter dropwon, it should list all of the MPC’s available in your project, choose the one you had created earlier. Then when you click the “Parameter Name” dropdown it will list all of the Vector Parameters available in that MPC. Choose the “TexLoc” parameter.</p>
<p>With this set up, now the location of this BP actor will be fed to the “<strong>TexLoc</strong>“ variable every tick, we can now use it in our shader to define the location of the Wormhole.</p>
<p>Next create a new Material, we use a material only because it is easier to test with while we make the shader. Later we will take all of the stuff created in this material and put it into a Material Function, this function will be where we put all of our shader math, we set this up as a material Function so that this Effect can easily be layered onto any exisitng surface shader.</p>
<h2 id="Distance-Gradient-Mask"><a href="#Distance-Gradient-Mask" class="headerlink" title="Distance Gradient Mask"></a><strong>Distance Gradient Mask</strong></h2><p>There’s multiple ways to apprach this part, one solution is to use a Distance Field Sphere mask as I’ve shown Post-Process-Scan-Effect</p>
<p>But i used a slightly different method this time, but it yeilds the same results:</p>
<p><img src="Mask_01.png" alt="Mask_01.png"></p>
<p>What this does is it creates, a spherical gradient based on the distance between the pixels and the location of the Blueprint actor</p>
<p>Go ahead and add a couple objects into your scene and apply the material we jsut made to them.Now drag the Blueprint Actor you made earlier into the level and try moving it around.You should see something like below:</p>
<p><img src="Mask_g01.gif" alt="Mask_g01.gif"></p>
<p>The important thing here is to note how we read the Location of the Blueprint we set up earlier. Inside the shader, we can use a node called “<strong>Collection Parameter</strong>“.</p>
<p><img src="MPC_Parameter.png" alt="MPC_Parameter.png"></p>
<p>This node lets us read variables from MPC’s inside our shader. If you click the node and look at it’s details panel, you will notice that you can link the MPC asset you created and choose the parameter the node will reference.</p>
<p><img src="MPC_Parameter_Settings.png" alt="MPC_Parameter_Settings.png"></p>
<h2 id="Deforming-Vertices"><a href="#Deforming-Vertices" class="headerlink" title="Deforming Vertices"></a><strong>Deforming Vertices</strong></h2><p>The basic concept here is to crush all the vertices of the geo to a finite point defined by the location of the Blueprint. Look at the following example.</p>
<p><img src="WPO_Crush.png" alt="WPO_Crush.png"></p>
<p>If you plug that into the World Position Offset pinof the material, you will get something like this</p>
<p><img src="WPO_01.gif" alt="WPO_01.gif"></p>
<p>Absolute World Position - Object position gives us the localized world position of the object, so when we Lerp between it and a null value with a sine-wave as the alpha, the vertices contract to a finite point and expand back up. We use this same concept, but instead of using the “object position” we will use the Blueprint location from the MPC and instead of a sine-wave alpha we will use the scaling distance field mask.</p>
<p>We take the same logic, and replace Object position with the Location parameter, and then use teh gradient mask from the previous step as an alpha to lerp between the new WPO and a null value as shown below: </p>
<p><img src="Mask_02.png" alt="Mask_02.png"></p>
<p>Now if you try moving the BP actor around in the level you’ll notice that the vertices of the meshes get pulled towards it’s center based on the gradient mask falloff.</p>
<p><img src="Mask_g02.gif" alt="Mask_g02.gif"></p>
<h2 id="Making-the-Material-Function"><a href="#Making-the-Material-Function" class="headerlink" title="Making the Material Function"></a><strong>Making the Material Function</strong></h2><p>At this point all the basic setups for the effect are complete, We can now wrap all this functionality into a Material Function so that, the effect can be easily layered on top of any existing shaders</p>
<p>Create a new material Function, I called mine MF_VertCrush and set it up as shown, below, it’s exactly the same as what I made before but with some tweaks:</p>
<p>Right click and open in new tab to view higher resolution:</p>
<p><img src="MF_VertCrush_Full.png" alt="MF_VertCrush_Full.png"></p>
<p>The Function has 3 Outputs:</p>
<p><strong>BaseColor</strong>: To override the basecolor of the objects material</p>
<p><strong>Emissive</strong>:To add emissive coloration to the shader.</p>
<p><strong>WorldPositionOffset</strong>:This will output the modified WPO to the shader</p>
<p>And we create input parameters for any scalar or vector parameter that we need to read from the Objects surface shader as well as any parameters that we want to be adjustable, in the function like radius, falloff etc</p>
<p>In this instance I’ve multiplied the mask radius with a sine-wave to make the effect oscillate the way it does in the gif below, I’ve also added some basic fresnel emissive based on the gradient mask, so that areas affected by the wormhole, get a fresnel emissive.I’ve also subtracted a noise texture from the gradient mask to create some variation in strength.</p>
<p>In the details panel, enable “<strong>expose to library</strong>“. Now if you make a new material and right-click and search for your function name, it will show up in the dropdown menu:</p>
<p><img src="Expose.png%22" alt="Expose.png&quot;"></p>
<p><img src="Search.png" alt="Search.png"></p>
<p>So now, you can basically access this function in any material and layer it on as shown below, by feeding the appropriate parameters into the function and using it’s outputs on the final output pins</p>
<p><img src="MatFunc.png" alt="MatFunc.png"></p>
<p>You can see the end results below, where I have applied the function to some of Epic’s demo assets. I hope you found this mini-tutorial useful, feel free to email me if you ahve any questions or suggestions!</p>
<p><img src="post07.gif" alt="post07.gif"></p>
<p><img src="Wormhole_Suck.gif" alt="Wormhole_Suck.gif"></p>
]]></content>
  </entry>
</search>
