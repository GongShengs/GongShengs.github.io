<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何使用VS Code写MD</title>
    <url>/2021/07/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VS_Code%E5%86%99MD/</url>
    <content><![CDATA[<h2><span id="备注">备注</span></h2><p>语法：<a href="https://www.runoob.com/markdown/md-tutorial.html">MarkDown</a></p>
<p>编写平台：vs code</p>
<p>插件：Markdown Preview Enhanced<br>Better Markdown &amp; Latex Shortcuts</p>
<p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/366596949">https://zhuanlan.zhihu.com/p/366596949</a></p>
]]></content>
  </entry>
  <entry>
    <title>Maya 插件开发学习</title>
    <url>/2021/07/24/Maya_%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1><span id="maya-插件开发学习">Maya 插件开发学习</span></h1><!-- toc -->

<ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">环境配置</a><ul>
<li><a href="#maya-%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE">maya 脚本编辑器配置</a></li>
<li><a href="#vs-code-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">vs code 环境配置</a></li>
</ul>
</li>
<li><a href="#%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB">语言分类</a><ul>
<li><a href="#mel">mel</a></li>
<li><a href="#python">python</a></li>
<li><a href="#qt">QT</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<ul>
<li>环境配置<ul>
<li>vs code</li>
<li>maya 脚本编辑器</li>
</ul>
</li>
<li>语言分类<ul>
<li>mel</li>
<li>python</li>
<li>QT</li>
</ul>
</li>
</ul>
<h2><span id="环境配置">环境配置</span></h2><h3><span id="maya-脚本编辑器配置">maya 脚本编辑器配置</span></h3><p>如图所示，对脚本编辑器进行配置</p>
<p><img src="Maya_Editor_Set.png" alt="d"></p>
<h3><span id="vs-code-环境配置">vs code 环境配置</span></h3><p>相关参考链接：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Cz4y1R7MC?from=search&seid=14150298653133706761">Python开发Maya脚本插件 开发环境详细配置</a></li>
</ul>
<h2><span id="语言分类">语言分类</span></h2><h3><span id="mel">mel</span></h3><h3><span id="python">python</span></h3><p>  maya.cmds——这是一个把MEL命令用python包装（ wrappers）的库，可以用于替代MEL命令，因为绝大多数的MEL命令都能查找得到一一对应的maya.cmds命令。只适合面向过程编程。</p>
<p>  pymel.core——该pymel库将许多最常用的MEL命令和API的方法重组到类的层次结构中，这样的设计让你的编程更简单易懂，更具有pythonic化，因为它是具有真正意义上的面向对象特性。由于该pymel库是第三方开发的，Autodesk公司并不提供技术上的支持帮助。</p>
<p>  maya.OpenMaya——这是Maya C++ API的Python包装（ wrappers）的库，称之为Python API 1.0， 适合开发插件和需要MEL未公开的功能的其他任务。</p>
<p>  maya.api.OpenMaya——这是Maya C++ API的Python包装（ wrappers）的库，称之为Python API 2.0。</p>
<h3><span id="qt">QT</span></h3><p>为了通用性，GUI选择QT。</p>
]]></content>
  </entry>
  <entry>
    <title>Autodesk FBX SDK 介绍</title>
    <url>/2021/07/24/Autodesk_FBX_SDK/</url>
    <content><![CDATA[<h1><span id="autodesk-fbx-sdk-介绍">Autodesk FBX SDK 介绍</span></h1><!-- toc -->

<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E9%80%94%E5%BE%84">相关学习途径</a></li>
<li><a href="#fbx%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Fbx的数据结构</a></li>
<li><a href="#fbx-sdk-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5python%E4%B8%BA%E4%BE%8B">Fbx SDK 的使用，以Python为例</a></li>
<li><a href="#fbx-sdk-%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93">FBX SDK 的学习总结</a></li>
</ul>
<!-- tocstop -->

<p><a href="https://www.autodesk.com/products/fbx/overview">Autodesk FBX</a>是Autodesk公司出品的一款用于跨平台的免费三维创作与交换格式的软件，通过FBX用户能访问大多数三维供应商的三维文件。FBX 文件格式支持所有主要的三维数据元素以及二维、音频和视频媒体元素。</p>
<p>官方提供了相对应的SDK提供给开发者使用，有C++，C#，Python等多个版本。相关的<a href="https://www.autodesk.com/products/fbx/overview">下载地址</a>。<br>不同环境安装方案：</p>
<ul>
<li>Unity中，如果安装了了Fbx Exporter插件，会自动内置FBX的SDK库。</li>
<li>Houdini中，请看<a href="https://zhuanlan.zhihu.com/p/144349799">Houdini 对于fbx sdk python的简单应用</a></li>
</ul>
<h3><span id="相关学习途径">相关学习途径</span></h3><ul>
<li>通过阅读Fbx Exporter的源代码来学习Fbx SDK的使用</li>
<li><a href="https://banexdevblog.wordpress.com/2014/06/23/a-quick-tutorial-about-the-fbx-ascii-format/">A QUICK TUTORIAL ABOUT THE FBX ASCII FORMAT</a></li>
<li><a href="https://www.gamedev.net/tutorials/programming/graphics/how-to-work-with-fbx-sdk-r3582/">How to Work with FBX SDK</a></li>
<li><a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_welcome_to_the_fbx_sdk_html">Welcome to the FBX SDK</a></li>
</ul>
<h3><span id="fbx的数据结构">Fbx的数据结构</span></h3><p>Fbx是节点式的数据结构，如下图所示：<br><img src="v2-d9e57228d64b062291395dfbc6f84025_720w.jpg" alt="Fbx结构图"></p>
<h3><span id="fbx-sdk-的使用以python为例">Fbx SDK 的使用，以Python为例</span></h3><p>这是修改Fbx Mesh 属性的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2.7</span></span><br><span class="line"><span class="keyword">import</span> fbx</span><br><span class="line"><span class="keyword">from</span> fbx <span class="keyword">import</span> FbxVector2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Run</span>():</span></span><br><span class="line">    node = hou.pwd()</span><br><span class="line">    fileName=node.parm(<span class="string">&quot;file&quot;</span>).<span class="built_in">eval</span>()</span><br><span class="line">    csv_path = node.parm(<span class="string">&#x27;csv_path&#x27;</span>).<span class="built_in">eval</span>()</span><br><span class="line">    directory = node.parm(<span class="string">&#x27;directory&#x27;</span>).<span class="built_in">eval</span>()</span><br><span class="line">    num =<span class="number">1</span></span><br><span class="line">    <span class="comment">#birth_data = []</span></span><br><span class="line">    <span class="comment">#birth_data.append(fileName)</span></span><br><span class="line">    birth_data = DuplicateArray(ReadCsvByPath(csv_path,num))</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> birth_data:</span><br><span class="line">        </span><br><span class="line">        fileName = os.path.basename(path)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;@&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> fileName:</span><br><span class="line">            <span class="built_in">print</span> path</span><br><span class="line">            <span class="built_in">iter</span>=<span class="number">0</span></span><br><span class="line">            fbxManager = fbx.FbxManager.Create()</span><br><span class="line">            fbxScene = fbx.FbxScene.Create(fbxManager, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            fbxImporter = fbx.FbxImporter.Create(fbxManager, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            fbxImporter.Initialize(path)</span><br><span class="line">            fbxImporter.Import(fbxScene)</span><br><span class="line">            fbxRoot = fbxScene.GetRootNode() </span><br><span class="line">            <span class="keyword">if</span> IsCollider(fileName) == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> GetFbxNodeList(fbxRoot,<span class="built_in">list</span> = []):</span><br><span class="line">                    <span class="comment">#i.GetMesh().ClearLayers()</span></span><br><span class="line">                    <span class="keyword">if</span> i.GetMesh()!= <span class="literal">None</span>:</span><br><span class="line">                        i.GetMesh().ClearLayers()</span><br><span class="line">                        <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> GetFbxNodeList(fbxRoot,<span class="built_in">list</span> = []):</span><br><span class="line">                <span class="comment">#i.GetMesh().ClearLayers()</span></span><br><span class="line">                <span class="keyword">if</span> i.GetMesh()!= <span class="literal">None</span>:</span><br><span class="line">                    mesh = i.GetMesh()</span><br><span class="line">                    LayerCount = mesh.GetLayerCount()</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LayerCount):</span><br><span class="line">                        Layer = mesh.GetLayer(j)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(Layer.GetVertexColors()!=<span class="literal">None</span>):</span><br><span class="line">                            Layer.SetVertexColors(<span class="literal">None</span>)</span><br><span class="line">                            <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> LayerCount&gt;=<span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LayerCount):</span><br><span class="line">                            <span class="keyword">if</span> j==<span class="number">1</span> <span class="keyword">or</span> j==<span class="number">2</span>:</span><br><span class="line">                                Layer = mesh.GetLayer(j)</span><br><span class="line">                                uv = Layer.GetUVs()</span><br><span class="line">                                DirectArray = uv.GetDirectArray()</span><br><span class="line">                                DirectArray.SetCount(<span class="number">1</span>)</span><br><span class="line">                                DirectArray.SetAt(<span class="number">0</span>,FbxVector2(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">                                <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line">                            <span class="keyword">elif</span> j&gt;<span class="number">3</span>:</span><br><span class="line">                                Layer = mesh.GetLayer(j)</span><br><span class="line">                                Layer.SetUVs(<span class="literal">None</span>)</span><br><span class="line">                                <span class="built_in">iter</span>+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> LayerCount&lt;<span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LayerCount):</span><br><span class="line">                            <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                                Layer = mesh.GetLayer(j)</span><br><span class="line">                                Layer.SetUVs(<span class="literal">None</span>)</span><br><span class="line">                                <span class="built_in">iter</span>+=<span class="number">1</span>            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">iter</span>!=<span class="number">0</span>:</span><br><span class="line">                ExportFbx(fbxManager,path,fbxScene)    </span><br><span class="line">            fbxScene.Destroy()</span><br><span class="line">            fbxImporter.Destroy()</span><br><span class="line">            fbxManager.Destroy()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFbxNodeList</span>(<span class="params">fbxRoot,<span class="built_in">list</span> = []</span>):</span></span><br><span class="line">    num = fbxRoot.GetChildCount()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fbxRoot.GetChildCount()):</span><br><span class="line">        fbxChildRoot = fbxRoot.GetChild(i)</span><br><span class="line">        <span class="built_in">list</span>.append(fbxChildRoot)</span><br><span class="line">        <span class="keyword">if</span> fbxChildRoot.GetChildCount()&gt;<span class="number">0</span> :</span><br><span class="line">            GetFbxNodeList(fbxChildRoot,<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExportFbx</span>(<span class="params">fbxManager,fileName,fbxScene</span>):</span></span><br><span class="line">    fbxExporter = fbx.FbxExporter.Create(fbxManager, <span class="string">&quot;Exporter&quot;</span>)</span><br><span class="line">    fileFormat = -<span class="number">1</span></span><br><span class="line">    fbxExporter.Initialize(fileName,fileFormat,fbxManager.GetIOSettings())</span><br><span class="line">    fbxExporter.Export(fbxScene)</span><br><span class="line">    fbxExporter.Destroy()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#获取输入路径下的指定类型的文件路径列表       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFbxListInDirectory</span>(<span class="params">filepath,file_type,<span class="built_in">list</span>=[]</span>):</span></span><br><span class="line">    path_list = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> f1 <span class="keyword">in</span> path_list:</span><br><span class="line">        f1_path = os.path.join(filepath,f1)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(f1_path):</span><br><span class="line">            suffix = os.path.splitext(f1_path)[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> suffix.lower() == file_type:</span><br><span class="line">                f1_path.replace(<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                <span class="built_in">list</span>.append(f1_path)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(f1_path):</span><br><span class="line">            GetFbxListInDirectory(f1_path,file_type,<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span> </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsCollider</span>(<span class="params">fileName</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;Collider&quot;</span> <span class="keyword">in</span> fileName <span class="keyword">or</span> <span class="string">&quot;collider&quot;</span> <span class="keyword">in</span> fileName:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DuplicateArray</span>(<span class="params">Imported_Array</span>):</span>     </span><br><span class="line">    <span class="type">List</span> = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Imported_Array:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">            <span class="type">List</span>.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">List</span></span><br><span class="line"><span class="comment">#读取csv的列信息，并返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadCsvByPath</span>(<span class="params">csv_path,num</span>):</span></span><br><span class="line">    birth_data = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(csv_path) <span class="keyword">as</span> csvfile:</span><br><span class="line">        csv_reader = csv.reader(csvfile)  <span class="comment"># 使用csv.reader读取csvfile中的文件</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  <span class="comment"># 将csv 文件中的数据保存到birth_data中</span></span><br><span class="line">            birth_data.append(<span class="built_in">str</span>(row[num]))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> birth_data</span><br></pre></td></tr></table></figure>
<h3><span id="fbx-sdk-的学习总结">FBX SDK 的学习总结</span></h3><ul>
<li>SDK使用的结构<ul>
<li>FbxManager </li>
<li>FbxScene </li>
<li>FbxImporter</li>
<li>FbxExporter</li>
</ul>
</li>
<li>关于Fbx 属性修改<br>Fbx的Node存在Layer的概念，Layer用于存储各种Mesh的数据，mesh本身的基础数据(如：法线，切线，顶点位置，uv，顶点色)都存储在Layer0上，当模型增加uv2,uv3等数据时，会增加新的Layer层级并存储在对应层级下</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Houdini Digital Assets 学习笔记</title>
    <url>/2021/07/24/Houdini%20Digital%20Assets%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="houdini-digital-assets-学习笔记">Houdini Digital Assets 学习笔记</span></h1><!-- toc -->

<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95">创建的方法</a></li>
<li><a href="#%E9%9D%A2%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D">面板参数介绍</a><ul>
<li><a href="#operator-type-window-%E8%B5%84%E4%BA%A7%E7%9A%84%E7%BC%96%E8%BE%91%E7%AA%97%E5%8F%A3">Operator Type window 资产的编辑窗口</a><ul>
<li><a href="#basic-tab%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE">Basic tab基础标签</a></li>
<li><a href="#parameters-tab-%E5%8F%82%E6%95%B0%E6%A0%87%E7%AD%BE">Parameters tab 参数标签</a></li>
<li><a href="#node-tabs-%E8%8A%82%E7%82%B9%E9%9D%A2%E6%9D%BF">Node Tabs 节点面板</a></li>
<li><a href="#inputoutput-tab">Input/Output tab</a></li>
<li><a href="#help-tabs">Help Tabs</a></li>
<li><a href="#code-tabs">Code Tabs</a></li>
<li><a href="#scripts-tab">Scripts tab</a></li>
<li><a href="#interactive-tab">Interactive tab</a></li>
<li><a href="#iextra-files-tab">IExtra Files tab</a></li>
<li><a href="#save-tab">Save Tab</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
<!-- tocstop -->

<p>Digital assets let you create reusable nodes and tools from existing networks.</p>
<p>可以创建复用的节点和工具。 </p>
<p>存储格式：.hda(.otl是旧版本)</p>
<h2><span id="创建的方法">创建的方法</span></h2><ol>
<li>Subnetwork 右键  Create digital asset    </li>
<li>资产命名<ul>
<li>Operator Name 命名空间的名字</li>
<li>Operator Label tab管理器的名称</li>
<li>Save to library 存储位置，建议制作自己的资产库，便于个人管理。</li>
</ul>
</li>
<li>编辑面板属性，脚本等细节</li>
<li>4.完成创建</li>
</ol>
<h2><span id="面板参数介绍">面板参数介绍</span></h2><h3><span id="operator-type-window-资产的编辑窗口">Operator Type window 资产的编辑窗口</span></h3><p>此窗口可以编辑资产除子节点之外的所有数据（参数面板，label and icon，嵌入文件，自定义脚本）</p>
<p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00.png" alt="资产的编辑窗口"></p>
<ul>
<li>Operator Type 就是上文提到的Operator Name，此时的状态是不可更改的。</li>
<li>Save to Library 存储位置。</li>
<li>Install Library to 安装到哪，统一适用packages管理，我觉得更好些。</li>
<li>Switch to Definition 切换定义</li>
</ul>
<h4><span id="basic-tab基础标签">Basic tab基础标签</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="Basic"></p>
<ul>
<li>Label 标签名 显示在tab</li>
<li>Icon 图标 建议使用houdini内置的图标，其他处理方式请查看帮助。</li>
<li>Version 版本 版本号提醒</li>
<li>Minimum Inputs 最小输入端口数量</li>
<li>Maximum Inputs 最大输入端口数量</li>
<li>Maximum Outputs 最大输出端口数量</li>
</ul>
<h4><span id="parameters-tab-参数标签">Parameters tab 参数标签</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.png" alt="Parameters"></p>
<ul>
<li><p>创建参数</p>
<ul>
<li>将子节点属性直接拖入Existing Parameters</li>
<li>从create Parameters 中拖入Existing Parameters，然后进行和子节点的关联</li>
</ul>
</li>
<li><p>create Parameters 创建属性</p>
</li>
<li><p>Existing Parameters 已有的参数</p>
</li>
<li><p>Parameter Description参数说明</p>
<ul>
<li>Name 是 参数的名称，当脚本或者其他方式调用时使用此名称， Label 是面板上显示的名称。</li>
<li>Callback Script 回调脚本 当参数有所变化就会触发，经常用于button</li>
<li>Tags 标签 可以存储一些参数属性，例如opengl实时显示材质之类。</li>
</ul>
</li>
<li><p>Channels中存储属性的默认值，但是ramp类型的不在这里设置 它的属性参数中有一项叫 get from  Parameter</p>
</li>
</ul>
<h4><span id="node-tabs-节点面板">Node Tabs 节点面板</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03.png" alt="Node"></p>
<p>Enitble Nodes 是目前我最常用的，为了能编辑内部节点</p>
<h4><span id="inputoutput-tab">Input/Output tab</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04.png" alt="Input/Output"></p>
<p>输入输出 可以进行一些输入输出的信息描述</p>
<h4><span id="help-tabs">Help Tabs</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05.png" alt="Help"></p>
<p>可以使用wiki 进行节点帮助的创建，我认为在大规模使用的情况下 是很有用的。</p>
<h4><span id="code-tabs">Code Tabs</span></h4><p>适用于其他类型的资产，现在不讨论。</p>
<h4><span id="scripts-tab">Scripts tab</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06.png" alt="Scripts"></p>
<p>触发脚本的标签<br>当有一些自定义的触发操作，批处理之类就可以使用该标签进行创建。</p>
<h4><span id="interactive-tab">Interactive tab</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07.png" alt="Interactive"></p>
<p>交互标签 用于hda 和用户交互的操作<br>例如 hda的菜单位置，界面交互，热键之类</p>
<p>菜单设置    在    shelf Tools-Context- NetWork Plane - TAB Submenu Path</p>
<h4><span id="iextra-files-tab">IExtra Files tab</span></h4><p>内嵌文件标签</p>
<p>用于将一些纹理 bgeo文件嵌入hda 中,嵌入后使用opdef 在资产中进行调用。</p>
<h4><span id="save-tab">Save Tab</span></h4><p>保存 目前还未涉及到，感觉默认就行。</p>
<h2><span id="其他">其他</span></h2><ol>
<li>关于私有资产保护问题<ul>
<li>可以创建黑盒，在你不想公开的情况下。</li>
<li>方法：<ol>
<li>选择需要创建黑盒的hda</li>
<li>Assets - Create Black Boxed Asset from Selection </li>
<li>选择存储位置，完成创建。    </li>
</ol>
</li>
</ul>
</li>
<li>当想修改官方的资产但不想影响资产的默认的问题<ol>
<li>打开资产管理面板，右键资产 show in Asset Manager </li>
<li>右键点击资产中的hda 选择duplicate 进行修改创建。</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Houdini 引擎面板功能介绍</title>
    <url>/2021/07/24/Houdini%20Engine%20For%20Unity%20%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1><span id="houdini-引擎面板功能介绍">Houdini 引擎面板功能介绍</span></h1><!-- toc -->

<ul>
<li><a href="#houdini-%E8%B5%84%E4%BA%A7ui%E9%9D%A2%E6%9D%BF">Houdini 资产UI面板</a></li>
<li><a href="#asset-options-%E8%B5%84%E4%BA%A7%E9%80%89%E9%A1%B9">Asset Options 资产选项</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%8A%82%E7%82%B9">导入节点</a></li>
</ul>
<!-- tocstop -->

<h2><span id="houdini-资产ui面板">Houdini 资产UI面板</span></h2><p><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D0.png" alt="Houdini 资产UI面板"></p>
<ul>
<li>Rebuild Assest 重建资产。强制重建资产，并保留最新参数。</li>
<li>Recook Assesrt 重新cook资产。 重新输出资产</li>
<li>Keep Only Output 仅保持输出。删除资产，保留输出的结果。</li>
<li>Duplicate Assest 复制资产</li>
<li>Reset Asset 重置资产。将参数重置为默认值。</li>
<li>Bake GameObject 烘焙GameObject</li>
<li>Bake Prefab 烘焙预制体。</li>
<li>Bake Update 烘焙更新 更新之前烘焙的GameObject和预制体。如果计划烘焙更新，请不要修改物体名称。<h2><span id="asset-options-资产选项">Asset Options 资产选项</span></h2><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D1.png" alt="Asset Options 资产选项"></li>
</ul>
<ol>
<li>Auto-Cook On Parameter Change 当参数变化时自动cook</li>
<li>Push Tranform To Houdini 变换传递至houdini</li>
<li>Transform Change Triggers Cooks 位移的变化触发cook</li>
<li>Cooking Triggers Downsteam Cooks 烘焙时触发其他关联的资产进行烘焙</li>
<li>Generate UVs 创建UV</li>
<li>Generate Tangents 创建切线</li>
<li>Generate Normals 创建法线</li>
<li>Generate Mesh Using Points 使用点创建mesh，但所有的属性都在点上而非顶点上。</li>
<li>Use LOD Groups 使用LOD组</li>
<li>Ignore NonDisplay Nodes 忽略不可显示的节点</li>
<li>Split Geos By Group 通过组分离geo </li>
<li>Save HDA Preset 保存hda预设</li>
<li>Load HDA Preset 导入 hda预设</li>
<li>Reset Material Overrides 重置材质替代<h2><span id="导入节点">导入节点</span></h2><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D2.png" alt="导入节点"></li>
<li>Input Type 输入类型 Unity_Mesh unity的gameObject或者预制体  hda houdini资产</li>
<li>Keep World Transform 保持世界空间位移</li>
<li>Pack Geometry Before Mergi 在合并前物体打包。仅适用于unity物体</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>转载：Ice Shader in UE4</title>
    <url>/2021/10/03/Ice-Shader-in-UE4/</url>
    <content><![CDATA[<h1><span id="ice-shader-in-ue4">Ice Shader in UE4</span></h1><!-- toc -->

<ul>
<li><a href="#material-preview"><strong>Material Preview</strong></a></li>
<li><a href="#textures"><strong>Textures</strong></a></li>
<li><a href="#bubblemasktga"><strong>BubbleMask.tga</strong></a></li>
<li><a href="#colormask-crack-roughnesstga"><strong>ColorMask-Crack-Roughness.tga</strong></a></li>
<li><a href="#subsurface-height-speckletga"><strong>Subsurface-Height-Speckle.tga</strong></a></li>
<li><a href="#normalmap"><strong>NormalMap</strong></a></li>
<li><a href="#bumpoffset-node"><strong>BumpOffset Node:</strong></a></li>
<li><a href="#creating-masks-for-surface-coloration"><strong>Creating Masks for Surface Coloration</strong></a></li>
<li><a href="#bubblecrackssurface-masks"><strong>Bubble,Cracks,Surface Masks</strong></a></li>
<li><a href="#material-roughness"><strong>Material Roughness</strong></a></li>
<li><a href="#opacitysubsurface-masking"><strong>Opacity/Subsurface Masking</strong></a><ul>
<li><a href="#part-1">Part 1:</a></li>
<li><a href="#part-2-camera-distance-mask">Part 2: Camera Distance Mask</a></li>
</ul>
</li>
<li><a href="#final-opacity-mask-blending"><strong>Final Opacity Mask Blending</strong></a></li>
<li><a href="#basecolor-pass"><strong>BaseColor Pass</strong></a></li>
<li><a href="#subsurface-color"><strong>Subsurface Color</strong></a></li>
<li><a href="#normal-map"><strong>Normal Map</strong></a></li>
<li><a href="#performance-optimizationfinal-thoughts"><strong>Performance, optimization/Final Thoughts</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post01.jpg" alt="post01"></p>
<p>So i’ve been meaning to do this for a while, but unfortunately finding time was tricky, but I’ve managed to sneak in some free time in-between assignments to make this write-up. Now, Full disclosure, I am no pro, this was a result of me researching/experimenting trying to get a result, lots of googling etc. So it may not be perfect, feel free to leave some feedback or any changes you may suggest. Anyway lets get started.</p>
<h2><span id="material-preview"><strong>Material Preview</strong></span></h2><p>Here is a preview of what the material looks like along with the entire material graph, if you’d rather not read through all my ramblings/explanation</p>
<p>My goal with this project was to create a “Genereal Purpose” ice material. Something that could be tweaked with parameters to work decently for any kind of use.</p>
<p><img src="IceShowcase_Gif.gif" alt="IceShowcase_Gif"></p>
<p><img src="Opaque_Ice.png" alt="Opaque_Ice"></p>
<p><img src="ICe_Floor_Showcase.gif" alt="ICe_Floor_Showcase"></p>
<p><img src="FullGraph.JPG" alt="FullGraph"></p>
<h2><span id="textures"><strong>Textures</strong></span></h2><p>This material makes use of 4-5 textures depending on whether you choose to add a baked normal map for a mesh, 3 of them will contain patterns in each channel and one will be a general purpose noisy normal map. I used Substance designer to generate these patterns and I thin I also found one or two wit on gogle. The images below show you how the textures are set up.</p>
<h2><span id="bubblemasktga"><strong>BubbleMask.tga</strong></span></h2><p><img src="BubbleMask_BD.jpg" alt="BubbleMask_BD"></p>
<h2><span id="colormask-crack-roughnesstga"><strong>ColorMask-Crack-Roughness.tga</strong></span></h2><p><img src="ColorMask-Crack-Roughness_BD.jpg" alt="ColorMask-Crack-Roughness_BD"></p>
<h2><span id="subsurface-height-speckletga"><strong>Subsurface-Height-Speckle.tga</strong></span></h2><p><img src="Subsurface-Height-Speckle.jpg" alt="Subsurface-Height-Speckle.jpg"></p>
<h2><span id="normalmap"><strong>NormalMap</strong></span></h2><p><img src="Ice_Substance_BaseNormal.jpg" alt="Ice_Substance_BaseNormal"></p>
<h2><span id="bumpoffset-node"><strong>BumpOffset Node:</strong></span></h2><p>This node in the UE4 Material Editor, basically helps us make use of parallax mapping, this is waht we use to fake the “depth” in this material. The basic explanation of how it works is this, you feed it a Coordinate value, a height value and a height ratio value. The Height Value determines the base or plane from which your heightratio is measured, so if you feed a height value 0 with a height ratio value of -1.0, pixels will appear as though they are “under” the surface, where as if you have a height value of 0 and a height ratio value of 1.0, pixels will appear to bulge above the surface (This can look very bad unless you use subtle values). <a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/HowTo/BumpOffset/">Here’s</a> the documentation page for the node</p>
<p><img src="BumpOffsetNode.JPG" alt="BumpOffsetNode"></p>
<h2><span id="creating-masks-for-surface-coloration"><strong>Creating Masks for Surface Coloration</strong></span></h2><p>In this step, we are going to mix and match some of the textures we made to create some masks that we will use to control the shader’s coloration and expose some useful variables as parameters so that we can use it to tweak the shader’s appearance with Instances. You can see the network below:</p>
<p>First we create a scalar parameter, “Master Tiling”, we will use this to control the global tiling value for the entire material.</p>
<p><img src="Master_Tiling_Parameter.JPG" alt="Master_Tiling_Parameter"></p>
<p>1: Next we create the basic setup that will repeat for all the textures that we use in the shader, we set up a scalar parameter to control the tiling for each TextureSample and multiply it by the Global Tiling parameter , we also setup the bumpOffset Node and the values for it’s inputs to be use.</p>
<p><img src="SurfaceColoration_Mask.JPG" alt="SurfaceColoration_Mask"></p>
<p>We do some basic value adjustments to each texture sample with a power node, we do this to create some variation in the masks as we will be re-using the same textures many times in the shader. WIth this network set up we have 3 mask outputs ready to be used (labeled in the image). We will make use of these later.</p>
<h2><span id="bubblecrackssurface-masks"><strong>Bubble,Cracks,Surface Masks</strong></span></h2><p>This part of the graph creates surface masks to control areas where the bubbles are visible.</p>
<p>![Crack and SurfaceMasks](Crack and SurfaceMasks.JPG)</p>
<p>In this section we are going to set up the the masks for the bubbles and surface cracks, see the node Graph below:</p>
<p><img src="BubbleMask.JPG" alt="BubbleMask"></p>
<p>In the graph above we repeat the process of setting up tiling parameters for the textures for each texturesample.</p>
<p>1.) This will be the upper most layer of bubbles,we will sue the Blue Channel of the texture as that is where we stored the blobby bubble pattern. We set a height ratio value of -0.2, so the bubbles appear just below the surface.</p>
<p>2.) This section will be bubbles that are deeper inside the surface. FIrst we set up two scalar parameters and add it to the texture coordinate, this will let us add some offsets in the U and V directions to create some variation. Next we repeat the procedure for setting up tiling values,We set a higher tiling value to make the bubbles appear smaller, to help improve the fake depth effect, In the Bump offset node we set a heihgt ratio of -1.0.</p>
<p>We multiply the end result of this network with the an the inverted result of Mask_01 from the previous section. This is done so the bubbles are not visible if they are under the Opaque sections of the ice surface. The gif below shows what the result of this network looks like.</p>
<p><img src="BubbleMask_GIF.gif" alt="BubbleMask_GIF"></p>
<h2><span id="material-roughness"><strong>Material Roughness</strong></span></h2><p>This section of the graph deals with how we set up the roughness input for the material, we do the same process as before and set up the tiling properties for the texture with the speckle pattern in the Blue channel, we use this as the mask to Lerp between a min an max roughness value. We expose these values as parameters so they can be tweaked. Finally we do a final lerp with the crack pattern mask from Mask_01, this is to give the cracked areas a different roughness than the rest of the surface.</p>
<p><img src="Roughness_Graph.PNG" alt="Roughness_Graph"></p>
<p>This will serve as the roughness output for the material, if we preview it, it will look something like this:</p>
<p><img src="Roughness_Output.gif" alt="Roughness_Output"></p>
<h2><span id="opacitysubsurface-masking"><strong>Opacity/Subsurface Masking</strong></span></h2><h3><span id="part-1">Part 1:</span></h3><p>In the following sections we will set up the Opacity output for the material, this part of the graph affect the material in two ways.</p>
<p>1.) It controls teh amount of subsurface scattering that occurs on the surfae of the mesh</p>
<p>2.) With translucency enabled,it controls how opaque/Translucent the material is.</p>
<p>So, this will affect how the Opacity output is used depending on whether we enable translucency or not</p>
<p>(Note: The translucent version of the material is quite expensive, use carefully, ideally any objects that use this shader should mip out to a cheaper version of the material quickly)</p>
<p>It is important to note that Opacity serves two purposes in this material, since our material uses a subsurface shading model, the opacity controls how much subsurface scattering happens on the surface of the object, in the opacity map, white areas = more scattering black areas= less scattering.</p>
<p>With translucency on the other hand, white areas = opaque, black areas = completely transparent. We need to keep this in mind as we build the opacity graph, so that we adress both these needs correctly</p>
<p>This first section just makes a basic mask using the texture we created earlier, but we also add some fresnel, so that the edges of the object do not become completely transparent as this can make the object feel floaty, and not very grounded in the world.</p>
<p><img src="Opacity.PNG" alt="Opacity"></p>
<p>If you preview the node commented as opacity, you’ll see something like this:</p>
<p><img src="Opacity-SubsurfaceMaskGif.gif" alt="Opacity-SubsurfaceMaskGif"></p>
<h3><span id="part-2-camera-distance-mask">Part 2: Camera Distance Mask</span></h3><p>Here we set up a camera distance based mask, so that the translucency becomes visible only when we are closer than a specified distance from the object (in thi s case 512 units). This was a personal choice for me, I didn’t like the way objects looked translucent from afar and wanted it to happend only when the viewer was close to the object.</p>
<p><img src="Camera_Distance.PNG" alt="Camera_Distance"></p>
<p>Here’s a gif showing what this network does, As you can see, the mask gets darker(i.e more transparent) the closer the camera is to the object.</p>
<p><img src="CameraMask.gif" alt="CameraMask.gif"></p>
<h2><span id="final-opacity-mask-blending"><strong>Final Opacity Mask Blending</strong></span></h2><p>In this part we bring together all the previous masks we made and blend them together to get the final output that goes into the Opacity Input of the material:</p>
<p><img src="OpacityMask_Blending.PNG" alt="OpacityMask_Blending.PNG"></p>
<p>If you preview the output of all these blends, it will look something like this.</p>
<p><img src="Opacity_Mask_Gif.gif" alt="Opacity_Mask_Gif.gif"></p>
<h2><span id="basecolor-pass"><strong>BaseColor Pass</strong></span></h2><p>The section below shows how we combine all the masks we have created in the previous sections to make the basecolor pass for the material. I used Adobe’ Kuler to pick an Analogous Color palette of light and deep blues, we expose all these colors as Texture Parameters so that it can be tweaked to any artists desires. I’ve commented which Mask goes to which lerp node.</p>
<p><img src="ColorPalette.PNG" alt="ColorPalette.PNG"></p>
<p>In the end we run everything through a Fuzzy shading Material Function, it works very similar to a fresnel but we are able to control the core darkness and the edge brightness, this function was commonly used when creating moss, cloth(before th release of the new shading model) and grass materials, but it provides an effect that I think works welll with Ice as well.</p>
<p><img src="Final_Color_Comp.PNG" alt="Final_Color_Comp.PNG"></p>
<p>If you preview the fuzzy shading node you will see something that looks like this. The output from this FuzzyShading Node will go into the BaseColor input of the material. This result will also be used to create the subsurface color in the next section.</p>
<p><img src="FinalColorPreview.gif" alt="FinalColorPreview.gif"></p>
<h2><span id="subsurface-color"><strong>Subsurface Color</strong></span></h2><p>The subsurface color output is generated by multiplying the Final Color Output with a parameterized color hue, and scaling factor to control how bright the color is. the output of this multiply node will go into the materials subsurface color input.</p>
<p><img src="SubSurface_Color.PNG" alt="SubSurface_Color.PNG"></p>
<h2><span id="normal-map"><strong>Normal Map</strong></span></h2><p>For the materials normal, the setup is simple, we use the normal texture, with uv coordinates from the Surface Masks section, we also add a static switch parameter to control whether we want to combine it with a baked object normal map. This option is made so that when we apply this material to an object with baked normal maps, we blend the ice normals with the objects baked normal map.</p>
<p><img src="NormalMap.PNG" alt="NormalMap.PNG"></p>
<h2><span id="performance-optimizationfinal-thoughts"><strong>Performance, optimization/Final Thoughts</strong></span></h2><p>When you create an instance of this material, you will have the option, of using it as a either a translucent-Subsurface material or as an opaque subsurface material. Using the translucency is quite expensice and ideally you’d want to mip to a cheaper material pretty quickly. The opaque-subsurface version on the other hand is not as beefy and is quite performant.</p>
<p>If you look at the shader complexity comparison between a <strong>transparent-subsurface</strong> and an <strong>Opaque-subsurface</strong> version of the material you will there is quite a big difference. For proper estimation of performance of course you want to use the GPU profiler to get accurate information on exactly what is going on in the scene.</p>
<p><img src="Shader.jpg" alt="Shader.jpg"></p>
<p><img src="ShaderComplexity.jpg" alt="ShaderComplexity.jpg"></p>
<p><img src="Translucent_Subsurface.PN" alt="Translucent_Subsurface.PN"></p>
<p><img src="Opaque_Subsurface.PNG" alt="Opaque_Subsurface.PNG"></p>
<p>The image below shows all the parameters that are exposed to the material instance, these settings can be tweaked to achieve different looks with the same material.</p>
<p><img src="Parameters.PNG" alt="Parameters.PNG"></p>
<p><strong>Thank you for reading and I hope you find this useful!Cheers!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Flowmapped-Burn-Shader</title>
    <url>/2021/10/03/Flowmapped-Burn-Shader/</url>
    <content><![CDATA[<h1><span id="flowmapped-burn-shader">Flowmapped-Burn-Shader</span></h1><!-- toc -->

<ul>
<li><a href="#textures"><strong>Textures:</strong></a></li>
<li><a href="#noise-texture"><strong>Noise Texture</strong></a></li>
<li><a href="#flowmap-texture"><strong>Flowmap Texture</strong></a></li>
<li><a href="#flowmap-setup"><strong>Flowmap setup</strong></a></li>
<li><a href="#spheremask"><strong>SphereMask</strong></a></li>
<li><a href="#hardness02"><strong>Hardness:0.2</strong></a></li>
<li><a href="#hardness05"><strong>Hardness:0.5</strong></a></li>
<li><a href="#with-flowmap"><strong>With flowmap</strong></a></li>
<li><a href="#without-flowmap"><strong>Without flowmap</strong></a></li>
<li><a href="#edge-glow-and-charring"><strong>Edge Glow and Charring</strong></a></li>
<li><a href="#mask-radius-512-spheremask-hardness0"><strong>Mask Radius: 512 , Spheremask Hardness:0</strong></a></li>
<li><a href="#mask-radius-92-spheremask-hardness05"><strong>Mask Radius: 92 , Spheremask Hardness:0.5</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post14.gif" alt="post14.gif"></p>
<p>This was a small shader that came about while I was thinking of different uses for Flowmaps, there are plenty of transition/dissolve effects out there, but most tend to look pretty static since they use static Textures. Here I’ve flowmapped the noise that drives the dissolve to achieve a location based burn shader. It is far from perfect, but the flowing motion makes it visually appealing as a burning dissolve effet.</p>
<p>The shader itself is extremely straight forward, I will detail a small breakdown below of my process. As with most of my other shaders. I’ve wrapped this into a Material Function, so that it can be used with any pre-existing materials.</p>
<p><font color="red">Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<h2><span id="textures"><strong>Textures:</strong></span></h2><p>I used the following textures in my shader, the first is a simple noise generated in Substance designer, the second is a swirly flowmap that I painted using <a href="http://teckartist.com/?page_id=107">Flowmap Painter</a></p>
<h2><span id="noise-texture"><strong>Noise Texture</strong></span></h2><p><img src="T_Noise_Cloud.png" alt="T_Noise_Cloud.png"></p>
<h2><span id="flowmap-texture"><strong>Flowmap Texture</strong></span></h2><p><img src="T_Swirlmap.pn" alt="T_Swirlmap.pn"></p>
<h2><span id="flowmap-setup"><strong>Flowmap setup</strong></span></h2><p>Flowmapping is a technique by which we use 2D Vectors stored in the form of a texture to distort of the UV’s of a texture over time. This distortion animation is then looped to give the illusion of flow, it’s commonly used in realtime water shaders to give the look of water flowing around rocks etc, but it can of course be used for lots of other things. In my shader I use it to create a material burning effect. If you would like a better understanding of flowmapping I reccomend reading the <a href="http://wiki.polycount.com/wiki/Flow_map">Polycount Wiki Entries</a> also check out <a href="https://youtu.be/tEr3NE_XLbc">Simonschreibt’s Flowmap Tutorial</a> as he does a great job of explaining it.</p>
<p>You can see my flowmap setup below</p>
<p><img src="flowmap_nodes.png" alt="flowmap_nodes.png"></p>
<p>As you can see we have parameters to control distortion strength, Tiling of the Different Textures as well as flow direction.</p>
<p>I use the Red channel’s output from the flowmapped noise to drive my effect, if you preview the Lerp Node, you will see this result</p>
<p><img src="flowmap_nodes.gif" alt="flowmap_nodes.gif"></p>
<h2><span id="spheremask"><strong>SphereMask</strong></span></h2><p>This next step can be handled multiple ways, in the end all it needs to be is a scaling gradient value to drive the effect. In this case, I am using a spheremask driven by blueprint location to drive the mask, this way I can move the blueprint around to affect what areas get burnt, and I can animate the sphere radius to create a burn away cycle. If you would liek to know how to setup a Material Parameter collection to pipe in the BP’s location into the shader I reccomend checking out my <a href="https://deepspacebanana.github.io/">Wormhole Shader Breakdown</a>. As I explain it i ndetail there, and I am usign the exact same setup here.</p>
<p>Creating a spheremask is easy as UE4 comes with an in-built function that lets us do jsut that</p>
<p><img src="spheremask.png" alt="spheremask.png"></p>
<p>The radius in this case is in World Space Units, so try sscrubbing the radius value and you’ll see this. By default, the location of the sphere mask is {o,o,o}, so you’ll notice the sphere growing from the center of the mesh.</p>
<p><img src="spheremask.gif" alt="spheremask.gif"></p>
<p>The next step is to create subtract the result from the flowmapped noise from the spheremask so we get a burn like pattern as the mask scales.</p>
<p><img src="subtract.png" alt="subtract.png"></p>
<p>Note that you can adjsut the <strong>spheremask hardness</strong> parameter to control the amount of spread in the transition</p>
<h2><span id="hardness02"><strong>Hardness:0.2</strong></span></h2><p><img src="subtract.gif" alt="subtract.gif"></p>
<h2><span id="hardness05"><strong>Hardness:0.5</strong></span></h2><p><img src="subtract_02.gif" alt="subtract_02.gif"></p>
<p>We can now take the result from this network and multiply it by the Opacity Mask input from thet Function input reads to get the Final Opacity Mask</p>
<p><img src="materialattributes.png" alt="materialattributes.png"></p>
<p><img src="opacitymask.png" alt="opacitymask.png"></p>
<p>It is good to know that, you could jsut as easily do this effect without the flowmap setup using jsut a static texture, the difference is that the flowmapped version has more motion and has a nice almost anime-esque visual flair. You can see the difference in the mask below.</p>
<h2><span id="with-flowmap"><strong>With flowmap</strong></span></h2><p><img src="finalopacitymask.gif" alt="finalopacitymask.gif"></p>
<h2><span id="without-flowmap"><strong>Without flowmap</strong></span></h2><p><img src="finalopacitymasknoflow.gif" alt="finalopacitymasknoflow.gif"></p>
<h2><span id="edge-glow-and-charring"><strong>Edge Glow and Charring</strong></span></h2><p>To make the Burning edges glow and to have the charred blackish outline, we use a technique that I’ve used in a lot of my shaders previously, where we sample the mask gradient at 0 and create an edge mask using the distance function.</p>
<p>You can see the setup below. The only thing to note here is that in this case we sample at <strong>0.45 for the glow outline</strong> and at <strong>0.5 for the charring outline</strong>, this is so that they are offset from each other and the charring appears around the glow, we also set a higher width for the charring outline so that it appears outside the glow Outline. We then expose the width inputs as parameters so that we can control the spread as needed.</p>
<p><img src="edgesample.png" alt="edgesample.png"></p>
<p>If you preview the outputs from each of these respectively you should see the following</p>
<p><img src="glowsample.gif" alt="glowsample.gif"></p>
<p><img src="charsample.gif" alt="charsample.gif"></p>
<p>Now we can simply take the result from the emberglow section, multiply it by a flame color and add it to the Emissive color from the Function Input to account for any pre-existing emissive color in whatever shader we use this function in, and use that as our final emissive color.</p>
<p><img src="emissive.png" alt="emissive.png"></p>
<p>You could alternatively, use the result from the emberglow section as input to map colors based on the gradient. A technique called gradient mapping, and UE4 now has a CurveAtlass feature which lets you define color curves and access them inside the shader, the feature is still a little finicky as I experienced a couple crashes trying to use it in my shader, so i will refrain from using it now, perhaps i’ll cover it in a future post.</p>
<p><img src="edgeglow.gif" alt="edgeglow.gif"></p>
<p>Next we take the result from the Charring section and multiply it with the Basecolor from the function input to get the Final Basecolor value</p>
<p><img src="basecolor.png" alt="basecolor.png"></p>
<p>Now you’ll see the edges turn black before they glow and burn</p>
<p><img src="charring.gif" alt="charring.gif"></p>
<p>And that’s it we are done.</p>
<p>The really cool part is now we can move the Blueprint around to create the burn area, in a game you could use the location of the players torch or something to drive the effect to make it look like they are burning things away. And we can play with the <strong>spheremask hardness</strong> and <strong>Radius</strong> to get the exact look and spread we want. Here’s what it looks like with different settings</p>
<h2><span id="mask-radius-512-spheremask-hardness0"><strong>Mask Radius: 512 , Spheremask Hardness:0</strong></span></h2><p><img src="loc_01.gif" alt="loc_01.gif"></p>
<h2><span id="mask-radius-92-spheremask-hardness05"><strong>Mask Radius: 92 , Spheremask Hardness:0.5</strong></span></h2><p><img src="loc_02.gif" alt="loc_02.gif"></p>
<p>Additionally you can animate the Radius to make it look like it’s burning away over time.</p>
<img src="https://media.giphy.com/media/8mwz2qnDRoOqBxYhzk/giphy.gif" width="512">

<img src="https://media.giphy.com/media/8PabF69ZHsjBbqCbZn/giphy.gif" width="512">

<p>Hope you found this useful.Cheers!</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Glitch Effects</title>
    <url>/2021/10/03/Glitch-Effects/</url>
    <content><![CDATA[<h1><span id="glitch-effects">Glitch Effects</span></h1><!-- toc -->

<ul>
<li><a href="#glitch-effect"><strong>Glitch Effect</strong></a></li>
<li><a href="#apparition"><strong>Apparition</strong></a></li>
<li><a href="#breakdown"><strong>Breakdown</strong></a></li>
<li><a href="#noise-functions"><strong>Noise Functions</strong></a></li>
<li><a href="#mf_vec3noise3"><strong>MF_Vec3Noise3</strong></a></li>
<li><a href="#mf_noise1d"><strong>MF_Noise1D</strong></a></li>
<li><a href="#opacity-mask"><strong>Opacity Mask</strong></a></li>
<li><a href="#final-opacity-mask"><strong>Final Opacity Mask</strong></a></li>
<li><a href="#vertex-deformationworldposition-offset"><strong>Vertex Deformation/WorldPosition Offset</strong></a></li>
<li><a href="#color-blendingemissive"><strong>Color Blending/Emissive</strong></a></li>
<li><a href="#basecolor"><strong>BaseColor</strong></a></li>
<li><a href="#emissive"><strong>Emissive</strong></a></li>
<li><a href="#randomized-glitch"><strong>Randomized Glitch</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post10.gif" alt="post10.gif"></p>
<p>This little project was spawned from being inspired by a video I saw showcasing all the cool Glitch Effects from Horizon Zero Dawn</p>
<p>I decided to try and make some form of a general purpose glitch shader that could be applied to any piece of geometry, I made two variations, one was a simple random distortiony glitch and the other used the same idea and combined it with my previous sphere mask based apparition effect to create a new type of apparition shader. You can see them both below.</p>
<p><font color="red">Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<h2><span id="glitch-effect"><strong>Glitch Effect</strong></span></h2><p><img src="Glitch_01.gif" alt="Glitch_01.gif"></p>
<h2><span id="apparition"><strong>Apparition</strong></span></h2><p><img src="Glitch_02.gif" alt="Glitch_02.gif"></p>
<h2><span id="breakdown"><strong>Breakdown</strong></span></h2><p>Like some of my previous posts, I encapsulated this entire shader into a material function so that it can be easily layered into any existing shader. So the first step is to create a Material Function.</p>
<p>The next step is to generate a psuedorandom CellNoise, this is what we will use to drive the color and Vertex Deformation of the glitch. You can see the netwrok below</p>
<p><img src="Nodes_01.png" alt="Nodes_01.png"></p>
<p>Now you may be wondering, but UE4 already has a “Noise” Function, why don’t you jsut use that? I could have..but I’m weird like that, also for some reason my custom network has less instructions</p>
<p>What this network is doing is essentially taking the localized WorldPosition of the object &gt; adding a time based psuedo-random scalar value to each channel &gt; running it through a custom function <strong>MF_Vec3Noise3</strong> which generates a psuedorandom Vector 3 value, which is our cell noise.</p>
<p>I add 0.1 and bias it because my function outputs values from -1 to 1, and i want values tht go from 0-1 instead, the 0.1 is to avoide any complete 0 values.</p>
<p>The output from this network will look like this</p>
<p><img src="output_01.gif" alt="output_01.gif"></p>
<h2><span id="noise-functions"><strong>Noise Functions</strong></span></h2><p>The two noise functions <strong>MF_Noise1D</strong> and <strong>MF_Vec3Noise3</strong> generate psuedo-random values based on inputs that are fed to them, the only difference between them being 1D takes a scalar input and outputs a random scalar value, the Vec3 one takes a Vector3 Input and outputs a Vector3 Psuedorandom Value.</p>
<p>If you would like to learn more about noise, I highly reccommend checking out <a href="https://thebookofshaders.com/11/">The Book of Shaders</a>, they do a great job of explaining it as well as it’s many uses.</p>
<p>Here’s what the node network for my functions looks like:</p>
<h2><span id="mf_vec3noise3"><strong>MF_Vec3Noise3</strong></span></h2><p><img src="Noise3D.png" alt="Noise3D.png"></p>
<h2><span id="mf_noise1d"><strong>MF_Noise1D</strong></span></h2><p><img src="Noise1D.png" alt="Noise1D.png"></p>
<h2><span id="opacity-mask"><strong>Opacity Mask</strong></span></h2><p>The next step is to create a mask that will drive the Opacity</p>
<p><img src="Nodes_02.png" alt="Nodes_02.png"></p>
<p>For this too, I calculate the localized worldposition of the object and then isolate the vector along which I want the mask effect to work. In my case I mask out the redChannel which is the X Vector of the object(You could convert this to a parameter so that you can pick along which axis the effect occurs)</p>
<p>We also have input parameters to enter the objects Length etc so that the shader can be customized to work with any object(in the future I will update this post to show how we can procuderally get these values without having to manually enter them).</p>
<p>If you preview the subtract node commented as <strong>BaseopacityMask</strong> you will see this</p>
<p><img src="basemask.gif" alt="basemask.gif"></p>
<p>As you can see we have a black and white mask that travels along the x axis of the object, we will combine this with some other outptus to get the final opacity mask.</p>
<p>The <strong>Edge Mask from Sample Gradient</strong> does exactly what it says, it samples the mask gradient and generates an Edge Mask, we use this to mask out the edge Fx as well as apply VertexDeformation for the Final Shader Effect. If you preview the out put from there you will see this. More on this soon.</p>
<p><img src="edgemask.gif" alt="edgemask.gif"></p>
<h2><span id="final-opacity-mask"><strong>Final Opacity Mask</strong></span></h2><p>To generate the final opacity mask we isolate the redChannel from our psuedorandom cell noise&gt;multiply it by a scaling factor(This controls the falloff of the transition,higher value = more falloff and vice versa), and subtract it from the baseopacitymask gradient to generate a cell pattern falloff. As shown below, this will be the input for the OpacityMask in the shader.</p>
<p><img src="finalopacity.png" alt="finalopacity.png"></p>
<p><img src="finalopacity.gif" alt="finalopacity.gif"></p>
<h2><span id="vertex-deformationworldposition-offset"><strong>Vertex Deformation/WorldPosition Offset</strong></span></h2><p>For the worldposition offset we take the output result from the psuedorandom cell noise &gt; Multiply it with the vertex Normals &gt; multiply it with scaling Factor(Deformation Strength) and then Linear interpolate it with a NULL value using the out put from the Gradient Sample Edge Mask as the alpha. This final result goes into the shader’s WorldPositionOffset Input</p>
<p><img src="wponodes.png" alt="wponodes.png"></p>
<p>if you preview the shader with just the WPO input, it’ll look like this</p>
<p><img src="wpo.gif" alt="wpo.gif"></p>
<h2><span id="color-blendingemissive"><strong>Color Blending/Emissive</strong></span></h2><p>For the Final Color we just create a fresnel from the object’s normal map and multiply it by the Psuedorandom cell noise input. Then we blend between this value and the object’s base color using the Gradient Sampled Edge Mask Output. We do the same for the emissive, blending between the Emissive Input, using the Gradient Sampled Edge Mask Output.</p>
<p><img src="colorblending.png" alt="colorblending.png"></p>
<h2><span id="basecolor"><strong>BaseColor</strong></span></h2><p><img src="basecolor.gif" alt="basecolor.gif"></p>
<h2><span id="emissive"><strong>Emissive</strong></span></h2><p><img src="Emissive.gif" alt="Emissive.gif"></p>
<p>And that’s it! the entire functions node network should look something like this:</p>
<p><img src="FullFunction.png" alt="FullFunction.png"></p>
<p>The Function Node will look like this when you use it in your material, it’ll take your entire material as an input and apply the shader effect on top of your existing shader</p>
<p><img src="FunctionNode.png" alt="FunctionNode.png"></p>
<h2><span id="randomized-glitch"><strong>Randomized Glitch</strong></span></h2><p><img src="Glitch_01.gif" alt="Glitch_01.gif"></p>
<p>To make make a randomized glitch effect like the one shown above, it’s jsut a matter of swapping out the sine gradient part of network with a netwrok that creates a spheremask with a time based randomised position, which can be done with the following. </p>
<p><img src="RandomPos.gif" alt="RandomPos.gif"></p>
<p>If you preview the result from this, you will see that it is basically a sphere mask that get moved around the model randomly</p>
<p><img src="Glitch_Combo.gif%22" alt="Glitch_Combo.gif&quot;"></p>
<p>And that’s it! Hope you found this breakdown useful! Feel free to email me if you have any questions.</p>
<p><img src="Final.gif" alt="Final.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Procedural Hologram Shader</title>
    <url>/2021/10/03/Hologram-Shader-V1/</url>
    <content><![CDATA[<h1><span id="procedural-hologram-shader">Procedural Hologram Shader</span></h1><!-- toc -->

<ul>
<li><a href="#the-setup"><strong>The Setup</strong></a></li>
<li><a href="#shader-setup"><strong>Shader Setup</strong></a></li>
<li><a href="#generating-random-values-per-face"><strong>Generating Random Values Per Face</strong></a></li>
<li><a href="#world-position-offset"><strong>World Position Offset</strong></a></li>
<li><a href="#look-development"><strong>Look development</strong></a></li>
<li><a href="#generate-procedural-grid-using-uv-coordinate"><strong>Generate Procedural Grid using UV Coordinate</strong></a></li>
<li><a href="#horizontal-paning-bar"><strong>Horizontal Paning Bar</strong></a></li>
<li><a href="#combining-grid-and-panning-bar"><strong>Combining grid and Panning Bar</strong></a></li>
<li><a href="#random-opacity-curve"><strong>Random Opacity Curve</strong></a></li>
<li><a href="#creating-an-opacity-curve-for-glow"><strong>Creating an Opacity Curve for glow</strong></a></li>
<li><a href="#opacity"><strong>Opacity</strong></a></li>
<li><a href="#emissive"><strong>Emissive</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="Post12.gif" alt="Post12.gif"></p>
<p>This was a quick little effect I came up with, to try and test some ideas I had for some Procedural Vertex Animation and a hacky technique for generating psuedorandom Vectors per face in the Shader. This would probably be infinitely easier to do if Unreal gave us access to Triangle,Vertex and Poly data in the Material Editor. But here’s what I did.</p>
<p><font color="red">Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<p><strong>The main goal with this effect was to try and make the shader fully procedural</strong>.It would probably be quite easy to recreate using textures.</p>
<p><img src="HoloSphere_01.gif" alt="HoloSphere_01.gif"></p>
<p><img src="HoloSphere_02.gif" alt="HoloSphere_02.gif"></p>
<h2><span id="the-setup"><strong>The Setup</strong></span></h2><p>This effect uses a simple sphere mesh with Split Edges as the base object. This is not really a reusable effect, as I was jsut experimenting.</p>
<p><img src="sphere.png" alt="sphere.png&quot;"></p>
<p><img src="sphere.gif" alt="sphere.gif"></p>
<h2><span id="shader-setup"><strong>Shader Setup</strong></span></h2><p>I n a nutshell, the shader basically displaces each face along it’s normal, and the animation is driven by some math in the Shader. We also procedurally generate some psuedorandom Vec2 values per face of the object, we then use these per face values to have each face have some randommness in how muc hthey displace.</p>
<h2><span id="generating-random-values-per-face"><strong>Generating Random Values Per Face</strong></span></h2><p>The Network below uses the VertexNormal with the <strong>MF_Vec2Noise2D</strong> function to generate some psuedorandom vec2 values per face on the model, Time is used in the Seed value so that the vec2 values randomly change over time. This Technique only works on simple concave/convex shapes which is why the shader, is not reusable. Perhaps there is some way to access some kind of PolygonID value using the Custom Node in unreal but I’m not familiar enough with Unreal’s Rendering API to figure out how to do it.</p>
<p><img src="Randomperface.png" alt="Randomperface.png"></p>
<p>The preview result looks like this</p>
<p><img src="Randomperface.gif" alt="Randomperface.gif"></p>
<p><strong>MF_Vec2Noise2D</strong> takes in a vec2 input and outputs a psuedorandom vec2 value from it. THe node network for the function can be seen below</p>
<p><img src="MF_Vec2Noise2D.png" alt="MF_Vec2Noise2D.png"></p>
<h2><span id="world-position-offset"><strong>World Position Offset</strong></span></h2><p>The network below uses a sphere mask, to drive displacement alongthe Vertex normal, using the Red Channel from the psuedorandom value generated previosuly to create soem variation in the displacement. The SineWave is jsut being used to preview, in the end we can jsut replace it with a scalar Parameter.</p>
<p><img src="WPO.png" alt="WPO.png"></p>
<p>If you wire the result from this into the world position output, you should see this result</p>
<p><img src="WPO.gif" alt="WPO.gif"></p>
<h2><span id="look-development"><strong>Look development</strong></span></h2><h2><span id="generate-procedural-grid-using-uv-coordinate"><strong>Generate Procedural Grid using UV Coordinate</strong></span></h2><p>The tricky part here was getting the grid lines to line up perfectly with the edges on the mesh so that when each poly was dispalced outward they would have a perfect outline around them</p>
<p><img src="grid.png" alt="grid.png"></p>
<p>Multiplying the R and G channels of the UV coords iwth the X and Y subdivision of the sphere mesh, makes the grid lines match the number of edges on the mesh.If you preview the result form this network you will see it does.</p>
<p><img src="gridpre.png" alt="gridpre.png"></p>
<h2><span id="horizontal-paning-bar"><strong>Horizontal Paning Bar</strong></span></h2><p>This is done in localized world Space, could have jsut as easily used a Texture or used UV Coords to generate it.</p>
<p><img src="HorizontalPanningBar.png" alt="HorizontalPanningBar.png"></p>
<p>The result from this network</p>
<p><img src="panningbar.gif" alt="panningbar.gif"></p>
<h2><span id="combining-grid-and-panning-bar"><strong>Combining grid and Panning Bar</strong></span></h2><p>Next the Panning bar and Grid Results are combine together, by doing the following little bit of math</p>
<p><img src="combine.png" alt="combine.png"></p>
<p>If you preview the result from the power node, you wil lsee this</p>
<p><img src="grid.gif" alt="grid.gif"></p>
<p>If you wire in the results from this network into their respective shader inputs, you will get something that looks like this.</p>
<p><img src="gridresult.gif" alt="gridresult.gif"></p>
<h2><span id="random-opacity-curve"><strong>Random Opacity Curve</strong></span></h2><p>This section of the shader creates the opacity curve so that the ppoly’s appear randomly as the form the sphere</p>
<p><img src="baseopacity.png" alt="baseopacity.png"></p>
<p>Wire this into the opacity and you’ll get this result</p>
<p><img src="baseopacity.gif" alt="baseopacity.gif"></p>
<h2><span id="creating-an-opacity-curve-for-glow"><strong>Creating an Opacity Curve for glow</strong></span></h2><p>If you look at the effect, you’ll notice that the glow does something interesting, each face glows bright before it becomes fully visible</p>
<p><img src="HoloSphere_V2.gif" alt="HoloSphere_V2.gif"></p>
<p>This is done by tweaking the opacity curve to have a quick bump as it almost reaches full value of 1.</p>
<p>If we think of the opacity curve as a linear gradient over time, it’ll look something like this.</p>
<p><img src="grad_01.png" alt="grad_01.png"></p>
<p>So what I we do is add a small bump around the 0.75 area where the value quickly climbs to 1</p>
<p><img src="grad_02.png" alt="grad_02.png"></p>
<p>Now if we add these two curves together we will get a gradient that has a bump right before it hits a value of one</p>
<p><img src="grad_03.png" alt="grad_03.png"></p>
<p>so here’s how we achieve that</p>
<p><img src="glowcurve.png" alt="glowcurve.png"></p>
<p>If you preview the result from this network you will see this.</p>
<p><img src="glowcurve.gif" alt="glowcurve.gif"></p>
<p>As you can see it uses the result from the sinewave and the RandomFacevalue to isolate gradient curve as it hits a value of 0.85, and adds a quick bump to the curve</p>
<p>The result from this network then gets added to the Opacity and Emissive sections as shown below to get teh final Effect.</p>
<h2><span id="opacity"><strong>Opacity</strong></span></h2><p><img src="Opacity_Final.png" alt="Opacity_Final.png"></p>
<h2><span id="emissive"><strong>Emissive</strong></span></h2><p><img src="Emissive_Final.png" alt="Emissive_Final.png"></p>
<p>And that gives us the final Effect, we can replace the sinewave with a Scalar Parameter and now we have a single Scalar parameter that controls the entire effect, the glow,opacity etc all work automatically.</p>
<p>To conclude here is a variation of the effect, in this one I force all the Random face values to go from 0-1 so that the sphere is fully formed and isn’t jsut partially formed.</p>
<p><img src="HoloSphere_01.gif" alt="HoloSphere_01.gif"></p>
<p><img src="HoloSphere_02.gif" alt="HoloSphere_02.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Post Process Glitch</title>
    <url>/2021/10/03/Post-Process-Glitch/</url>
    <content><![CDATA[<h1><span id="post-process-glitch">Post Process Glitch</span></h1><!-- toc -->

<ul>
<li><a href="#introduction"><strong>Introduction</strong></a></li>
<li><a href="#pixellation"><strong>Pixellation</strong></a></li>
<li><a href="#rgb-offset"><strong>RGB Offset</strong></a></li>
<li><a href="#rgb-color-noise"><strong>RGB Color Noise</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post15.gif" alt="post15.gif"></p>
<p>This Post-Process effect came about after I saw this <a href="https://twitter.com/klemen_lozar/status/1017116328539217920">Tweet</a> from Klemen Lozar, it was neat little glitch effect, So I decided to take it a little further and try and make a Post0Process Glitch shader.</p>
<p><font color="red">Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<h2><span id="introduction"><strong>Introduction</strong></span></h2><p>The Entire Shader is created procedurally and makes use of some of my Custom Noise Functions that I feature in my previous Glitch Effects breakdown, so be sure to read through that before following along with this one.</p>
<p>The effect basically has three layers</p>
<ol>
<li><p>Pixellation</p>
<p> <img src="pixellate.gif" alt="pixellate.gif"></p>
</li>
<li><p>RGB Offset</p>
<p> <img src="offset.gif" alt="offset.gif"></p>
</li>
<li><p>Color noise (Vertical/Horizontal)</p>
<p> <img src="colornoise.gif" alt="colornoise.gif"></p>
</li>
</ol>
<h2><span id="pixellation"><strong>Pixellation</strong></span></h2><p>This is a pretty common effect, it’s basically a UV trick where we multiple the UV’s with a resolution amount, round the values down so that each cell determined by resolution value only samples a single pixel to create the pixellated look, the lower the “Resolution” the more low-res it looks. We add one extra step to this we multiple the Resolution value by a psuedorandom scalar value, so that the resolution value varies over time to feel more glitch like. We also create a Psuedorandom cell mask to mask out the glitch so that it only appears at certain times on certain parts of the screen.</p>
<p><img src="pixellation_Whole.png" alt="pixellation_Whole.png"></p>
<p>Make sure the <strong>Scene Texture</strong> Node is set to use PostProcessInput0</p>
<p><img src="scenetexturesettings.png" alt="scenetexturesettings.png"></p>
<p>If you wire the result from the <strong>Node Marked 1</strong> directly into the Scene Textuer node you can see what the fully pixellated result looks like.</p>
<p><img src="pixellate.gif" alt="pixellate.gif"></p>
<p>The Pixellate Mask section basically uses the 2D Noise Function to create an Animated Black and White cell Mask in ScreenSpace that then Interpolates between regular Screen UV’s and the Pixellated Screen UV’s. If you plug the result from <strong>Round Node Marked 3</strong> directly into the emissive, You ucan see what the mask looks like</p>
<p><img src="pixellatemask.gif" alt="pixellatemask.gif"></p>
<p>Note that you can control the tiling of the mask by multiplying a scalar value with the U and V of the screen Coordinates, in this case I jsut left a default value of 3 for both, but you can create a parameter to control that as well.</p>
<p>We then use it to Interpolate between the Regular Screen UV’s and the Pixellated Screen Uv’s and feed that to the SceneTexture UV Input, for the Final Result:</p>
<p><img src="pixellate02.gif" alt="pixellate02.gif"></p>
<h2><span id="rgb-offset"><strong>RGB Offset</strong></span></h2><p>The RGB offset is basically the same as what Klemen does in his shader, but instead of using a texture we use a psuedorandom cell noise function to drive the offset.</p>
<p><img src="RGB_Offset.png" alt="RGB_Offset.png"></p>
<p>The network of nodes under the section <strong>Offset Noise</strong> basically uses the Screen UV’s as input for the <strong>MF_Vec2Noise2D</strong> Function to generate some animated psuedorandom screenspace 2D CellNoise, we use this noise to offset the pixels of the screen, you can preview what this noise looks like by plugging in the result from <strong>MF_Vec2Noise2D</strong> into the emissive output:</p>
<p><img src="cellnoise.gif" alt="cellnoise.gif"></p>
<p>We take the result from the Noise Function and then multiple it by 3 different values for the Red , Green and Blue Channles respectively, we then add each of these to the Result from the Pixellated Screen UVs to get three different Uv results that will drive the Red,Green and Blue Channel of the Screen Buffer. If you preview the result from the <strong>MakeFlaot3</strong> you’ll see this.</p>
<p><img src="offset_02.gif" alt="offset_02.gif"></p>
<p>The section under <strong>Pixellate Offset Mask</strong> is basically the same thing that we did in the previous section, we are using the Noise function to generate a black an white cell mask which we will use to Interpolate between the Pixel Effect and the Offset Effect</p>
<p><img src="offsetmask.gif" alt="offsetmask.gif"></p>
<p>The last thing to do in this section is to just interpolate between the Pixellated Scene Texture Result and the Offset Scene Texture result using the PixelOffset Mask</p>
<p><img src="pixeloffset.gif" alt="pixeloffset.gif"></p>
<h2><span id="rgb-color-noise"><strong>RGB Color Noise</strong></span></h2><p>This last section deals with adding some horizontal and vertical color streaks to try and mimic the glitchy effects you would see in old cable TV’s when the signal was messy. Here too we make use of our handy Custom Noise Functions</p>
<p><img src="colornoise.png" alt="colornoise.png"></p>
<p>The <strong>ColorGlitchMask</strong> section does the same thing as teh previous two sections it creates a black and white cell mask, that we will use later to mask out the areas where the RGB Color Streaks show.</p>
<p><img src="mask03.gif" alt="mask03.gif"></p>
<p>The two sections at the bottom <strong>CellNoise</strong> and <strong>HorizontalStreak</strong> use the <strong>MF_Vec3Noise3</strong> function to generate some screen space color(Vector3) noise as shown below respectively</p>
<p><img src="cellnoiseanimated.gif" alt="cellnoiseanimated.gif"></p>
<p><img src="horizontalnoise.gif" alt="horizontalnoise.gif"></p>
<p>The <strong>VerticalMsk and Horizaontal Mask</strong> sections are very similar to the previous mask we have created, in that they generate animated screen space Masks, in this case we isolate the V and U respectively to get Vertical Lines and Horizontal Lines as shown below</p>
<p><img src="verticalline.gif" alt="verticalline.gif"></p>
<p><img src="horizontalline.gif" alt="horizontalline.gif"></p>
<p>We then multiple the VerticleLine Mask with the result from cellnoise, and the result from the HorizontalLine Mask with the result from the horizontal Streak section and add both together before multiplying it with the overall <strong>GlitchColorMask</strong> which gives us the Final Result for the color Streaking</p>
<p><img src="streaking.gif" alt="streaking.gif"></p>
<p>The Last thing to do is take the result from the RGB Color Noise Section and Add it to the result from the last two sections to give us the Final Result, You can see the Entire Network Below</p>
<p><img src="Fullnetwork.png" alt="Fullnetwork.png"></p>
<p>And the Final Result</p>
<p><img src="Final.gif" alt="Final.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Post Process Scan Effect</title>
    <url>/2021/10/03/Post-Process-Scan-Effect/</url>
    <content><![CDATA[<h1><span id="post-process-scan-effect">Post Process Scan Effect</span></h1><!-- toc -->

<ul>
<li><a href="#high-level-components"><strong>High Level Components</strong></a></li>
<li><a href="#scaling-distance-field-sphere"><strong>Scaling Distance Field Sphere</strong></a></li>
<li><a href="#sobel-edge-function"><strong>Sobel Edge Function</strong></a></li>
<li><a href="#world-aligned-grid-texture"><strong>World-Aligned Grid Texture</strong></a></li>
<li><a href="#bringing-it-all-together"><strong>Bringing it All Together!</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post04.gif" alt="post04.gif"></p>
<p>I got some free time this weekend in between school-work, and I decided to go back to doing some shader doodles, I came up with the Post-Process Scan Effect. I imagine it being used in a game as some sort distance based scan Effect.And we also use some simple noise distortion to make the scan effect look a little more interesting</p>
<p><font color="red">Note:If any of the images are not clear you can right-click and open in a new tab to view a Higher Resolution Version</font></p>
<p>In this section I’m going to breakdown how this effect was made in UE4, now there are multiple ways you could approach creating an effect like this, this jsut happens to be the method that I chose</p>
<h2><span id="high-level-components"><strong>High Level Components</strong></span></h2><p>The basic idea behind this effect is to create a sobel-edge/modified version of the scene render and then blend it between the regular scene render based on a World-Space Sphere mask, and this mask is animated to create the scanning effect.</p>
<p>This effect is primarily a combination of 3 main pieces</p>
<ul>
<li><p>A Scaling Distance Field Sphere Mask</p>
</li>
<li><p>Sobel-Edge Post PRocess Function(I wont be expalining how this function works as it is a topic of its own, but I shall link the code I referenced)</p>
</li>
<li><p>World Projected Grid Texture Overlay</p>
</li>
</ul>
<h2><span id="scaling-distance-field-sphere"><strong>Scaling Distance Field Sphere</strong></span></h2><p>This deals with how we create the scaling sphere mask, we make use of a simple distance Field equation to create a sphere, here’s how it works.  </p>
<p><img src="DF_01_Nodes.JPG" alt="DF_01_Nodes.JPG"></p>
<p>Plug in the result of the clamp into the emissive output of your Post-Process Material, and u will see something like this in your viewport. </p>
<p><img src="DF_01.JPG" alt="DF_01.JPG"></p>
<p>“TexLoc” is a vector3 that defines the location of the origin of the sphere, in my case I have it being read from a Parameter Collection, so that it can be read from gmeplay to use for eg the Player Position, but this value basically represents the location of the center of the sphere mask.</p>
<p>The bbove bit of “Node-Code” basically defines a Distance Field Sphere with a radius of 1024 units, I used the clamp jsut to show the result in the viewport as the actualy values go muc hHigher than 1. If you would like a deepdive on distance Fields and their uses I highly reccomend checking out <a href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">Inigo Quillez’s website</a></p>
<p>Now we are going to use a Time Variable to Scale this Sphere Over Times</p>
<p><img src="DF_Scaling_Nodes" alt="DF_Scaling_Nodes"></p>
<p>This will result in something like this</p>
<p><img src="DF_Scaling.gif" alt="DF_Scaling.gif"></p>
<p>Frac(time) basically gives us a constant period that keeps going 0-1,0-1,0-1. We multiply time by a small number 0.25 to control the scaling speed and then we multiple ply the Fraction result with the radius of the sphere, this makes the radius go from 0-1024, tus giving us an animated sphere mask.</p>
<p>This is good progress, but this does not work for out effect, we need a scaling ring. This can be easily accomplished with a little bit of math on our current result.</p>
<p><img src="Edge_Mask.png" alt="Edge_Mask.png"></p>
<p>This will give us what we want, basically a growing ring, with a nice gradient falloff which can be controlled. </p>
<p><img src="Edge_Mask.gif" alt="Edge_Mask.gif"></p>
<p>The bit of math under “Edge Mask” basically samples a positon in the gradient of the distance Field, in this case 0.5 and defines an edge mask from that position with a specified width, this is what gives us a nice scaling ring. I will not go into too much detail aboutthis technique of edge masking, maybe I’ll cover it in mroe detail in another post.</p>
<p>As you can see whe have complete control over how wide the ring is with out scalar parameter, and if we wantedwe could even control the falloff with a power node, but that is not required forthis effect</p>
<p>The nest step is to use some noise, to create some interesting variation to the ring</p>
<p>For this we make use of UE4’s “Vector Noise Node”, you can read more about it <a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/ExpressionReference/Vector/#vectornoise">here</a>, you could alternatively just use a custom noise texture that has WorldALigned UV COordinates</p>
<p>In my Shader I set the Vector Noise Node to use “CellNoise”, feel free to experiment with other nosie types to get you own unique effect</p>
<p><img src="DF_Noise.png" alt="DF_Noise.png"></p>
<p>The result will look something like this </p>
<p><img src="DF_Noise.gif" alt="DF_Noise.gif"></p>
<p>This concludes the First Step of our shader, next we will look at the Implementing the Sobel-Edge Function</p>
<h2><span id="sobel-edge-function"><strong>Sobel Edge Function</strong></span></h2><p>There are many different variations of this function, some more optimized than others, I am not explain this function as it is a topic of it’s own, but a simple google search should give you an abundance of resources</p>
<p>The basic idea behind Sobel-Edge Detection is this, we take the scene RenderTarget(Imagine this as a texture that holds what you currently see in your viewport)and compare each pixel with all the neighbouring pixels around it, and we compare the difference in brightness, if the brightness difference is above a certain threshold, we mark it as an edge, and in this process we get a black and white mask texture of the scene rendertarget, that has the edges masked out.</p>
<p>The code below is a simple example of a sobelEdge Function made in Shadertoy by <a href="https://www.shadertoy.com/view/4t3XDM">RebelMoogle</a>(I think this one isn’t fully optimized, maybe try another one), we will recreate it in UE4 with the Material Nodes</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fragColor = 4.*abs(fwidth(texture(iChannel0, uv)));</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> TL = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> TM = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> TR = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> ML = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">0</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> MR = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">0</span>)/ iResolution.xy).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> BL = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">-1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> BM = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">-1</span>)/ iResolution.xy).rgb;</span><br><span class="line">    <span class="type">vec3</span> BR = <span class="built_in">texture</span>(iChannel0, uv + <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">-1</span>)/ iResolution.xy).rgb;</span><br><span class="line">                         </span><br><span class="line">    <span class="type">vec3</span> GradX = -TL + TR - <span class="number">2.0</span> * ML + <span class="number">2.0</span> * MR - BL + BR;</span><br><span class="line">    <span class="type">vec3</span> GradY = TL + <span class="number">2.0</span> * TM + TR - BL - <span class="number">2.0</span> * BM - BR;</span><br><span class="line">   	</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* vec2 gradCombo = vec2(GradX.r, GradY.r) + vec2(GradX.g, GradY.g) + vec2(GradX.b, GradY.b);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    fragColor = vec4(gradCombo.r, gradCombo.g, 0, 1);*/</span></span><br><span class="line">    </span><br><span class="line">    fragColor.r = <span class="built_in">length</span>(<span class="type">vec2</span>(GradX.r, GradY.r));</span><br><span class="line">    fragColor.g = <span class="built_in">length</span>(<span class="type">vec2</span>(GradX.g, GradY.g));</span><br><span class="line">    fragColor.b = <span class="built_in">length</span>(<span class="type">vec2</span>(GradX.b, GradY.b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In UE4 it looks like this:</p>
<p><img src="SobelEdge_Nodes.png" alt="SobelEdge_Nodes.png"></p>
<p>A few notes about this setup make sure that your “SceneTexture” nodes are set to use “PostProcessInput0”</p>
<p><img src="SceneTexture_Settings.png" alt="SceneTexture_Settings.png"></p>
<p>The two Custom Nodes GradX and Grady, use the following:</p>
<p><img src="Sobel_Edge_Custom.png" alt="Sobel_Edge_Custom.png"></p>
<ul>
<li>GradX:</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> -TL + TR - <span class="number">2.0</span> * ML + <span class="number">2.0</span> * MR - BL + BR;</span><br></pre></td></tr></table></figure>
<ul>
<li>GradY:</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> TL + <span class="number">2.0</span> * TM + TR - BL - <span class="number">2.0</span> * BM - BR;</span><br></pre></td></tr></table></figure>

<p>This does not necessarily have to be done with a custom node, i used it merely for convenience sake, as otherwise it would have been too much node spaghetti.</p>
<p>If you plug in the end result of this Node Network to the emissive channel, you will see somthing like this in your Viewport</p>
<p><img src="SobelEdge.png" alt="SobelEdge.png"></p>
<p><img src="EdgeTinted.jpg" alt="EdgeTinted.jpg"></p>
<p>We also multiply this result with a simple Vector3 so that we can tint the edges whatever color we want</p>
<p><img src="EdgeTint.png" alt="EdgeTint.png"></p>
<h2><span id="world-aligned-grid-texture"><strong>World-Aligned Grid Texture</strong></span></h2><p>This part is easy we just use a simple grid texture and make it world aligned, and later combine it with the sobel-edge fucntion to get a cool BluePrint graph type effect</p>
<p><img src="WorldAlignedGrid.png" alt="WorldAlignedGrid.png"></p>
<p>If you plug this into the emissive, it looks like this</p>
<p><img src="WorldGrid.png" alt="WorldGrid.png"></p>
<h2><span id="bringing-it-all-together"><strong>Bringing it All Together!</strong></span></h2><p>Now we will bring all three parts together, for the final Effect!</p>
<p>First we will combine the Sobel-Edge function and the World-Aligned Grid Function by adding them together</p>
<p><img src="SW.png" alt="SW.png"></p>
<p>Next we create a sceneTexture Node and add the result from the sobeledge and World Grid to it</p>
<p>Then we Interpolate between the regular sceneTexture and the Added one, using the result of the scaling ring mask we created in the first part</p>
<p><img src="FinalCombine.png" alt="FinalCombine.png"></p>
<p>And voila we are done, The end result will look something like this. You can of course tweak the parameters and try changing some values to get different results</p>
<p><img src="FinalResult.gif" alt="FinalResult.gif"></p>
<p>I hope you found this informative, cheers</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Rainy Surface Shader Part 1</title>
    <url>/2021/10/03/Rainy-Surface-Shader-Part-1/</url>
    <content><![CDATA[<h1><span id="rainy-surface-shader-part-1">Rainy Surface Shader Part 1</span></h1><!-- toc -->

<ul>
<li><a href="#introduction"><strong>Introduction</strong></a></li>
<li><a href="#textures"><strong>Textures</strong></a></li>
<li><a href="#basic-concept"><strong>Basic Concept</strong></a></li>
<li><a href="#hiding-the-time-loop"><strong>Hiding the Time Loop</strong></a></li>
<li><a href="#ripple-normals"><strong>Ripple Normals</strong></a></li>
<li><a href="#wet-surface-water-lookdev-inputs-from-base-materials"><strong>Wet Surface, Water LookDev, Inputs from Base Materials</strong></a></li>
<li><a href="#basecolor"><strong>BaseColor</strong></a></li>
<li><a href="#normal-blending">Normal Blending</a></li>
<li><a href="#metallicroughness"><strong>Metallic,Roughness</strong></a></li>
<li><a href="#using-the-function"><strong>Using the Function</strong></a></li>
</ul>
<!-- tocstop -->

<p><img src="post08.gif" alt="post08.gif"></p>
<h2><span id="introduction"><strong>Introduction</strong></span></h2><p>So this is going to be part 1 of a two parter that will cover how I created my <strong>Slope Aware Rainy Surface</strong> Material Function in UE4. This part is going to cover how to create rainy ripples/patters on surface that are hit directly by rain, so without further ado, lets get started!</p>
<h2><span id="textures"><strong>Textures</strong></span></h2><p>There are 2 main textures we need to author for this Maerial Function, the first one is an RGB Channel Packed Msk Texture for the droplet,streaks and streak gradient. It is important to author this texture with proper gradient values for the shader to work accurately.</p>
<p>You can grab my Texture <a href="RainPattern_basecolor.tga">here</a></p>
<p><img src="Texture_Packing.jpg" alt="Texture_Packing.jpg"></p>
<p>In this part, we are priamrily only going to be using the Red Channel with the droplet mask, in part 2 will make use of the other two channels to create the streaking effect</p>
<p>The other texture will be a normal map for the water droplets</p>
<p>Grab the normal texture <a href="RainPattern_normal.tga">here</a></p>
<p><img src="Droplet_Normal.jpg" alt="Droplet_Normal.jpg"></p>
<h2><span id="basic-concept"><strong>Basic Concept</strong></span></h2><p>The basic idea is to use <a href="https://www.youtube.com/watch?v=724ZMiQx200"><strong>Alpha Erosion</strong></a> on the Pattern in the Red Channel of our channel packed texture, with some additional math to create the ripples</p>
<p>So lets get started, create a new Material Function in UE4 and name it whatever you want, I called mine “MF_Ripples”(this is a temporary function, later in part 2 of this article we will combine what we create in this article) and set up the nodes as shown below</p>
<p><img src="nodes_01.png" alt="nodes_01.png"></p>
<p>The Above network creates a basic Alpha Erosion setup, since we are making a material function, I’ve also setup two Function Inputs to Control <strong>Tiling</strong> and <strong>Rain Speed</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">TextureSample2D.x - (<span class="number">1.0</span> - frac(time*RainSpeed));</span><br></pre></td></tr></table></figure>

<p>The above equation gives us a simple period going 0-1, 0-1, we subtract this value from the <strong>Red Channel</strong> of our Texture, which gives us the Aplha erosion Effect Seen below</p>
<p><img src="nodes_01_vis.gif" alt="nodes_01_vis.gif"></p>
<p>Now we can use some math to create a simple edge mask to that the expanding dot’s look like ripples instead. Take the result from the Subtract node and do the following:</p>
<p><img src="nodes_02.png" alt="nodes_02.png"></p>
<p>This will result in the edges of the dots getting masked out to give us something that looks like and expanding ripple</p>
<p><img src="nodes_02_vis.gif" alt="nodes_02_vis.gif"></p>
<p>This is pretty good, but the ripples appear and disappear too abruptly, we need to make them fade-in and fade-out over time to make it look more natural. We can achieve this with a little bit of math:</p>
<p><img src="nodes_03.png" alt="nodes_03.png"></p>
<p>The Time is multiplied by the <strong>RainSpeed</strong> variable we made earlier.</p>
<p>What we are doing is multiplying the result from the <strong>Edge Mask</strong> with a absolute sine-wave i.e without the negative part, it has a period that goes [1,0,1] instead of[1,0,-1,0,1]. We have also remapped the time in this sine-wave so that it goes [0,1,0] in the same time that it takes our alpha erosion Time Function to go from [0-1]. This is visualized in the graph below.</p>
<p>The Equation that we multiply is</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(<span class="built_in">sin</span>((Time*RainSpeed)*<span class="number">0.5</span>));</span><br></pre></td></tr></table></figure>

<p><img src="Time_Graph.gif" alt="Time_Graph.gif"></p>
<p>This result’s in a nice Fade-out of the ripples as they reach their maximum size, as shown below</p>
<p><img src="nodes_03_vis.gif" alt="nodes_03_vis.gif"></p>
<h2><span id="hiding-the-time-loop"><strong>Hiding the Time Loop</strong></span></h2><p>This looks pretty good, but one big issue at the moment is that the rippling isn’t continuos, there is hard period where the ripples reset and start, we need to find a way to hide this effect, this can be achieved by creating a Time-Offset version of this current setup and combining the two together:</p>
<p>So copy and past the current node network and place it above so that current one make these small changes marked in the image</p>
<p><img src="nodes_04.png" alt="nodes_04.png"></p>
<p><font color="red">Note:Do not copy and paste the Input variables, just connect the existing ones to the second network of nodes:</font></p>
<p><font color="red">Note:I’ve also used a single time variable for both equations, so that the time offset is universal, and we don’t have to repeat it for each time node we use</font></p>
<p>So we’ve done two things, first we’ve offset the UV’s by 0.1 so that the second set of ripples aren’t in the same spot as our first group.</p>
<p>Next we add a time offset of 0.5, so that these ripples start and end with a 0.5s frequency offset compared to the first network.</p>
<p>You can see the two time frequencies visualized in the graph below</p>
<p><img src="Time_Offset.gif" alt="Time_Offset.gif"></p>
<p>Now we can blend between these two sets of ripples, with a Time function that is at exactly the same frequency to hide the abrupt starts and a get seamless ripples.</p>
<p><img src="Interp_Nodes.png" alt="Interp_Nodes.png"></p>
<p><font color="red">Note: Time is multiplied by the <strong>RainSpeed Variable</strong>.</font></p>
<p><img src="nodes_04_v2.png" alt="nodes_04_v2.png"></p>
<p>Now we use this Interpolation TIme Function as the alpha to Lerp between the two sets of ripples, which gives us seamless ripples.</p>
<p><img src="nodes_04_vis.gif" alt="nodes_04_vis.gif"></p>
<h2><span id="ripple-normals"><strong>Ripple Normals</strong></span></h2><p>The Normals for the ripples are starightforwad to set up, we just use the texture coordinates from the two sets of ripples and feed them to two seperate TextureSamples of teh same Normal Texture that I linked earlier, then we blend between these two normals, with the same Time Interpolation Function.</p>
<p><img src="Ripple_Normal.png" alt="Ripple_Normal.png"></p>
<h2><span id="wet-surface-water-lookdev-inputs-from-base-materials"><strong>Wet Surface, Water LookDev, Inputs from Base Materials</strong></span></h2><p>All the basic setups for the ripples are done, now we jsut need to setup ways to get Inputs from a base material(BaseColor,normal,metallic,roughness) so that we can blend in the ripples and wetness.The following sections will cover how to do that.</p>
<h2><span id="basecolor"><strong>BaseColor</strong></span></h2><p>For the BaseColor, we need to add a Function Input to Recieve the basecolor from the base material so that we can overlay the water color. We then overlay a water color and blend it using the ripplemask that we just created.</p>
<p>First add 4 Function Inputs <strong>WaterBrightness(Scalar),BaseColor(Vector3),WaterColor(Vector3),Metallic(Scalar)</strong></p>
<p><img src="nodes_05.png" alt="nodes_05.png"></p>
<p>We take the BaseColor Input and multiply it with the watercolor and then with the water brightness, this creates teh basecolor for the ripples.</p>
<p>We also take the basecolor and multiply it by 0.5 to make it darker in color, we do this becasue most surfaces become darker in color when wet, there are some exceptions mostly metals/non porous materials.This is why we use the Metallic input to lerp between the regular basecolor and the one that is multiplied to be darker.</p>
<p>We the ninterpolate between these to results with teh Ripple mask to create the final baseColor output.</p>
<p>Create a Function Output called <strong>Basecolor</strong> and plug it into that</p>
<p><img src="BaseColor_Output.png" alt="BaseColor_Output.png"></p>
<h2><span id="normal-blending">Normal Blending</span></h2><p>In this section we create a function input to read the base material Normal Information and then overlay the ripple normals on top of it.</p>
<p><img src="nodes_06.png" alt="nodes_06.png"></p>
<p>We take the ripple normals we created earlier, and combine it with the base material normal info using the handy <strong>Blend Angle Corrected Normals Function</strong>, we then lerp between the base material normal and the overlayed normal using the ripplemask</p>
<p>We then create a Function Output called Normal and plug the result into it.If you preview the result, you will see that the ripple nomrals are overlayed:</p>
<p><img src="Normal_Output.png" alt="Normal_Output.png"></p>
<p><img src="nodes_05_vis.gif" alt="nodes_05_vis.gif"></p>
<h2><span id="metallicroughness"><strong>Metallic,Roughness</strong></span></h2><p>The metallic and roughness setups are pretty straight forward:</p>
<p>For Metallic we set up a function Input to read the Base Material Metallic value and we linear interpolate it with a value of 0.0(I’m not sure what the correct metallic value to use for water is but I liked 0.0,since..well water isn’t metal)using, again the ripplemask as the alpha and then plug it into a function output called Metallic.</p>
<p><img src="nodes_07.png%22" alt="nodes_07.png&quot;"></p>
<p>For the roughness as well we set up an Input function to read the Values from the Base Material, multiply it by a value of 0.5(because once a surface is wet, it tends to be shinier), and then Lerp it with a value of 0.0 using the ripplemask for the alpha.Then same as before we create Function Output for Roughness and plug it into that.</p>
<p><img src="nodes_08.png" alt="nodes_08.png"></p>
<p>And that’s pretty much all we need in our function for now, we can off create more ripple networks to add more variation, but for now this is enough, another thing we could do is add refraction options so that, the water actaully refracts and bends the light on the surface, this is something I’ll cover in part-2 when we look at streaking and slope awareness.</p>
<p>We could also blend between ripples and patters based on vertex painted puddles so that the ripples only appear in areas with puddles and it patters on solid surfaces. Again stuff that will be covered in part-2.</p>
<h2><span id="using-the-function"><strong>Using the Function</strong></span></h2><p>Now in the detail’s panel we can expose the function to the library and access it in any of our other shaders, and alyer it.</p>
<p><img src="Expose.png" alt="Expose.png"></p>
<p>Below you can see how I’ve added teh function to one of epic’s default tile materials, jsut feed in teh appropraite inputs and use the outputs from teh function as inputs forthe base shader.</p>
<p><img src="MF_Ripple.png" alt="MF_Ripple.png"></p>
<p><img src="final_01.gif" alt="final_01.gif"></p>
<p><img src="final_02.gif" alt="final_02.gif"></p>
<p>I hope you found this useful, part 2 will cover slope awareness and streaking, and potentially creating a BP controlled Wind Actor to dynamically update streaking direction etc based on it. Coming Soon-ish!</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Rainy SurfaceShader in UE4 Part 2</title>
    <url>/2021/10/03/Rainy-Surface-Shader-Part-2/</url>
    <content><![CDATA[<h1><span id="rainy-surfaceshader-in-ue4-part-2">Rainy SurfaceShader in UE4 Part 2</span></h1><!-- toc -->

<ul>
<li><a href="#slope-awareness"><strong>Slope Awareness</strong></a></li>
<li><a href="#texture-setup"><strong>Texture Setup</strong></a></li>
<li><a href="#droplet-streaking-setup"><strong>Droplet Streaking Setup</strong></a></li>
<li><a href="#combining-with-ripple-effect"><strong>Combining with Ripple Effect</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="Cam1_opt.gif" alt="Cam1_opt"></p>
<p>This is a continuation of the <a href>first part</a>, so if you havn’t read that I recommend going through that first since this will continue where that left off, and you will need to be aware of that setup, so that you know how to combine both at the end..</p>
<p>Just as a side not, as I was writing this post, i actually came up with an even simpler and easier to use solution for this rain system, using just one Post-Process Material, I will cover that some other time</p>
<h2><span id="slope-awareness"><strong>Slope Awareness</strong></span></h2><p>So making the Function “slope aware” is actually incredibly simple, all we are doing is using a Z-gradient to blend betweek the Ripples Effect and the Streaking Effect that we create in this post.</p>
<p><img src="RainTest_T3.gif" alt="RainTest_T3"></p>
<p><img src="post05.gif" alt="post05"></p>
<p>Below you can see simple way to get a z-gradient</p>
<p><img src="z-gradient.png" alt="z-gradient"></p>
<p>The result looks like this</p>
<p><img src="z-gradient.gif" alt="z-gradient"></p>
<p>We use this result later to blend betweek the ripples and the water streaks</p>
<h2><span id="texture-setup"><strong>Texture Setup</strong></span></h2><p>So, if you remember the previous post, the texture setup we use is shown below, in this part we are going to make use of the Green and Blue Channels to make the water appear to drip.</p>
<p><img src="Texture_Packing.jpg" alt="Texture_Packing"></p>
<p>And the Normal Map</p>
<p><img src="texturenormal.png" alt="texturenormal"></p>
<h2><span id="droplet-streaking-setup"><strong>Droplet Streaking Setup</strong></span></h2><p>For the streaking, all we are actually doing is setting the texture to be World Aligned along the xz and yz axis, and then panning the gradient texture in the blue channel to create some simple alpha eroision, that makes the drops appear to streak.</p>
<p>First we create two input parameters, <strong>Streaks_Tiling</strong> and <strong>Streak_Length. RainSpeed</strong> was created in the last part, but it will be used for the streaking as well</p>
<p><img src="input_parameters.png" alt="input_parameters"></p>
<p>Next we set up the rain streaking texture to be world aligned along the xz and yz plane. We use the <strong>Green Channel</strong> which contains the streak pattern.</p>
<p><img src="worldalign.png" alt="worldalign"></p>
<p>We use the same <strong>RB</strong> and <strong>GB</strong> outputs as the uv input for the normal map as well.</p>
<p><img src="normal.png" alt="normal"></p>
<p>The result will look like this</p>
<p><img src="worldalign.gif" alt="worldalign"></p>
<p>Next we set up the world aligned panning setup for the gradient texture in the <strong>Blue Channel</strong></p>
<p><img src="gradientworldalign.png" alt="gradientworldalign"></p>
<p>The result has the texture mapped in world space and panning along the z-axis.</p>
<p><img src="gradientworldalign.gif" alt="gradientworldalign"></p>
<p>Now we take the result from the panning gradient texture, do some math operations to it and then subtract it from the original world aligned streak texture in the Green channel.</p>
<p>We also use the result from this to blend between a default normal color value and the World Aligned Normal Result</p>
<p><img src="streaking.png" alt="streaking"></p>
<p>If you preview the result from the <strong>StreakMask</strong> and the <strong>Normal</strong> you will see the following results respectively</p>
<p><img src="streakmask.gif" alt="streakmask"><img src="streaknormal.gif" alt="streaknormal"></p>
<p>The panning gradient creates an alpha erosion effect, that creates the illusion of dripping water</p>
<p>Note:There is a better solution for the Dripping water, I will cover that in one of my future posts.</p>
<h2><span id="combining-with-ripple-effect"><strong>Combining with Ripple Effect</strong></span></h2><p>Now all that’s left to do is blend between this streaking effect and the ripple effect using the z-gradient we created earlier in the post</p>
<p>This is the part where you will need to refer to the previous blog post, as we are essentially just adding a lerp for all the function outputs from the previous blog post, you can read it here</p>
<p>Find the normal output taht was setup in the previous Post and add a linear interpolation between the ripple normal and the streak normal</p>
<p><img src="normalblend.png" alt="normalblend"></p>
<p>Do the same for the mask as well</p>
<p><img src="maskblend.png" alt="maskblend"></p>
<p>Note: The result from this output will now take the place of all hte places where the ripple mask was being used to blend, like <strong>Basecolor,Metallic etc</strong></p>
<p><img src="result.gif" alt="result"></p>
<p>And that’s it now you ahve a material function that can be layered to any existing shader to make it look like the surface is being rained on, with parameters to control ripple size, rainspeed etc.</p>
<p><img src="MaterialFunction.png" alt="MaterialFunction"></p>
<p>Here’s a small test Environment I put together to show how the shader looks in a scene. All the materials used in the scene have the RainySurfaceMaterial function layered on them.</p>
<p><img src="Cam1_opt.gif" alt="Cam1_opt"></p>
<p><img src="Cam3_opt.gif" alt="Cam3_opt"></p>
<p><img src="Cam4_opt.gif" alt="Cam4_opt"></p>
<p><img src="Cam5_opt.gif" alt="Cam5_opt"></p>
<p><img src="Cam6_opt.gif" alt="Cam6_opt"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Star Wars Inspired Hologram Shader and Blueprint System</title>
    <url>/2021/10/03/Star-Wars-Hologram/</url>
    <content><![CDATA[<h1><span id="star-wars-inspired-hologram-shader-and-blueprint-system">Star Wars Inspired Hologram Shader and Blueprint System</span></h1><!-- toc -->

<ul>
<li><a href="#setup"><strong>Setup</strong></a></li>
<li><a href="#base-cylinder"><strong>Base Cylinder</strong></a></li>
<li><a href="#hologram-asset"><strong>Hologram Asset</strong></a></li>
<li><a href="#setting-up-the-parameter-collection"><strong>Setting up the Parameter Collection</strong></a></li>
<li><a href="#hologram-shader-1-assigned-to-cylinder-mesh"><strong>Hologram Shader 1: Assigned to Cylinder Mesh</strong></a></li>
<li><a href="#node-network-to-generate-z-gradient"><strong>Node Network to generate z-gradient</strong></a></li>
<li><a href="#node-network-to-control-scalingexpansion"><strong>Node Network to control scaling/Expansion</strong></a></li>
<li><a href="#adding-turbulance-to-worldposition-offset-for-glitchiness"><strong>Adding Turbulance to WorldPosition Offset for Glitchiness</strong></a></li>
<li><a href="#screenspace-2d-noise-visualized"><strong>ScreenSpace 2D Noise Visualized</strong></a></li>
<li><a href="#final-worldpositionoffset-result"><strong>Final WorldPositionOffset Result</strong></a></li>
<li><a href="#look-development"><strong>Look Development</strong></a></li>
<li><a href="#screen-space-parallel-bars"><strong>Screen Space Parallel Bars</strong></a></li>
<li><a href="#fresnel-and-camerafade"><strong>Fresnel and CameraFade</strong></a></li>
<li><a href="#fresnel-result"><strong>Fresnel Result</strong></a></li>
<li><a href="#camerafade-result"><strong>CameraFade Result</strong></a></li>
<li><a href="#color-and-opacity"><strong>Color and Opacity</strong></a></li>
<li><a href="#hologram-shader-2-assigned-to-game-mesh"><strong>Hologram Shader 2: Assigned to Game Mesh</strong></a></li>
<li><a href="#worldposition-offset-setup-for-activation"><strong>WorldPosition Offset Setup for Activation</strong></a></li>
<li><a href="#turbulance"><strong>Turbulance</strong></a></li>
<li><a href="#screen-space-noise-visualized"><strong>Screen Space Noise Visualized</strong></a></li>
<li><a href="#look-development-1"><strong>Look Development</strong></a></li>
<li><a href="#encapsulating-into-a-blueprint"><strong>Encapsulating into a Blueprint</strong></a><ul>
<li><a href="#components-and-variables"><strong>Components and Variables</strong></a></li>
</ul>
</li>
<li><a href="#construction-script"><strong>Construction Script</strong></a></li>
<li><a href="#event-graph"><strong>Event Graph</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post11.gif" alt="post11.gif"></p>
<p>I wanted to do this little shader because I had been watching a lot of the <strong>The Clone Wars</strong> animated show lately, and I wanted to recreate the holograms from the show, I really like the iconic star wars hologram effect, it’s very simple yet effective.</p>
<p>I decided to try and make my system easily re-usable within a game development context, so I created a blueprint system to encapsulate the hologram system, which lets you assign any asset you want to be shown as a hologram. The Majority of the effect is handled by two shaders, and the blueprint setup is a convenient way to make the system re-usable as a game object.</p>
<p><font color="red">Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<p><img src="post11_V2.gif" alt="post11_V2.gif"></p>
<h2><span id="setup"><strong>Setup</strong></span></h2><p>The system makes use of two meshes:</p>
<h2><span id="base-cylinder"><strong>Base Cylinder</strong></span></h2><p><img src="cylinder.gif" alt="cylinder.gif"></p>
<p>The base cylinder is jsut a cylinder with no caps, and the pivot aligned to the bottom center(This is important). We use this as the hologram base projection, using a shader we will reshape it an animate it.</p>
<h2><span id="hologram-asset"><strong>Hologram Asset</strong></span></h2><p><img src="scope.png" alt="scope.png"></p>
<p>This can be any asset, in my case I’m using a scope I modelled a while back as my asset.</p>
<p>Each of these objects will get a unique shader with similar look-dev and some shared parameters so that they work together.</p>
<h2><span id="setting-up-the-parameter-collection"><strong>Setting up the Parameter Collection</strong></span></h2><p>First we setup an MPC for the shared parameters</p>
<p><img src="MPC.png" alt="MPC.png"></p>
<ul>
<li><strong>Activation</strong>:Scalar parameter that controls the hologram’s on/off status.</li>
<li><strong>Turbulance_Amt</strong>:Scalar parameter that controls how much turbulance/distortion affects the hologram.</li>
<li><strong>Turbulance_Displacement</strong>:Scalar parameter that controls the amount of dispalcement in the turbulance.</li>
</ul>
<h2><span id="hologram-shader-1-assigned-to-cylinder-mesh"><strong>Hologram Shader 1: Assigned to Cylinder Mesh</strong></span></h2><p>Generate Z-Gradient to drive Scaling of the mesh in the shader, for activation/deactivation.</p>
<h2><span id="node-network-to-generate-z-gradient"><strong>Node Network to generate z-gradient</strong></span></h2><p><img src="zgradient_nodes.png" alt="zgradient_nodes.png"></p>
<h2><span id="node-network-to-control-scalingexpansion"><strong>Node Network to control scaling/Expansion</strong></span></h2><p><img src="dimensionscaling_nodes.png" alt="dimensionscaling_nodes.png"></p>
<p>The result from the z-gradient is used to drive the WorldPosition offset logic that controls the height and expansion of the cylinder.</p>
<p>The <strong>Activation</strong> parameter is a scalar value that controls the height of the cylinder (0 = squished, 1 = fully expanded height)</p>
<p>The <strong>spreadfactor</strong> parameter is a scalar value that controls the radius spread of the top part of the cylinder(Ths is in world units)</p>
<p>You can see the result from tweaking these two parameters below</p>
<p><img src="gradientscaling.gif" alt="gradientscaling.gif"></p>
<h2><span id="adding-turbulance-to-worldposition-offset-for-glitchiness"><strong>Adding Turbulance to WorldPosition Offset for Glitchiness</strong></span></h2><p>Next we generate psuedorandom noise in screen space and use it to add some Turbulance to the WorldPosition Offset to create some glitchiness. The setup is shown below</p>
<p><img src="turbulance_nodes.png" alt="turbulance_nodes.png"></p>
<p><strong>TurbulanceAmt</strong> is a scalar parameter that controls how much turbulance is present(0=no turbulance, 1 = full turbulance)</p>
<p><strong>Turbulance_Dispalcement</strong> controls how extreme the dispalcement is.(This value is in world units)</p>
<p>The result from this gets added to the resut from Scaling/Expansion and that creates teh final output for the WorldPositionOffset of the Shader.</p>
<h2><span id="screenspace-2d-noise-visualized"><strong>ScreenSpace 2D Noise Visualized</strong></span></h2><p><img src="2DNoiseVisualize.gif" alt="2DNoiseVisualize.gif"></p>
<h2><span id="final-worldpositionoffset-result"><strong>Final WorldPositionOffset Result</strong></span></h2><p><img src="WPO.gif" alt="WPO.gif"></p>
<p>It looks weird now, but once we add the look-dev, it works quite well</p>
<h2><span id="look-development"><strong>Look Development</strong></span></h2><h2><span id="screen-space-parallel-bars"><strong>Screen Space Parallel Bars</strong></span></h2><p>We use a little bit of UV math to create screen space panning parallel bars, we also do some math with the camera position and object position to make sure that the screen space bar’s continue tiling consistently regardless of distance from the screen</p>
<p><img src="ScreenSpaceBars.png" alt="ScreenSpaceBars.png"></p>
<p>If you preview the result from this network, it will look like this(I preview it by wiring it into the basecolor,opacity and emissive)</p>
<p><img src="bars.gif" alt="bars.gif"></p>
<h2><span id="fresnel-and-camerafade"><strong>Fresnel and CameraFade</strong></span></h2><p>Next we setup a fresnel and CameraFade that will later be used to drive the opacity.</p>
<p><img src="fresnelcamerafade.png" alt="fresnelcamerafade.png"></p>
<h2><span id="fresnel-result"><strong>Fresnel Result</strong></span></h2><p><img src="fresnel.gif" alt="fresnel.gif"></p>
<h2><span id="camerafade-result"><strong>CameraFade Result</strong></span></h2><p><img src="camerafade.gif" alt="camerafade.gif"></p>
<h2><span id="color-and-opacity"><strong>Color and Opacity</strong></span></h2><p>Next we create the main graph network for the color, Emissive and Opacity, this is driven primarily by the result from the z-gradient and Activation Parameter, I combine it with the results from <strong>ScreenSpace bars, Fresnel and CameraFade</strong> for the final color,Emissive and Opacity.</p>
<p><img src="coloropacity.png" alt="coloropacity.png"></p>
<p>The result from the DepthFade(DepthFade is to prevent hard clips through geometry) node goes into Opacity, and the result from the color multiply drives the emissive and the base color.</p>
<p>The end result is this, with parameters to control activation,turbulance and spread.</p>
<p><img src="cylinderresult.gif" alt="cylinderresult.gif"></p>
<h2><span id="hologram-shader-2-assigned-to-game-mesh"><strong>Hologram Shader 2: Assigned to Game Mesh</strong></span></h2><p>This shader will be pretty identical to the previous one assigned to the cylinder but with a few changes so that it works with complex meshes</p>
<h2><span id="worldposition-offset-setup-for-activation"><strong>WorldPosition Offset Setup for Activation</strong></span></h2><p>The setup below controls the scaling and Opacity</p>
<p><img src="WPO_scope.png" alt="WPO_scope.png"></p>
<p>The result from the z-gradient drives the opacity and the result from the WorldPosition Math drives the scaling of the Mesh.</p>
<p>In this case when I generate the z-gradient I add 160(Height of the cylinder mesh) to the z-channel, this is so that the scaling happens within the scale of the base cylinder.</p>
<p>by sliding the value of <strong>Activation</strong> from 0 - 2 you will see the following result.</p>
<p><img src="WPO_scope.gif" alt="WPO_scope.gif"></p>
<h2><span id="turbulance"><strong>Turbulance</strong></span></h2><p><font color="red">Note: The Rotation is handled in the BLueprint and is covered in the last section, doing the rotation in the shader resulted in some errors when doing the look development,because vertex normals weren’t recalculated for the fresnel. More on that later.</font></p>
<p>Next I add some math to create some turbulance.</p>
<p>The turbulance section is very similar to what was done in the previous shader, we generate some screen space noise, and use it to distort the WorldPosition of the mesh.</p>
<p><img src="turbulancerotation.png" alt="turbulancerotation.png"></p>
<p>The Function <strong>MF_FloatNoise2D</strong> takes a vec2 and returns a psuedorandom float as the result.The node network for it is shown below.</p>
<p><img src="MF_FloatNoise2D.png" alt="MF_FloatNoise2D.png"></p>
<h2><span id="screen-space-noise-visualized"><strong>Screen Space Noise Visualized</strong></span></h2><p><img src="turbulancevisualize.gif" alt="turbulancevisualize.gif"></p>
<p>Wiring the result from this network into the WorldPositionoffset, will look like this, we also have the <strong>Turbulance_Amt</strong> parameter which can be used to animate/control the turbulance as shown below</p>
<p><img src="turbulancerotate.gif" alt="turbulancerotate.gif"></p>
<p>The result from the <strong>Turbulance</strong>section and the initial <strong>z-gradient WorldPositonOffset</strong> result gets added together to give us the final output that get’s wired into the WorldPositionOffset input for the shader.</p>
<p>Now, we have a setup with parameters to control activation as well as turbulance</p>
<p><img src="finalwpo.gif" alt="finalwpo.gif"></p>
<h2><span id="look-development"><strong>Look Development</strong></span></h2><p>This part is identical to what we did in the previous shader.</p>
<p>One thing we could have done here, is used the <strong>object’s baked Normal Map</strong> and used that to calculate the fresnel,this is nice because the baked normal gives us more surface details to work with, and thus results in a much more detailed fresnel, but I have avoided this here because I found it difficult to make this work with a re-usable Blueprint System, especially when sometimes meshes have multiple material ID’s with multiple normal maps. So for now we just stick to using the <strong>Vertex Normals</strong>.</p>
<p><img src="lookdev.png" alt="lookdev.png"><br><img src="//lookdev.png" width="1024"></p>
<p>The results from these networks gives us our Emissive Color and our opacity outputs.Now we have a shader with parameters to control <strong>activation,turbulance and color.</strong>&gt;As you can see below.</p>
<p><img src="lookdevscope.gif" alt="lookdevscope.gif"></p>
<p><img src="lookdevactivation.gif" alt="lookdevactivation.gif"></p>
<p><img src="lookdevturbulance.gif" alt="lookdevturbulance.gif"></p>
<p><img src="lookdevcolor.gif" alt="lookdevcolor.gif"></p>
<p>Put both meshes together in the scene and try tweaking the activation parameter in the MPC.</p>
<p><img src="comp1.gif" alt="comp1.gif"></p>
<h2><span id="encapsulating-into-a-blueprint"><strong>Encapsulating into a Blueprint</strong></span></h2><p>Now i just set up a simple blueprint for ease of use.</p>
<p>The BP has two parts, the <strong>construction script</strong> which handles bulk of the work, choosing meshes,materials,postioning etc and the Event Graph which will handle rotation during runtime.</p>
<h4><span id="components-and-variables"><strong>Components and Variables</strong></span></h4><p>I expose certain variables, so that they can be tweaked in the editor</p>
<p><img src="viewport.png" alt="viewport.png"></p>
<h2><span id="construction-script"><strong>Construction Script</strong></span></h2><p>The first part of the construction script creates the Dynamic Material Instances and assigns the material to the Cylinder Mesh</p>
<p><img src="cs_p1.png" alt="cs_p1.png"></p>
<p>I wanted the BP to have the ability to pick between using a skeletal mesh with animation or a regular static mesh, the following sections set up the Mesh part</p>
<p><img src="cs_p2.png" alt="cs_p2.png"></p>
<p>Continueing from the last section, sometimes meshes have multiple material id’s, so we use a For Loop to cycle through all the Material Indexes and assign the Hologram Material to Each Part</p>
<p><img src="cs_p3.png" alt="cs_p3.png"></p>
<p>Objects tend to have pivot inconsistant pivot locations, so we have a parameter available so that we can compensate for any offsets manually. We also use the objectbounds to calculate the <strong>SpreadFactor</strong> that is fed into the cylinder’s Hologram Shader</p>
<p><img src="cs_p4.png" alt="cs_p4.png"></p>
<h2><span id="event-graph"><strong>Event Graph</strong></span></h2><p>The event graph is only used if we enable mesh rotation, it is used to rotation the object at runtime.</p>
<p><img src="eventgraph.png" alt="eventgraph.png"></p>
<p>Now if we drop the Blueprint into the level and select it it should have all these parameters</p>
<p><img src="parameters.png" alt="parameters.png"></p>
<p>Now we have a blueprint that we can use to assign any mesh we have to use in the hologram system, we can choose to use a skeletal mesh with animations or just a regular StaticMesh. As well as parameters to control activation,turbulance etc.</p>
<p><img src="SkelHolo_opt.gif" alt="SkelHolo_opt.gif"></p>
<p><img src="holoskull.gif" alt="holoskull.gif"></p>
<p><img src="SM_Holo1_opt.gif" alt="SM_Holo1_opt.gif&quot;"></p>
<p><img src="SM_Holo2_opt.gif" alt="SM_Holo2_opt.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：Teleportation Shader</title>
    <url>/2021/10/03/Teleportation-Shader/</url>
    <content><![CDATA[<h1><span id="teleportation-shader">Teleportation Shader</span></h1><!-- toc -->

<ul>
<li><a href="#setup"><strong>Setup</strong></a></li>
<li><a href="#localized-z-gradient-mask"><strong>Localized Z-Gradient mask</strong></a></li>
<li><a href="#a"><strong>A</strong></a></li>
<li><a href="#b"><strong>B</strong></a></li>
<li><a href="#noise-pattern"><strong>Noise Pattern</strong></a></li>
<li><a href="#opacity-mask"><strong>Opacity Mask</strong></a></li>
<li><a href="#vertex-deformation"><strong>Vertex Deformation</strong></a></li>
<li><a href="#emissive"><strong>Emissive</strong></a></li>
<li><a href="#conclusion"><strong>Conclusion</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post13.gif" alt="post13"></p>
<p>This small shader effect came out of another shader I was making that was inspired by this <a href="https://twitter.com/phi6/status/989638191949975552">Fog of War Effect</a> I came across on twitter. I then modified the Material Function to work as Teleportation Shader Effect</p>
<h2><span id="setup"><strong>Setup</strong></span></h2><p>Like a lot of my other Fx Shaders, this one is also wrapped into a Material Function for easy Re-usability. This one is actually quite similar to the glitch effect and use a lot of the same concepts.The basic idea for this effect is to use a linear gradient along the z-Axis of the object to create an opacity Mask, we combine the mask with some Noise Patterns to make it look more interesting, then we add some Vertex Deformation to add some more interest to the effect.</p>
<p><font color="red">Note: You can open the images in a new tab to view them at a higher resolution</font></p>
<p>This is what the initial setup for the material function looks like, we take an entire Base Material as the input and we add shader effects on top of it.</p>
<p><img src="MF_Setup.png" alt="MF_Setup"></p>
<h2><span id="localized-z-gradient-mask"><strong>Localized Z-Gradient mask</strong></span></h2><p>First we create a localized linear z-gradient based on the object bounds, please note this setup assumes that the object’s pivot is located at it’s base, if not you would need to add the necessary offset value for the offset input.</p>
<p><img src="z-gradient_01.png" alt="z-gradient_01"></p>
<p>Previewing this result, will result in a linear gradient from top to bottom.</p>
<p><img src="gradient_01.gif" alt="gradient_01"></p>
<p>Next we create an inverted version of the gradient which we will use later to drive vertex Deformation, and we also subtract a scalar Parameter that we can use to drive the effect. Note that I am using a Sine wave to preview the result, in the end the effect is controlled with a Scalar Parameter value going from 0-1</p>
<p><img src="z-gradient_02.png" alt="z-gradient_02"></p>
<p>If you preview A and B respectively you will see the following results, as you can see we are using the “Transition” Scalar input(0-1) to drive the gradient, which in turn will drive the Opacity mask and the Vertex Deformation later.</p>
<h2><span id="a"><strong>A</strong></span></h2><p><img src="gradient_A.gif" alt="gradient_A"></p>
<h2><span id="b"><strong>B</strong></span></h2><p><img src="gradient_B.gif" alt="gradient_B"></p>
<h2><span id="noise-pattern"><strong>Noise Pattern</strong></span></h2><p>Next we setup an animated cell noise pattern to drive the effect, <strong>MF_Vec3Noise3</strong> is a Material Function that generates a psuedorandom Vector given an input, I cover this in a previous post you can read it <a href="https://deepspacebanana.github.io/">here</a>.We also create an Input varaible <strong>Number_Tiling</strong> so that we can control the tiling of the noise in the Base Shader. Note that this setup can be repalced with any kind of world Aligned Noise Pattern Texture to achieve different effects. I will show some examples at the end of teh blog.</p>
<p><img src="Noise_01.png" alt="Noise_01"></p>
<p>if you preview the results from the Red or Green Channel, you will see similar results, we use the green channel to drive the emissive later, and we will use the red channel to distort the opacity result</p>
<p><img src="Noise_G.gif" alt="Noise_G"></p>
<h2><span id="opacity-mask"><strong>Opacity Mask</strong></span></h2><p>To get the final Opacity Mask, we take the <strong>Result from A</strong> and subtract the result from the <strong>Red Channel</strong> of the Noise Pattern, and round to the highest value. This result gets plugged into the Opacity Mask Output.</p>
<p><img src="opacity.png" alt="opacity"></p>
<p>Previweing this result will show the following</p>
<p><img src="opacity_p_01.gif" alt="opacity_p_01"></p>
<h2><span id="vertex-deformation"><strong>Vertex Deformation</strong></span></h2><p>Next we use the result from <strong>z-gradient B</strong> to displace the meshes Vertices Along the z-Axis to create the effect of being beamed up, we also use some noise to distort the deformation to add some visual interest, once again this noise can be repalced with different patterns to achieve different effects, we use Vector(0,0,1) to control the direction of the displacement. The result from this network goes into the WorldPositionOffset output.</p>
<p><img src="VertexDeformation.png" alt="VertexDeformation"></p>
<p>We have two input variabes <strong>Noise_Tiling</strong> to control the tiling of the noise pattern and <strong>Displacement_Amt</strong> to control how far along the z-axis the Vertices get Displaced.The result looks like this</p>
<p><img src="VertexDeformation.gif" alt="VertexDeformation"></p>
<h2><span id="emissive"><strong>Emissive</strong></span></h2><p>In this last section we use the Noise Pattern to add some emissive to the effect to finish it off. We use a seperate scalar Parameter called <strong>GlowPatternControl</strong> to control the emissive Transition, I did this so that we can have more artistic control over the timings of the effect, we could just as easily have this controlled by the <strong>z-gradient</strong> or the <strong>Transition Scalar Parameter</strong>. We also have a another input variable <strong>Glow_Color</strong> to control the color of the emissive glow.</p>
<p><img src="emissive.png" alt="emissive"></p>
<p>Previweing the result from this network</p>
<p><img src="emissive.gif" alt="emissive"></p>
<h2><span id="conclusion"><strong>Conclusion</strong></span></h2><p>And there you have it, now you should have a material function with the following inputs that you can add to any shader</p>
<p><img src="MF_Node.png" alt="MF_Node"></p>
<p>Here’s the full Material Graph for reference</p>
<p><img src="completegraph.png" alt="completegraph"></p>
<p>Here are some variations using different patterns.</p>
<p><img src="Line_01.gif" alt="Line_01"></p>
<p><img src="ManCube_01.gif" alt="ManCube_01"></p>
<p><img src="ManNumbers.gif" alt="ManNumbers"></p>
<p><img src="ManTriangle.gif" alt="ManTriangle"></p>
<p><img src="Tesseract_Gif_01.gif" alt="Tesseract_Gif_01"></p>
]]></content>
  </entry>
  <entry>
    <title>转载：UE4 Apparition Material</title>
    <url>/2021/10/03/UE4-Apparition-Material/</url>
    <content><![CDATA[<h1><span id="ue4-apparition-material">UE4 Apparition Material</span></h1><!-- toc -->

<ul>
<li><a href="#introduction"><strong>Introduction</strong></a></li>
<li><a href="#the-sphere-mask"><strong>The Sphere Mask</strong></a></li>
<li><a href="#pattern-texture"><strong>Pattern Texture</strong></a></li>
<li><a href="#binary_generatortga"><strong>Binary_Generator.tga</strong></a></li>
<li><a href="#edge-masking-for-emissive"><strong>Edge Masking for Emissive</strong></a></li>
<li><a href="#final-touches"><strong>Final Touches</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post06.gif" alt="post06.gif"></p>
<h2><span id="introduction"><strong>Introduction</strong></span></h2><p>This was a simple apparition material I came up with when I was messing around with Inigo Quillez’s distance field functions. This shader uses a scaling Distance Field Sphere as a mask transition the opacity, then we use some vdb textures to make the transition look interesting.</p>
<h2><span id="the-sphere-mask"><strong>The Sphere Mask</strong></span></h2><p>This part is basically the same as what I did in my Post-Process Scan Effect Article with only one difference, please refer to that post for an explanation of how we set up the animated distance field,</p>
<p><img src="DistanceFieldSphere.png" alt="DistanceFieldSphere.png"></p>
<p>As you can see the only big difference is that here we use the objects position instead of a Vector3 Paramter, technically you can add or subtract values from the object position to position the Distance Field Sphere as you like.</p>
<p>If you plug in the result from this network to the material’s <strong>Opacity Mask</strong> input, you will see something like this</p>
<p><img src="DF_Masking.gif" alt="DF_Masking.gif"></p>
<p>As you can see the Distance Field Sphere creates a spherical Apparition shape forthe mesh, you can technicaly use any kind of Distance Field Function you want, so any kind of shape is possible, the sphere is the simples and cheapest i nterms of instruction count</p>
<p>In the next step we are going to use some pattern textures to make the effect look more interesting, and then finally we will combine it with some emissives for the finishing touch</p>
<h2><span id="pattern-texture"><strong>Pattern Texture</strong></span></h2><p>I am using a Texture with three different greyscale patterns packed into each channel to drive the effect, here is what my setup looks like:</p>
<h2><span id="binary_generatortga"><strong>Binary_Generator.tga</strong></span></h2><p><img src="TextureSetup.jpg%22" alt="TextureSetup.jpg&quot;"></p>
<p>Now we will combine the gresycale information from the Pattern to modify the mask as shown below:</p>
<p><img src="Noise_Combine.png" alt="Noise_Combine.png"></p>
<p>As you can see we subtract the Red channel of the pattern texture from the result of the Distance Field Function to create the value difference at the edges that brings in the pattern, into the mask function. We also multiply the red channel by a scalar Parameter <strong>MaskSpread</strong>(note:As you increase the spread value, you will also need to increase the radius of the DF Sphere to compensate for the spread so that the entire mesh is covered in the transition, i.8 mutliple the objectradius by a higher value.), which controls the spread of teh noise values from the edges, if we increase this value, you will get more noise spread</p>
<p>If we preview the clamp node, we will get a preview of what the mask looks like now:</p>
<p><img src="MaskNoisePre.gif" alt="MaskNoisePre.gif"></p>
<h2><span id="edge-masking-for-emissive"><strong>Edge Masking for Emissive</strong></span></h2><p>In this section we will create and edge mask, so that the edges of the transition can be highlighted with an emissive color, this setup is also borrowed from my Post-Process Scan Effect Article so read about it there for a full explanation.</p>
<p><img src="EdgeMask.png" alt="EdgeMask.png"></p>
<p>What I have done here is basically take the Mask Field (Result of the Subtract node) and run it through an Edge Mask Function,This basically masks the edges of the Distance Field Sphere ,this gives us the result shown below wich we will sue to lerp with an emissive value for the edges</p>
<p><img src="EdgeMask.gif" alt="EdgeMask.gif"></p>
<h2><span id="final-touches"><strong>Final Touches</strong></span></h2><p>Now we just plug in the emissive mask and Opacity Mask to their respective inputs</p>
<p><br>All we have to do now is multiply the emissive mask with an Emissive Color Value and plug that output into the Emissive input of the material, and plug our Opacity Mask output to the opacity input of the material, and Voila we are done!</p>
<p><img src="Final_Nodes.png" alt="Final_Nodes.png"></p>
<p><img src="CubeGif_02.gif" alt="CubeGif_02.gif"></p>
<p>You can of course, swap out the patterns used to get different effects as well as tweak teh different parameters in the shader to get variations, here’s a couple I made with just adjusting values and changing patterns.</p>
<p><img src="NumberGif_02.gif" alt="NumberGif_02.gif"></p>
<p><img src="NumbersGif_01.gif" alt="NumbersGif_01.gif"></p>
<p>I hope you found this articel useful! Cheers!</p>
]]></content>
  </entry>
  <entry>
    <title>转载：Wormhole Shader Effect</title>
    <url>/2021/10/03/Wormhole-Shader-Effect/</url>
    <content><![CDATA[<h1><span id="wormhole-shader-effect">Wormhole Shader Effect</span></h1><!-- toc -->

<ul>
<li><a href="#overview"><strong>Overview</strong></a></li>
<li><a href="#basic-concept"><strong>Basic Concept</strong></a></li>
<li><a href="#initial-setup"><strong>Initial Setup</strong></a></li>
<li><a href="#setting-up-blueprint-actor-to-feed-wormhole-location"><strong>Setting up Blueprint Actor to Feed Wormhole Location</strong></a></li>
<li><a href="#distance-gradient-mask"><strong>Distance Gradient Mask</strong></a></li>
<li><a href="#deforming-vertices"><strong>Deforming Vertices</strong></a></li>
<li><a href="#making-the-material-function"><strong>Making the Material Function</strong></a></li>
</ul>
<!-- tocstop -->

<p>源地址：<a href="https://deepspacebanana.github.io/deepspacebanana.github.io/">https://deepspacebanana.github.io/deepspacebanana.github.io/</a></p>
<p><img src="post07.gif" alt="post07.gif"></p>
<p>This effect is actually just a re-working of one of my old doodles, the effects is quite simple, but it seemed like a really nice use-case. I’ve seen similar effects being used for “Loot Pickup Effects” in games. It is a basic Vertex Deformation Shader under the hood</p>
<h2><span id="overview"><strong>Overview</strong></span></h2><p>This effect basically uses a Vector3 input(Location of wormhole i.e area that sucks in geometry) to generate a Distance Gradient, then the pixels that are inside this sphere get sucked towards the center with a falloff controlled by the gradient strength. we will be creating this as a material Function inside UE4 so that it can be easily applied to any existing material that we have. So let’s get started!</p>
<h2><span id="basic-concept"><strong>Basic Concept</strong></span></h2><p>The basic concept behind this effect is to use a world space Distance Field Sphere Mask to blend between two different WorldPosition Offsets, one is the central location of the mask i.e center of the wormhole and the other is the regular location of the pixels in the world</p>
<h2><span id="initial-setup"><strong>Initial Setup</strong></span></h2><p>First there are a couple setups we need to make, so that we can feed the location of the wormhole from a Gameplay object or a Blueprint. In my case I use a <strong>Material Parameter Collection(MPC)</strong> to store the location value and then use it in the shader.</p>
<p><img src="MPC_Setup.png" alt="MPC_Setup.png"></p>
<p>So in your content browser right-click&gt;Materials &amp; Textures&gt;MaterialParameterCollection to create a new MPC Asset,give it a name(I named mine “M_Bhole_Collection”..seemed like a good idea at the time..),then double click to open it up and click on the “+” sign next to vector Parameters to add a new Vector Parameter to the collection. Name it “Texloc” or anything you want really, but this is the parameter we will store the location from the blueprint.</p>
<p><img src="MPC_Setup_01.png" alt="MPC_Setup_01.png"></p>
<p><img src="MPC_Setup_02.png" alt="MPC_Setup_02.png"></p>
<h2><span id="setting-up-blueprint-actor-to-feed-wormhole-location"><strong>Setting up Blueprint Actor to Feed Wormhole Location</strong></span></h2><p>In this section we will set up a basic blueprint actor that we will use as our gameplay object whose location we will feed into the shader to serve as the Wormhole’s global Location</p>
<p>Create a new Blueprint Asset type Actor, give it a name(I called mine BP_Texture_Locator), open up the event graph and set it up as shown below:</p>
<p><img src="BP_TextureLocator.png" alt="BP_TextureLocator.png"></p>
<p><img src="BP_Setup_01.png" alt="BP_Setup_01.png"></p>
<p>On the “Set Vector Parameter node”, when you click on the collection Paramter dropwon, it should list all of the MPC’s available in your project, choose the one you had created earlier. Then when you click the “Parameter Name” dropdown it will list all of the Vector Parameters available in that MPC. Choose the “TexLoc” parameter.</p>
<p>With this set up, now the location of this BP actor will be fed to the “<strong>TexLoc</strong>“ variable every tick, we can now use it in our shader to define the location of the Wormhole.</p>
<p>Next create a new Material, we use a material only because it is easier to test with while we make the shader. Later we will take all of the stuff created in this material and put it into a Material Function, this function will be where we put all of our shader math, we set this up as a material Function so that this Effect can easily be layered onto any exisitng surface shader.</p>
<h2><span id="distance-gradient-mask"><strong>Distance Gradient Mask</strong></span></h2><p>There’s multiple ways to apprach this part, one solution is to use a Distance Field Sphere mask as I’ve shown Post-Process-Scan-Effect</p>
<p>But i used a slightly different method this time, but it yeilds the same results:</p>
<p><img src="Mask_01.png" alt="Mask_01.png"></p>
<p>What this does is it creates, a spherical gradient based on the distance between the pixels and the location of the Blueprint actor</p>
<p>Go ahead and add a couple objects into your scene and apply the material we jsut made to them.Now drag the Blueprint Actor you made earlier into the level and try moving it around.You should see something like below:</p>
<p><img src="Mask_g01.gif" alt="Mask_g01.gif"></p>
<p>The important thing here is to note how we read the Location of the Blueprint we set up earlier. Inside the shader, we can use a node called “<strong>Collection Parameter</strong>“.</p>
<p><img src="MPC_Parameter.png" alt="MPC_Parameter.png"></p>
<p>This node lets us read variables from MPC’s inside our shader. If you click the node and look at it’s details panel, you will notice that you can link the MPC asset you created and choose the parameter the node will reference.</p>
<p><img src="MPC_Parameter_Settings.png" alt="MPC_Parameter_Settings.png"></p>
<h2><span id="deforming-vertices"><strong>Deforming Vertices</strong></span></h2><p>The basic concept here is to crush all the vertices of the geo to a finite point defined by the location of the Blueprint. Look at the following example.</p>
<p><img src="WPO_Crush.png" alt="WPO_Crush.png"></p>
<p>If you plug that into the World Position Offset pinof the material, you will get something like this</p>
<p><img src="WPO_01.gif" alt="WPO_01.gif"></p>
<p>Absolute World Position - Object position gives us the localized world position of the object, so when we Lerp between it and a null value with a sine-wave as the alpha, the vertices contract to a finite point and expand back up. We use this same concept, but instead of using the “object position” we will use the Blueprint location from the MPC and instead of a sine-wave alpha we will use the scaling distance field mask.</p>
<p>We take the same logic, and replace Object position with the Location parameter, and then use teh gradient mask from the previous step as an alpha to lerp between the new WPO and a null value as shown below: </p>
<p><img src="Mask_02.png" alt="Mask_02.png"></p>
<p>Now if you try moving the BP actor around in the level you’ll notice that the vertices of the meshes get pulled towards it’s center based on the gradient mask falloff.</p>
<p><img src="Mask_g02.gif" alt="Mask_g02.gif"></p>
<h2><span id="making-the-material-function"><strong>Making the Material Function</strong></span></h2><p>At this point all the basic setups for the effect are complete, We can now wrap all this functionality into a Material Function so that, the effect can be easily layered on top of any existing shaders</p>
<p>Create a new material Function, I called mine MF_VertCrush and set it up as shown, below, it’s exactly the same as what I made before but with some tweaks:</p>
<p>Right click and open in new tab to view higher resolution:</p>
<p><img src="MF_VertCrush_Full.png" alt="MF_VertCrush_Full.png"></p>
<p>The Function has 3 Outputs:</p>
<p><strong>BaseColor</strong>: To override the basecolor of the objects material</p>
<p><strong>Emissive</strong>:To add emissive coloration to the shader.</p>
<p><strong>WorldPositionOffset</strong>:This will output the modified WPO to the shader</p>
<p>And we create input parameters for any scalar or vector parameter that we need to read from the Objects surface shader as well as any parameters that we want to be adjustable, in the function like radius, falloff etc</p>
<p>In this instance I’ve multiplied the mask radius with a sine-wave to make the effect oscillate the way it does in the gif below, I’ve also added some basic fresnel emissive based on the gradient mask, so that areas affected by the wormhole, get a fresnel emissive.I’ve also subtracted a noise texture from the gradient mask to create some variation in strength.</p>
<p>In the details panel, enable “<strong>expose to library</strong>“. Now if you make a new material and right-click and search for your function name, it will show up in the dropdown menu:</p>
<p><img src="Expose.png%22" alt="Expose.png&quot;"></p>
<p><img src="Search.png" alt="Search.png"></p>
<p>So now, you can basically access this function in any material and layer it on as shown below, by feeding the appropriate parameters into the function and using it’s outputs on the final output pins</p>
<p><img src="MatFunc.png" alt="MatFunc.png"></p>
<p>You can see the end results below, where I have applied the function to some of Epic’s demo assets. I hope you found this mini-tutorial useful, feel free to email me if you ahve any questions or suggestions!</p>
<p><img src="post07.gif" alt="post07.gif"></p>
<p><img src="Wormhole_Suck.gif" alt="Wormhole_Suck.gif"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/06/Houdini%20Engine%20for%20Unity-Plugin%20API/</url>
    <content><![CDATA[<h1><span id="houdini-engine-for-unity-plugin-api">Houdini Engine for Unity-Plugin API</span></h1><p>此文档关于houdini引擎的C# API学习<br>官方文档位置：<br><a href="http://www.sidefx.com/docs/unity/_plugin_a_p_i.html">http://www.sidefx.com/docs/unity/_plugin_a_p_i.html</a></p>
<p>分为三部分 1&gt; Asset layer 2&gt;Utility layer 3&gt;HAPI layer<br>1&gt;资产层<br>即资产创建以及参数获取和修改的操作<br>包含以下几个类<br>HEU_HoudiniAssetRoot这是Unity中Houdini Engine资产的根组件。它是轻量级的，仅充当层次结构的根并提供用户界面。<br>HEU_HoudiniAsset这是主要的资产组件，其中包含资产的所有元数据，以及构建，烹饪，查询和修改资产的功能。<br>HEU_ParameterUtility包含便利功能，用于查询和修改资产上的参数。<br>官方提供了一个相关的实例文档：<br>Plugins / HoudiniEngineUnity / Scripts / Examples / HEU_ExampleEvergreenQuery.cs</p>
<p>此目录为unity houdini 引擎的包位置下。</p>
<p>实例文档笔记<br>using HoudiniEngineUnity;</p>
<p>HEU_AssetDatabase.GetAssetFullPath</p>
<p>//Manages the asset database to store persistent assets such as materials, textures, asset data, etc. Wraps around Unity AssetDatabase. Only available in Editor. Probably not needed at runtime as data probably does not need to persist past session.<br>//Given relative path to an asset (with Assets/ in the path), this returns the full path to it.</p>
<p>HEU_SessionBase<br>//Base class for a Houdini Engine session. Contains functionality to interface with the Houdini Engine for a particular session.</p>
<p>HEU_SessionManager.GetOrCreateDefaultSession()<br>//Manages a session for Houdini Engine. Supports all types of sessions.<br>//获取或者创建有效会话</p>
<p>HEU_HAPIUtility.InstantiateHDA(evergreenFullPath, Vector3.zero, session, true);<br>//houdini引擎的工作，如创建hda，cook等。<br>//Load and instantiate an HDA asset in Unity and Houdini, for the asset located at given path.创建指定路径的hda</p>
<p>public static GameObject InstantiateHDA(string filePath, Vector3 initialPosition, HEU_SessionBase session, bool bBuildAsync)<br>FilePath文件路径     initialPosition 初始位置  获取会话 是否重载</p>
<p>HEU_EditorUtility.SelectObject(rootGO);<br>//Wrapper around Unity Editor functions.Unity编辑器函数的包装。<br>//选择物体 返回数组</p>
<p>HEU_HoudiniAsset houdiniAsset = QueryHoudiniAsset(rootGO);<br>//HEU_HoudiniAsset 资产组件<br>//QueryHoudiniAsset Shows how to get the HEU_HoudiniAsset component from a HDA root gameobject.</p>
<p>// Make sure the HDA is cooked before querying or changing its properties.<br>CookAsset(houdiniAsset);</p>
<p>// Example of querying and changing parms.<br>ChangeParmsAndCook(houdiniAsset);</p>
<p>// This will query objects, geometry, parts, and attributes in the asset.<br>QueryObjects(houdiniAsset);</p>
<p>// This will query the gravity attribute.<br>QueryAttribute(houdiniAsset, “EvergreenGenerator”, “EvergreenGenerator1”, 0, “Cd”);</p>
<p>HEU_HoudiniAssetRoot<br>//The root object of a Houdini Engine asset. Used for organizing hierarchy, and more importantly displaying custom UI.</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/06/Houdini%20Python(%E4%BA%8C)/</url>
    <content><![CDATA[<p>阅读本篇的前提，是了解了python的语法结构，如果有什么不清楚的请阅读我的上一篇文章。</p>
<p><a href="https://zhuanlan.zhihu.com/p/109349860">https://zhuanlan.zhihu.com/p/109349860</a></p>
<p>之后的文章将只讲述Hpython。</p>
<p>这次我先总结一些关于如何使用的小的Tips，仅我个人观点。</p>
<ol>
<li>关于查询对应的属性调用，请把鼠标光标放在你想查询的属性面板上，根据提示就可以知道对应属性。</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%871.png"></p>
<p>Parameter即是属性的真名（这让我想起了神话的真名设定）</p>
<ol start="2">
<li>节点创建的名称查询的提示<br>创建一个节点可以使用create系列的创建函数，然后写入你想要创建的节点即可。节点的名字一般的情况下是他的名称去除末尾的数字例如下图。</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%872.png"></p>
<p>但是是有例外的，例如mantra节点，如果直接使用mantra无法创建该节点，这时候需要使用node.type().name() 来获取到你需求的节点的名字。然后就获得了mantra其实名字叫”ifd”.</p>
<ol start="3">
<li>关于功能上的查询，比如你想实现一个快捷操作的功能，最快的方法就是抄轮子了，但是如果没有轮子的情况下怎么办，由于houdini我目前没有发现和maya，max的操作代码返回的功能，所以我的解决办法就是看库。<br><img src="%E5%9B%BE%E7%89%873.png"><br>如下图所示，houdini 已经将库的类分门别类的整理好，并且有一句话概括，这样就可以根据个人需求去对应的类型里查找需要的功能。<br><img src="%E5%9B%BE%E7%89%874.png"><br>我个人认为最快捷有效的学习方法就是查阅对应的帮助文档和对应的官方教程。</li>
</ol>
<p>还有就是查阅帮助，我认为并不是需求要背会，或者百分百掌握，而是会使用它完成个人需求，所以不要对帮助的查阅产生恐惧心理。</p>
<p>4.请学会看错误提示<br>很多时候，但你写完你的需求运行时，会出现错误，导致无法获得想要的结果，这时对应的ide会返回错误提示信息，这里说下python shell<br><img src="%E5%9B%BE%E7%89%875.png"></p>
<p>例如上图，请看最后一行，提示名称错误，然后对细节进行了解释。</p>
<p><img src="%E5%9B%BE%E7%89%876.png"></p>
<p>上图爆出了一大段错误提示，看不懂的部分没事，只要获取我们有效的信息就行，一般就在最后一行， 提示节点的类型名称错误。</p>
<p>其他的错误也同理。    </p>
<p>最后，如果你想验证自己到底会不会用了，那么请去实践，如果没有想法，可以去实现一个abc文件导入搭建初始场景的功能，我相信当你实现了这个功能就会对hpython 有个初步的认知。</p>
<p>对了，我要简要描述下如何将你的功能放到工具架上使用，可以在工具架上选择“+”号添加你的个人工具架，然后再工具架上右键 “New Tool…” 然后将你写好的功能拷贝到“Script”中，然后保存就可以使用了，关于更加细节的如何自定义包体，icon，导入库，之后我会新文章中进行阐述。</p>
<p>下面是我个人的abc文件导入的代码，可以给你少许参考。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#__version__ = &quot;2.0&quot;</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;Gong Sheng&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFile</span>(<span class="params">filePath,fileType</span>):</span></span><br><span class="line">    flieList = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> dirpath,dirnames,filenames <span class="keyword">in</span> os.walk(filePath):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(filename)[<span class="number">1</span>] <span class="keyword">in</span>  fileType:</span><br><span class="line">                value=dirpath[<span class="built_in">len</span>(filePath)+<span class="number">1</span>:]</span><br><span class="line">                value=value.replace(<span class="string">&#x27;\\&#x27;</span>,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                flieList[filename] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> flieList </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cs</span>():</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> hou.hipFile.basename() == <span class="string">&#x27;untitled.hip&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Please create a project&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fileType=[<span class="string">&#x27;.abc&#x27;</span>,<span class="string">&#x27;.fbx&#x27;</span>,<span class="string">&#x27;.obj&#x27;</span>]</span><br><span class="line">        filePath = os.path.dirname(hou.hipFile.path())    </span><br><span class="line">        fileList= findFile(filePath,fileType)</span><br><span class="line">        </span><br><span class="line">        nodeplane = hou.node(<span class="string">&#x27;/obj&#x27;</span>)</span><br><span class="line">        Word_Xfrom = nodeplane.createNode(<span class="string">&#x27;null&#x27;</span>,<span class="string">&#x27;Word_Xfrom&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        EditNode =nodeplane.createNode(<span class="string">&#x27;geo&#x27;</span>,<span class="string">&#x27;Edit&#x27;</span>)</span><br><span class="line">        EditNode.setColor(hou.Color((<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> details <span class="keyword">in</span> fileList.items():</span><br><span class="line">            <span class="comment">#houdini hip path</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(details[<span class="number">1</span>]) != <span class="number">0</span>:          </span><br><span class="line">                filePath = <span class="string">&#x27;$HIP/&#x27;</span>+details[<span class="number">1</span>]+<span class="string">&#x27;/&#x27;</span>+details[<span class="number">0</span>]        </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                filePath = <span class="string">&#x27;$HIP/&#x27;</span>+details[<span class="number">0</span>]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">in</span> details[<span class="number">0</span>].rsplit(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;cam&#x27;</span> <span class="keyword">in</span> details[<span class="number">0</span>].rsplit(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>][<span class="number">0</span>:<span class="number">3</span>].lower():</span><br><span class="line">                    abcNode = Word_Xfrom.createOutputNode(<span class="string">&#x27;alembicarchive&#x27;</span>,<span class="string">&#x27;Abc_&#x27;</span>+details[<span class="number">0</span>][:-<span class="number">4</span>])</span><br><span class="line">                    abcNode.setParms(&#123;<span class="string">&quot;fileName&quot;</span>:filePath&#125;)</span><br><span class="line">                    abcNode.parm(<span class="string">&#x27;buildHierarchy&#x27;</span>).pressButton()</span><br><span class="line">                    camshape=abcNode.children()[<span class="number">0</span>].children()[<span class="number">0</span>]</span><br><span class="line">                    camshape.setParms(&#123;<span class="string">&#x27;resx&#x27;</span>:<span class="number">1920</span>,<span class="string">&#x27;resy&#x27;</span>:<span class="number">1080</span>&#125;)</span><br><span class="line">                    camshape.setParmExpressions(&#123;<span class="string">&#x27;near&#x27;</span>:<span class="string">&#x27;0.001&#x27;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    abcNode = Word_Xfrom.createOutputNode(<span class="string">&#x27;geo&#x27;</span>,<span class="string">&#x27;Abc_&#x27;</span>+details[<span class="number">0</span>][:-<span class="number">4</span>])</span><br><span class="line">                    importAbcNode=abcNode.createNode(<span class="string">&#x27;alembic&#x27;</span>,<span class="string">&#x27;ABC_&#x27;</span>+details[<span class="number">0</span>][:-<span class="number">4</span>])</span><br><span class="line">                    importAbcNode.setParms(&#123;<span class="string">&#x27;fileName&#x27;</span>:filePath&#125;)</span><br><span class="line">                    </span><br><span class="line">                             </span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;fbx&#x27;</span> <span class="keyword">in</span> details[<span class="number">0</span>].rsplit(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]:</span><br><span class="line">            </span><br><span class="line">                fbxNodes=hou.hipFile.importFBX(filePath) </span><br><span class="line">                fbxNode=<span class="built_in">list</span>(fbxNodes)[<span class="number">0</span>]</span><br><span class="line">                fbxNode.setColor(hou.Color((<span class="number">0.976</span>,<span class="number">0.78</span>,<span class="number">0.263</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;obj&#x27;</span> <span class="keyword">in</span> details[<span class="number">0</span>].rsplit(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]:</span><br><span class="line">                objNode = Word_Xfrom.createOutputNode(<span class="string">&#x27;geo&#x27;</span>,<span class="string">&#x27;Obj_&#x27;</span>+details[<span class="number">0</span>][:-<span class="number">4</span>])</span><br><span class="line">                importObjNode=objNode.createNode(<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;ABC_&#x27;</span>+details[<span class="number">0</span>][:-<span class="number">4</span>])</span><br><span class="line">                importObjNode.setParms(&#123;<span class="string">&#x27;file&#x27;</span>:filePath&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> geoNode <span class="keyword">in</span> Word_Xfrom.outputs():</span><br><span class="line">            geoNode.setColor(hou.Color((<span class="number">0.976</span>,<span class="number">0.78</span>,<span class="number">0.263</span>)))</span><br><span class="line">            <span class="keyword">if</span> geoNode.<span class="built_in">type</span>().name() == <span class="string">&#x27;geo&#x27;</span>:</span><br><span class="line">                OmNode=EditNode.createNode(<span class="string">&#x27;object_merge&#x27;</span>)</span><br><span class="line">                OmNode.setParms(&#123;<span class="string">&#x27;objpath1&#x27;</span>:<span class="built_in">list</span>(geoNode.children())[<span class="number">0</span>].path()&#125;)</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> hou.node(<span class="string">&#x27;/obj&#x27;</span>).children():</span><br><span class="line">            node.setDisplayFlag(<span class="number">0</span>) </span><br><span class="line">                </span><br><span class="line">        hou.node(<span class="string">&#x27;/obj&#x27;</span>).layoutChildren()</span><br><span class="line">        EditNode.layoutChildren()</span><br><span class="line">        hou.setFps(<span class="number">25</span>)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/06/Houdini%20Python(%E4%B8%80)/</url>
    <content><![CDATA[<h1><span id="houdini-python一">Houdini Python(一)</span></h1><p>还在为重复操作而流失的时间而苦恼么？来吧，使用python进行批处理。<br>我写这些的目的呢很简单，逐步复习之前获得的技能点，顺便水一水，嘿嘿。<br>需求导向学习，只有知道了要什么，然后带着需求去学习，才是最快的。</p>
<p>我接触Hpython（就是houdini中的python）是因为项目中的操作很多过于繁琐，而且很多时候想对文件进行规范化是一件很重要，但是又十分苦恼的事情。那时候，我看了很多大佬的分享，发现了，哦，我们可以使用hpython 进行一些处理。比如：快速搭建初始场景，将abc，摄像机之类快速加入houdini文件，对一些目的性的节点进行自动区分，还有hda的控制之类都是由python操作的。</p>
<p>虽然工具架很多还是由houdini脚本语言进行写的，但python同样也可以写。</p>
<p>关于python的基础语法，推荐大家去看一下廖雪峰大神的免费python博客，虽然那个是3.X的python，而houdini 默认的是2.7，但这不妨碍学习。<br>Python教程​<a href="http://www.liaoxuefeng.com/">www.liaoxuefeng.com</a><br>大概看到正则表达式，就可以愉快的使用了，毕竟我们不是程序员，只是为了让自己的工作更愉快，嘿嘿。</p>
<p>或许你就会有一个疑惑python和Hpython 有啥区别呢？</p>
<p>Hpython 就是 python 在houdini里的库 “hou”</p>
<p>关于Hpython 的最快捷学习方法 就是 看官方帮助。<br><a href="http://www.sidefx.com/docs/houdini/hom/index.html%E2%80%8Bwww.sidefx.com">http://www.sidefx.com/docs/houdini/hom/index.html​www.sidefx.com</a><br>为了更加方便，请在对应版本的houdini文档的环境变量中添加以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HOUDINI_EXTERNAL_HELP_BROWSER = 1</span><br></pre></td></tr></table></figure>
<p>当你在houdini环境下按F1时，用默认浏览器打开houdini的帮助，这样就能很快捷的进行查找你想要的，还可以偷懒使用谷歌翻译，嘿嘿嘿。</p>
<p>实践是检验真理的唯一标准。<br>Windows-Python Shell 这个调试框将是最常用的面板，可以快速调试，支持自动补足。</p>
<p><img src="%E5%9B%BE%E7%89%871.png"></p>
<p>从上图可知houdini使用的是2.7.15版本的python 引入了H18.0.348的hou模块。还有一些简单的提示信息<br>所以先来个 hello world吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">geoNode =hou.node(<span class="string">&quot;/obj&quot;</span>).createNode(<span class="string">&quot;geo&quot;</span>,<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line">fontNode = geoNode.createNode(<span class="string">&quot;font&quot;</span>)</span><br><span class="line">fontNode.parm(<span class="string">&quot;text&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后就获得了下图效果。</p>
]]></content>
  </entry>
  <entry>
    <title>Houdini 学习 Engine For Unity-Plugin API</title>
    <url>/2021/07/24/Houdini%20%E5%AD%A6%E4%B9%A0%20Engine%20For%20Unity-Plugin%20API/</url>
    <content><![CDATA[<h1><span id="houdini-学习-engine-for-unity-plugin-api">Houdini 学习 Engine For Unity-Plugin API</span></h1><p><a href="http://www.sidefx.com/docs/unity/pluginapi.html">官方文档</a></p>
<p>HEU分为三部分：</p>
<ul>
<li>Asset layer</li>
<li>Utility layer</li>
<li>HAPI layer</li>
</ul>
<h2><span id="asset-layer">Asset layer</span></h2><p>即资产创建以及参数获取和修改的操作，包含以下几个类：</p>
<ul>
<li>HEU_HoudiniAssetRoot这是Unity中Houdini Engine资产的根组件。它是轻量级的，仅充当层次结构的根并提供用户界面。</li>
<li>HEU_HoudiniAsset这是主要的资产组件，其中包含资产的所有元数据，以及构建，烹饪，查询和修改资产的功能。</li>
<li>HEU_ParameterUtility包含便利功能，用于查询和修改资产上的参数。</li>
</ul>
<p>官方提供了一个相关的实例文档<br>Plugins / HoudiniEngineUnity / Scripts / Examples / HEU_ExampleEvergreenQuery.cs</p>
<h3><span id="文档阅读笔记">文档阅读笔记</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using HoudiniEngineUnity;</span><br><span class="line"></span><br><span class="line">HEU_AssetDatabase.GetAssetFullPath</span><br><span class="line"></span><br><span class="line">//Manages the asset database to store persistent assets such as materials, textures, asset data, etc. Wraps around Unity AssetDatabase. Only available in Editor. Probably not needed at runtime as data probably does not need to persist past session.</span><br><span class="line">//Given relative path to an asset (with Assets/ in the path), this returns the full path to it.</span><br><span class="line"></span><br><span class="line">HEU_SessionBase </span><br><span class="line">//Base class for a Houdini Engine session. Contains functionality to interface with the Houdini Engine for a particular session.</span><br><span class="line"></span><br><span class="line">HEU_SessionManager.GetOrCreateDefaultSession()</span><br><span class="line">//Manages a session for Houdini Engine. Supports all types of sessions.</span><br><span class="line">//获取或者创建有效会话</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEU_HAPIUtility.InstantiateHDA(evergreenFullPath, Vector3.zero, session, true);</span><br><span class="line">//houdini引擎的工作，如创建hda，cook等。</span><br><span class="line">//Load and instantiate an HDA asset in Unity and Houdini, for the asset located at given path.创建指定路径的hda</span><br><span class="line"></span><br><span class="line">public static GameObject InstantiateHDA(string filePath, Vector3 initialPosition, HEU_SessionBase session, bool bBuildAsync)</span><br><span class="line">FilePath文件路径	 initialPosition 初始位置  获取会话 是否重载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEU_EditorUtility.SelectObject(rootGO);</span><br><span class="line">//Wrapper around Unity Editor functions.Unity编辑器函数的包装。</span><br><span class="line">//选择物体 返回数组</span><br><span class="line"></span><br><span class="line">HEU_HoudiniAsset houdiniAsset = QueryHoudiniAsset(rootGO);</span><br><span class="line">//HEU_HoudiniAsset 资产组件</span><br><span class="line">//QueryHoudiniAsset Shows how to get the HEU_HoudiniAsset component from a HDA root gameobject.</span><br><span class="line"></span><br><span class="line">// Make sure the HDA is cooked before querying or changing its properties.</span><br><span class="line">CookAsset(houdiniAsset);</span><br><span class="line"></span><br><span class="line">// Example of querying and changing parms.</span><br><span class="line">ChangeParmsAndCook(houdiniAsset);</span><br><span class="line"></span><br><span class="line">// This will query objects, geometry, parts, and attributes in the asset.</span><br><span class="line">QueryObjects(houdiniAsset);</span><br><span class="line"></span><br><span class="line">// This will query the gravity attribute.</span><br><span class="line">QueryAttribute(houdiniAsset, &quot;EvergreenGenerator&quot;, &quot;EvergreenGenerator1&quot;, 0, &quot;Cd&quot;);</span><br><span class="line"></span><br><span class="line">HEU_HoudiniAssetRoot</span><br><span class="line">//The root object of a Houdini Engine asset. Used for organizing hierarchy, and more importantly displaying custom UI.</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/06/Houdini%20HDA%E5%B0%81%E8%A3%85%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>目的：避免时间浪费，以及混乱。</p>
<p>1.官方的建议<br>有专门的帮助进行解释<br>Digital asset versions and namespaces<br>assets/namespaces.html</p>
<p>[namespace::]node_name[::version]<br>命名空间-节点名称-版本</p>
<p>2.我查看了五行精灵的文章<br><a href="https://zhuanlan.zhihu.com/p/98099124">https://zhuanlan.zhihu.com/p/98099124</a><br>也讨论了 如何规范命名</p>
<p>3.我个人所采用的规则</p>
<p>主要是name 很重要 ，label 倒是很好 修改<br>A B C 格式<br>A 大范围<br>B 具体操作<br>C 资产名称</p>
<p>规则<br>1.name 不能是大写开头</p>
]]></content>
  </entry>
  <entry>
    <title>Houdini 学习 Digital Assets</title>
    <url>/2021/07/24/Houdini%20%E5%AD%A6%E4%B9%A0%20Digital%20Assets/</url>
    <content><![CDATA[<h1><span id="houdini-学习-digital-assets">Houdini 学习 Digital Assets</span></h1><p>Digital assets let you create reusable nodes and tools from existing networks.</p>
<p>可以创建复用的节点和工具。 </p>
<p>存储格式：.hda(.otl是旧版本)</p>
<h2><span id="创建的方法">创建的方法</span></h2><ol>
<li>Subnetwork 右键  Create digital asset    </li>
<li>资产命名<ul>
<li>Operator Name 命名空间的名字</li>
<li>Operator Label tab管理器的名称</li>
<li>Save to library 存储位置，建议制作自己的资产库，便于个人管理。</li>
</ul>
</li>
<li>编辑面板属性，脚本等细节</li>
<li>4.完成创建</li>
</ol>
<h2><span id="面板参数介绍">面板参数介绍</span></h2><h3><span id="operator-type-window-资产的编辑窗口">Operator Type window 资产的编辑窗口</span></h3><p>此窗口可以编辑资产除子节点之外的所有数据（参数面板，label and icon，嵌入文件，自定义脚本）</p>
<p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00.png" alt="资产的编辑窗口"></p>
<ul>
<li>Operator Type 就是上文提到的Operator Name，此时的状态是不可更改的。</li>
<li>Save to Library 存储位置。</li>
<li>Install Library to 安装到哪，统一适用packages管理，我觉得更好些。</li>
<li>Switch to Definition 切换定义</li>
</ul>
<h4><span id="basic-tab基础标签">Basic tab基础标签</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="Basic"></p>
<ul>
<li>Label 标签名 显示在tab</li>
<li>Icon 图标 建议使用houdini内置的图标，其他处理方式请查看帮助。</li>
<li>Version 版本 版本号提醒</li>
<li>Minimum Inputs 最小输入端口数量</li>
<li>Maximum Inputs 最大输入端口数量</li>
<li>Maximum Outputs 最大输出端口数量</li>
</ul>
<h4><span id="parameters-tab-参数标签">Parameters tab 参数标签</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.png" alt="Parameters"></p>
<ul>
<li><p>创建参数</p>
<ul>
<li>将子节点属性直接拖入Existing Parameters</li>
<li>从create Parameters 中拖入Existing Parameters，然后进行和子节点的关联</li>
</ul>
</li>
<li><p>create Parameters 创建属性</p>
</li>
<li><p>Existing Parameters 已有的参数</p>
</li>
<li><p>Parameter Description参数说明</p>
<ul>
<li>Name 是 参数的名称，当脚本或者其他方式调用时使用此名称， Label 是面板上显示的名称。</li>
<li>Callback Script 回调脚本 当参数有所变化就会触发，经常用于button</li>
<li>Tags 标签 可以存储一些参数属性，例如opengl实时显示材质之类。</li>
</ul>
</li>
<li><p>Channels中存储属性的默认值，但是ramp类型的不在这里设置 它的属性参数中有一项叫 get from  Parameter</p>
</li>
</ul>
<h4><span id="node-tabs-节点面板">Node Tabs 节点面板</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03.png" alt="Node"></p>
<p>Enitble Nodes 是目前我最常用的，为了能编辑内部节点</p>
<h4><span id="inputoutput-tab">Input/Output tab</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04.png" alt="Input/Output"></p>
<p>输入输出 可以进行一些输入输出的信息描述</p>
<h4><span id="help-tabs">Help Tabs</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05.png" alt="Help"></p>
<p>可以使用wiki 进行节点帮助的创建，我认为在大规模使用的情况下 是很有用的。</p>
<h4><span id="code-tabs">Code Tabs</span></h4><p>适用于其他类型的资产，现在不讨论。</p>
<h4><span id="scripts-tab">Scripts tab</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06.png" alt="Scripts"></p>
<p>触发脚本的标签<br>当有一些自定义的触发操作，批处理之类就可以使用该标签进行创建。</p>
<h4><span id="interactive-tab">Interactive tab</span></h4><p><img src="Houdini_Digital_Assets_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07.png" alt="Interactive"></p>
<p>交互标签 用于hda 和用户交互的操作<br>例如 hda的菜单位置，界面交互，热键之类</p>
<p>菜单设置    在    shelf Tools-Context- NetWork Plane - TAB Submenu Path</p>
<h4><span id="iextra-files-tab">IExtra Files tab</span></h4><p>内嵌文件标签</p>
<p>用于将一些纹理 bgeo文件嵌入hda 中,嵌入后使用opdef 在资产中进行调用。</p>
<h4><span id="save-tab">Save Tab</span></h4><p>保存 目前还未涉及到，感觉默认就行。</p>
<h2><span id="其他">其他</span></h2><ol>
<li>关于私有资产保护问题<ul>
<li>可以创建黑盒，在你不想公开的情况下。</li>
<li>方法：<ol>
<li>选择需要创建黑盒的hda</li>
<li>Assets - Create Black Boxed Asset from Selection </li>
<li>选择存储位置，完成创建。    </li>
</ol>
</li>
</ul>
</li>
<li>当想修改官方的资产但不想影响资产的默认的问题<ol>
<li>打开资产管理面板，右键资产 show in Asset Manager </li>
<li>右键点击资产中的hda 选择duplicate 进行修改创建。</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Houdini 学习 Engine For Unity</title>
    <url>/2021/07/24/Houdini%20%E5%AD%A6%E4%B9%A0%20Engine%20For%20Unity/</url>
    <content><![CDATA[<h1><span id="houdini-学习-engine-for-unity">Houdini 学习 Engine For Unity</span></h1><h2><span id="houdini-资产ui面板">Houdini 资产UI面板</span></h2><p><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D0.png" alt="Houdini 资产UI面板"></p>
<ul>
<li>Rebuild Assest 重建资产。强制重建资产，并保留最新参数。</li>
<li>Recook Assesrt 重新cook资产。 重新输出资产</li>
<li>Keep Only Output 仅保持输出。删除资产，保留输出的结果。</li>
<li>Duplicate Assest 复制资产</li>
<li>Reset Asset 重置资产。将参数重置为默认值。</li>
<li>Bake GameObject 烘焙GameObject</li>
<li>Bake Prefab 烘焙预制体。</li>
<li>Bake Update 烘焙更新 更新之前烘焙的GameObject和预制体。如果计划烘焙更新，请不要修改物体名称。<h2><span id="asset-options-资产选项">Asset Options 资产选项</span></h2><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D1.png" alt="Asset Options 资产选项"></li>
</ul>
<ol>
<li>Auto-Cook On Parameter Change 当参数变化时自动cook</li>
<li>Push Tranform To Houdini 变换传递至houdini</li>
<li>Transform Change Triggers Cooks 位移的变化触发cook</li>
<li>Cooking Triggers Downsteam Cooks 烘焙时触发其他关联的资产进行烘焙</li>
<li>Generate UVs 创建UV</li>
<li>Generate Tangents 创建切线</li>
<li>Generate Normals 创建法线</li>
<li>Generate Mesh Using Points 使用点创建mesh，但所有的属性都在点上而非顶点上。</li>
<li>Use LOD Groups 使用LOD组</li>
<li>Ignore NonDisplay Nodes 忽略不可显示的节点</li>
<li>Split Geos By Group 通过组分离geo </li>
<li>Save HDA Preset 保存hda预设</li>
<li>Load HDA Preset 导入 hda预设</li>
<li>Reset Material Overrides 重置材质替代<h2><span id="导入节点">导入节点</span></h2><img src="HoudiniEngineForUnity%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D2.png" alt="导入节点"></li>
<li>Input Type 输入类型 Unity_Mesh unity的gameObject或者预制体  hda houdini资产</li>
<li>Keep World Transform 保持世界空间位移</li>
<li>Pack Geometry Before Mergi 在合并前物体打包。仅适用于unity物体</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/06/Houdini%20%E5%BC%95%E6%93%8E%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1><span id="houdini-引擎面板功能介绍">Houdini 引擎面板功能介绍</span></h1><p>Houdini资产UI面板</p>
<p><img src="%E5%9B%BE%E7%89%871.png"></p>
<p>Rebuild Assest 重建资产。强制重建资产，并保留最新参数。<br>Recook Assesrt 重新cook资产。 重新输出资产<br>Keep Only Output 仅保持输出。删除资产，保留输出的结果。<br>Duplicate Assest 复制资产<br>Reset Asset 重置资产。将参数重置为默认值。</p>
<p>Bake GameObject 烘焙GameObject<br>Bake Prefab 烘焙预制体。<br>Bake Update 烘焙更新 更新之前烘焙的GameObject和预制体。如果计划烘焙更新，请不要修改物体名称。</p>
<p>Asset Options 资产选项</p>
<p><img src="%E5%9B%BE%E7%89%872.png"></p>
<p>1.Auto-Cook On Parameter Change 当参数变化时自动cook<br>2.Push Tranform To Houdini 变换传递至houdini<br>3.Transform Change Triggers Cooks 位移的变化触发cook<br>4.Cooking Triggers Downsteam Cooks 烘焙时触发其他关联的资产进行烘焙<br>5.Generate UVs 创建UV<br>6.Generate Tangents 创建切线<br>7.Generate Normals 创建法线<br>8.Generate Mesh Using Points 使用点创建mesh，但所有的属性都在点上而非顶点上。<br>9.Use LOD Groups 使用LOD组<br>10.Ignore NonDisplay Nodes 忽略不可显示的节点<br>11.Split Geos By Group 通过组分离geo<br>12.Save HDA Preset 保存hda预设<br>13.Load HDA Preset 导入 hda预设<br>14.Reset Material Overrides 重置材质替代</p>
<p><img src="%E5%9B%BE%E7%89%873.png"></p>
<p>导入节点<br>1.Input Type 输入类型 Unity_Mesh unity的gameObject或者预制体  hda houdini资产<br>2.Keep World Transform 保持世界空间位移<br>3.Pack Geometry Before Mergi 在合并前物体打包。仅适用于unity物体</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/06/Houdini%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1><span id="houdini-帮助文档使用指南">Houdini 帮助文档使用指南</span></h1><p>越来越多的小伙伴知道了houdini这款成年人乐高软件，纷纷下载，然后很多人被houdini不一样的操作界面和逻辑给虎住了。很多人纷纷疑惑，该看什么教程啊？怎么入门啊？怎么系统化学习啊？这个教程那个教程好不好啊？</p>
<p>就我个人观点来说，一个软件想获得更多的用户群体，首先他们官方肯定会写一份帮助文档来帮助用户快速的学习自家的软件，还有houdini官方会有相关功能的大师班或者一些其他免费的教程。</p>
<p>Tutorials | SideFX​<a href="http://www.sidefx.com/">www.sidefx.com</a></p>
<p>关于官方教程可以自行了解上面是链接。</p>
<p>下面我来说官方的帮助的一些我的个人使用心得吧，或许其实大家都知道。</p>
<p>首先如何打开帮助</p>
<p>方法一：官方在线帮助</p>
<p><a href="http://www.sidefx.com/docs/houdini/%E2%80%8Bwww.sidefx.com">http://www.sidefx.com/docs/houdini/​www.sidefx.com</a></p>
<p>方法二：在打开houdini的情况下，本地帮助F1开启</p>
<p>这里我强烈推荐修改环境变量，使用默认浏览器开启帮助</p>
<p>HOUDINI_EXTERNAL_HELP_BROWSER = 1</p>
<p>方法三：在不打开houdini的情况下直接开启本地帮助文档</p>
<p>关于如何使用帮助文档的个人经验：</p>
<ol>
<li><p>萌新请直接看基础模块</p>
<p> <img src="%E5%9B%BE%E7%89%871.png"></p>
<p> 快速的了解基础的操作逻辑。</p>
</li>
<li><p>很多人说新版本改了，不知道怎么用，如果你开过文档，就知道有个what’s new in houdiniXX</p>
<p> <img src="%E5%9B%BE%E7%89%872.png"></p>
<p> 点开就会有当前的版本相较于上个版本的新功能功能介绍，并且包含了之前的版本的what new </p>
</li>
<li><p>请看官方的目录结构是非常的明显的</p>
<p> <img src="%E5%9B%BE%E7%89%872.png"></p>
<p> 获得开始，一切的开端</p>
<p> <img src="%E5%9B%BE%E7%89%873.png"></p>
<p> 简单的使用介绍</p>
<p> <img src="%E5%9B%BE%E7%89%874.png"></p>
<p> 动力学，houdini最强的模块的介绍</p>
<p> <img src="%E5%9B%BE%E7%89%875.png"></p>
<p> 关于houdini节点的功能介绍</p>
<p> <img src="%E5%9B%BE%E7%89%876.png"></p>
<p> 灯光，渲染和合成的介绍</p>
<p> <img src="%E5%9B%BE%E7%89%877.png"></p>
<p> 参考，这里可以找到脚本相关的介绍</p>
</li>
<li><p>可能太多了，看不过来怎么办</p>
<p> 我的建议是萌新了解一下第一个模块和第二个模块，剩下的在实践的过程中遇到了问题再依据你的需求进行单独的查阅。<br> 每一个地方都会有一个问号的标签，点击就可以直接找到对应的帮助，而vex相关的你可以直接光标浮在对应的函数上按F1 进行查看。</p>
<p> <img src="%E5%9B%BE%E7%89%878.png"></p>
<p> 并且还附带一句话攻略</p>
</li>
<li><p>一些脚本在节点上使用时的快速帮助查询方法<br> 你写一半会自动弹出一个黑底的帮助提示</p>
<p> <img src="%E5%9B%BE%E7%89%879.png"></p>
<p> 如图，会用用法，含义，例子还有对应python的提示</p>
</li>
<li><p>帮助文档的每个帮助页面的末尾也是很有用的，会提示你相关的内容，这样就可以获得相关的应有办法</p>
<p> <img src="%E5%9B%BE%E7%89%8710.png"></p>
</li>
<li><p>犹豫不决请，请引入官方例子</p>
<p> <img src="%E5%9B%BE%E7%89%8711.png"></p>
<p> 当你了解的你想要的，但又不明白怎么应有啊，有什么骚操作啊，这时候建议看看末尾有没有EXAMPLES，当有你就可以load到文件里进行查看。</p>
<p> 如图会有简单的例子说明<br> houdini18版本新增，新的例子调用功能，在节点上右键，同样会有EXAMPLES选项</p>
<p> <img src="%E5%9B%BE%E7%89%8712.png"></p>
<p> 有一些节点会有，还有些节点可以支持自己创建例子</p>
<p> <img src="%E5%9B%BE%E7%89%8713.png"></p>
</li>
<li><p>未完待续。。（想起来再写）</p>
</li>
</ol>
<p>如有错误或者建议请指出，谢谢啦！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/18/MAXScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="maxscript学习笔记">MAXScript学习笔记</span></h1><h2><span id="简介">简介</span></h2><p>MAXscript是3ds Max内置脚本语言，Max2.0及以后加入的功能。也能使用在与3ds Max相关的产品中如Autodesk VIZ,character studio,Plasma和GMax;脚本可使用于建模，动画，材质，渲染等等。它是专门为3D Studio Max设计的。</p>
<h2><span id="环境配置">环境配置</span></h2><h3><span id="3dsmax内部的环境">3dsMax内部的环境</span></h3><ul>
<li><p>MAXscript Listener 设置</p>
<ul>
<li><p>Scripting - MAXscript Listener</p>
<p>  <img src="MAXscriptListenerSet.png" alt="MAXscriptListenerSet.png"></p>
</li>
<li><p>设置后，可以返回操作的语法</p>
</li>
</ul>
</li>
</ul>
<h3><span id="vscode环境配置">VSCode环境配置</span></h3><ul>
<li>将“initialize_COM_server.ms”3dsMax的开始目录下复制到startup<ul>
<li>通过 %localappdata%\autodesk\3dsmax ，在资料管理中找到3dsMAX的安装目录</li>
<li>根据版本选择找到script\startup</li>
<li>将“initialize_COM_server.ms”复制到此处</li>
</ul>
</li>
<li>将 MXSPyCOM.exe 复制到任意位置</li>
<li>建立工程区<ul>
<li>添加json文件</li>
<li>将以下脚本粘贴  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;Execute in Max&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;process&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;C:/MXSPyCOM.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [&quot;-f&quot;, &quot;$&#123;file&#125;&quot;],</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">            &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">            &quot;panel&quot;: &quot;new&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>调整vs的快捷键设置  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;key&quot;: &quot;ctrl+e&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;command&quot;: &quot;workbench.action.tasks.runTask&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;args&quot;: &quot;Execute in Max&quot;       </span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &quot;key&quot;: &quot;shift+e&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;command&quot;: &quot;workbench.action.quickOpen&quot;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &quot;key&quot;: &quot;shift+e&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;command&quot;: &quot;workbench.action.quickOpenNavigateNextInFilePicker&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;when&quot;: &quot;inFilesPicker &amp;&amp; inQuickOpen&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">] </span><br></pre></td></tr></table></figure></li>
<li>重启3dsMAX，在vscode编写脚本时，使用快捷键“Ctrl+E”<h2><span id="实例">实例</span></h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 导出资源的例子</span><br><span class="line">rollout AnimExporter &quot;动画资产导出&quot;</span><br><span class="line">(</span><br><span class="line">    group &quot;Export Setting&quot; (</span><br><span class="line">        </span><br><span class="line">        edittext ExportPath &quot;路径:&quot; </span><br><span class="line"></span><br><span class="line">        button GetCurrentPath &quot;获取路径&quot; width: 200 height:30 </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    )</span><br><span class="line">    button Export &quot;导出&quot; width: 200 height:30 </span><br><span class="line">    button ShowIn &quot;打开目录&quot; width: 200 height:30 </span><br><span class="line">    -- Get Folder Path</span><br><span class="line">    fn GetFolderPath =(</span><br><span class="line">        folderPath = maxFilePath</span><br><span class="line">        return folderPath</span><br><span class="line">    )</span><br><span class="line">    -- Fbx Export</span><br><span class="line">    fn ExportFbx go assetPath =(</span><br><span class="line">        path = assetPath+go.name</span><br><span class="line">        exportFile path #noPrompt selectedOnly:true using:FBXEXP</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    -- Get Head Dummy</span><br><span class="line">    fn GetHeadDummy gos =(</span><br><span class="line">        result</span><br><span class="line">        for i in gos do</span><br><span class="line">            if Classof i == Dummy &amp;&amp; i.children.count == 0  &amp;&amp; i.parent==null do </span><br><span class="line">                result =i</span><br><span class="line">        return i</span><br><span class="line">    )</span><br><span class="line">    -- Get Polys </span><br><span class="line">    fn GetPolys gos =(</span><br><span class="line">        result = #()</span><br><span class="line">        for i in gos do</span><br><span class="line">            if Classof i == PolyMeshObject do </span><br><span class="line">                append result i</span><br><span class="line">        return result</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fn GetHairPolys PolyMeshs =(</span><br><span class="line">        result</span><br><span class="line">        for i in PolyMeshs do (</span><br><span class="line">            polyMeshName = i.name</span><br><span class="line">            if matchpattern i.name pattern: &quot;*Hair*&quot; == true do (</span><br><span class="line">                result = i</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        return result</span><br><span class="line">    )</span><br><span class="line">    -- 获得所有子集 http://tk.v5cg.com/help/250.html</span><br><span class="line">    fn RecurseChildren RecurseCollector currNode=</span><br><span class="line">    (</span><br><span class="line">        append RecurseCollector currNode</span><br><span class="line">        local childNodes = currNode.children</span><br><span class="line">        if(childNodes.count !=0)then for c in childNodes do</span><br><span class="line">        (</span><br><span class="line">            RecurseChildren RecurseCollector c</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fn GetChildrens currNode=</span><br><span class="line">    (</span><br><span class="line">        -- 清空集合</span><br><span class="line">        RecurseCollector = #()</span><br><span class="line">        -- 开始递归</span><br><span class="line">        RecurseChildren RecurseCollector currNode</span><br><span class="line">        -- 返回  </span><br><span class="line">        return RecurseCollector</span><br><span class="line">    )</span><br><span class="line">    -- 获得skin列表</span><br><span class="line">    fn GetBipsOnSkin skin =(</span><br><span class="line">        result = #()</span><br><span class="line">        num = skinOps.GetNumberBones skin</span><br><span class="line">        for i=1 to num do</span><br><span class="line">            boneName = skinOps.GetBoneName skin i 0</span><br><span class="line">            append result boneName</span><br><span class="line">        return result</span><br><span class="line">    )</span><br><span class="line">    -- 按键</span><br><span class="line">    on GetCurrentPath pressed do</span><br><span class="line">    (</span><br><span class="line">        path = GetFolderPath()</span><br><span class="line">        if(path.count==0)</span><br><span class="line">        then(</span><br><span class="line">            messageBox &quot;错误！&quot;</span><br><span class="line">        )</span><br><span class="line">        else(</span><br><span class="line">            ExportPath.text = GetFolderPath()</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    on Export pressed do</span><br><span class="line">    (</span><br><span class="line">        aa = $</span><br><span class="line">        ExportFbx aa ExportPath.text</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    on ShowIn pressed do</span><br><span class="line">    (</span><br><span class="line"></span><br><span class="line">        a=  $.modifiers[#Skin]</span><br><span class="line">        cc = GetBipsOnSkin a </span><br><span class="line">        for i in cc do</span><br><span class="line">            print i</span><br><span class="line">        </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 获取当前文件的地址</span><br><span class="line">-- 获取当前文件中的物体列表</span><br><span class="line">-- 列表</span><br><span class="line">-- Editable_Poly</span><br><span class="line">-- Dummy</span><br><span class="line"></span><br><span class="line">-- 获得层级的全部子级</span><br><span class="line">-- 创建组合好的选择列表</span><br><span class="line">-- 按mesh名创建FBX</span><br><span class="line">-- 分别导出到当前文件地址下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createdialog AnimExporter 220 200</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2><ol>
<li><p><a href="https://space.bilibili.com/7398208/channel/detail?cid=84063&ctype=0">霜狼_may-Maxscrip教程</a></p>
</li>
<li><p><a href>3ds MAXscript 脚本语言完全学习手册</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/24/MarkDown%20%E5%AD%A6%E4%B9%A0%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1><span id="hello-world">Hello World!</span></h1><h2><span id="hello-world">Hello World!</span></h2><h3><span id="hello-world">Hello World!</span></h3><h4><span id="hello-world">Hello World!</span></h4><h5><span id="hello-world">Hello World!</span></h5><h6><span id="hello-world">Hello World!</span></h6><p>####### Hello World! </p>
<h1><span id="我展示的是一级标题">我展示的是一级标题</span></h1><h2><span id="我展示的是二级标题">我展示的是二级标题</span></h2><h1><span id="一级标题">一级标题</span></h1><h2><span id="二级标题">二级标题</span></h2><h3><span id="三级标题">三级标题</span></h3><h4><span id="四级标题">四级标题</span></h4><h5><span id="五级标题">五级标题</span></h5><h6><span id="六级标题">六级标题</span></h6><p>段落测试</p>
<p>段落测试</p>
<p><em>斜体文本</em></p>
<p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong>粗体文本</strong></p>
<p><em><strong>粗斜体文本</strong></em></p>
<p><em><strong>粗斜体文本</strong></em></p>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>RUNOOB.COM<br>GOOGLE.COM<br><del>BAIDU.COM</del></p>
<p><u>带下划线文本</u></p>
<p>创建脚注格式类似这样 [^RUNOOB]。</p>
<p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p>
<ul>
<li><p>第一项</p>
<ul>
<li>大的</li>
</ul>
</li>
<li><p>第二项</p>
</li>
<li><p>第三项</p>
</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<blockquote>
<p>区块引用</p>
</blockquote>
<pre><code>测试
</code></pre>
<blockquote>
<p>菜鸟教程</p>
</blockquote>
<p>测试</p>
<blockquote>
<p>学的不仅是技术更是梦想</p>
</blockquote>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<ul>
<li><p>第一项</p>
<blockquote>
<p>菜鸟教程</p>
</blockquote>
<blockquote>
<p>学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li><p>第二项</p>
</li>
</ul>
<p><code>printf()</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>C#
</code></pre>
<p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p>
<p><a href="https://www.runoob.com/">https://www.runoob.com</a></p>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a></p>
<p>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a></p>
<p>然后在文档的结尾为变量赋值（网址）</p>
<p>  <img src="http://static.runoob.com/images/runoob-logo.png" alt="alt 属性文本"><br>  <img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.</p>
<p>然后在文档的结尾为变量赋值（网址）</p>
<img src="http://static.runoob.com/images/runoob-logo.png" width="50%">



<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<p><strong>文本加粗</strong> </p>
<p>** 正常显示星号 **</p>
<p>\   反斜线<br>`   反引号</p>
<ul>
<li>  星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<h1><span id="井字号">井字号</span></h1></li>
</ul>
<ul>
<li>  加号</li>
</ul>
<ul>
<li>  减号<br>.   英文句点<br>!   感叹号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Maya 插件开发学习</title>
    <url>/2021/07/24/Maya%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1><span id="maya-插件开发学习">Maya 插件开发学习</span></h1><ul>
<li>环境配置<ul>
<li>vs code</li>
<li>maya 脚本编辑器</li>
</ul>
</li>
<li>语言分类<ul>
<li>mel</li>
<li>python</li>
<li>QT</li>
</ul>
</li>
</ul>
<h2><span id="环境配置">环境配置</span></h2><h3><span id="maya-脚本编辑器配置">maya 脚本编辑器配置</span></h3><p>如图所示，对脚本编辑器进行配置</p>
<p><img src="Maya_Editor_Set.png" alt="d"></p>
<h3><span id="vs-code-环境配置">vs code 环境配置</span></h3><p>相关参考链接：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Cz4y1R7MC?from=search&seid=14150298653133706761">Python开发Maya脚本插件 开发环境详细配置</a></li>
</ul>
<h2><span id="语言分类">语言分类</span></h2><h3><span id="mel">mel</span></h3><h3><span id="python">python</span></h3><p>  maya.cmds——这是一个把MEL命令用python包装（ wrappers）的库，可以用于替代MEL命令，因为绝大多数的MEL命令都能查找得到一一对应的maya.cmds命令。只适合面向过程编程。</p>
<p>  pymel.core——该pymel库将许多最常用的MEL命令和API的方法重组到类的层次结构中，这样的设计让你的编程更简单易懂，更具有pythonic化，因为它是具有真正意义上的面向对象特性。由于该pymel库是第三方开发的，Autodesk公司并不提供技术上的支持帮助。</p>
<p>  maya.OpenMaya——这是Maya C++ API的Python包装（ wrappers）的库，称之为Python API 1.0， 适合开发插件和需要MEL未公开的功能的其他任务。</p>
<p>  maya.api.OpenMaya——这是Maya C++ API的Python包装（ wrappers）的库，称之为Python API 2.0。</p>
<h3><span id="qt">QT</span></h3><p>为了通用性，GUI选择QT。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/25/Unity%20C#%20API%20%E5%AD%A6%E4%B9%A0%20ImageConversion/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-10-25 11:47:26
 * @LastEditTime: 2021-10-25 11:58:44
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\编写中\编写 20211025\Unity C# API 学习 ImageConversion\Unity C# API 学习 ImageConversion.md
-->
<h1><span id="unity-c-api-学习-imageconversion">Unity C# API 学习 ImageConversion</span></h1><h2><span id="简介">简介</span></h2><p>ImageConversion 提供的方法是将图像数据从 PNG、EXR、TGA 和 JPEG 格式转换或转换为 PNG、EXR、TGA 和 JPEG 格式。</p>
<h2><span id="方法">方法</span></h2><ul>
<li>EncodeArrayToEXR    Encodes this array into the EXR format.</li>
<li>EncodeArrayToJPG    Encodes this array into JPG format.</li>
<li>EncodeArrayToPNG    Encodes this array into PNG format.</li>
<li>EncodeArrayToTGA    Encodes this array into TGA format.</li>
<li>EncodeNativeArrayToEXR    Encodes this native array into the EXR format.</li>
<li>EncodeNativeArrayToJPG    Encodes this native array into JPG format.</li>
<li>EncodeNativeArrayToPNG    Encodes this native array into PNG format.</li>
<li>EncodeNativeArrayToTGA    Encodes this native array into TGA format.</li>
<li>EncodeToEXR    Encodes this texture into the EXR format.</li>
<li>EncodeToJPG    Encodes this texture into JPG format.</li>
<li>EncodeToPNG    Encodes this texture into PNG format.</li>
<li>EncodeToTGA    Encodes the specified texture in TGA format.</li>
<li>LoadImage    Loads PNG/JPG (or supported format) image byte array into a texture.</li>
</ul>
<h2><span id="图像格式说明">图像格式说明</span></h2><ul>
<li>EXR<ul>
<li>数据格式<ul>
<li>16-bit floating-point ( half)</li>
<li>32-bit floating-point</li>
<li>32-bit unsigned integer</li>
</ul>
</li>
</ul>
</li>
<li>JPG</li>
<li>PNG</li>
<li>TGA</li>
</ul>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://docs.unity3d.com/ScriptReference/ImageConversion.html">ImageConversion - Unity Documentation</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/OpenEXR">OpenEXR - Wikipedia</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/JPEG">JPEG - Wikipedia</a></p>
<p>[4] <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">Portable Network Graphics - Wikipedia</a></p>
<p>[5] <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision TGA - Wikipedia</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/14/Shadertoy%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1><span id="shadertoy-使用总结">Shadertoy 使用总结</span></h1><h2><span id="简介">简介</span></h2><p><a href="https://www.shadertoy.com/">Shadertoy.com</a>是一个跨浏览器的在线社区和工具，用于通过WebGL创建和共享着色器，用于在Web 浏览器中学习和教授3D 计算机图形。</p>
<h2><span id="用法">用法</span></h2><ul>
<li><p>点击新建，进入<a href="https://www.shadertoy.com/new">https://www.shadertoy.com/new</a></p>
</li>
<li><p>编写,简单例子如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// input: pixel coordinates</span></span><br><span class="line">    <span class="type">vec2</span> p = (-iResolution.xy + <span class="number">2.0</span>*fragCoord)/iResolution.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// angle of each pixel to the center of the screen</span></span><br><span class="line">    <span class="type">float</span> a = <span class="built_in">atan</span>(p.y,p.x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// modified distance metric</span></span><br><span class="line">    <span class="type">float</span> r = <span class="built_in">pow</span>( <span class="built_in">pow</span>(p.x*p.x,<span class="number">4.0</span>) + <span class="built_in">pow</span>(p.y*p.y,<span class="number">4.0</span>), <span class="number">1.0</span>/<span class="number">8.0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// index texture by (animated inverse) radius and angle</span></span><br><span class="line">    <span class="type">vec2</span> uv = <span class="type">vec2</span>( <span class="number">1.0</span>/r + <span class="number">0.2</span>*iTime, a );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern: cosines</span></span><br><span class="line">    <span class="type">float</span> f = <span class="built_in">cos</span>(<span class="number">12.0</span>*uv.x)*<span class="built_in">cos</span>(<span class="number">6.0</span>*uv.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color fetch: palette</span></span><br><span class="line">    <span class="type">vec3</span> col = <span class="number">0.5</span> + <span class="number">0.5</span>*<span class="built_in">sin</span>( <span class="number">3.1416</span>*f + <span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">0.5</span>,<span class="number">1.0</span>) );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lighting: darken at the center    </span></span><br><span class="line">    col = col*r;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output: pixel color</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>( col, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2><span id="细节介绍">细节介绍</span></h2><ul>
<li><p>shadertoy使用GLSL</p>
</li>
<li><p>如何将 shadertoy的代码应用到Unity中？</p>
<ul>
<li>参考资料： <a href="https://zhuanlan.zhihu.com/p/269747994">ShaderToy转换成ShaderLab(Unity)</a></li>
</ul>
</li>
<li><p>相关的学习资料</p>
<ul>
<li><a href="https://blog.csdn.net/candycat1992/article/details/44039077">【ShaderToy】开篇-冯乐乐</a></li>
<li><a href="https://thebookofshaders.com/">The Book of Shaders</a></li>
</ul>
</li>
</ul>
<h2><span id="总结">总结</span></h2><p>Shadertoy 是一个很棒的学习别人shader的网站！！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/03/RenderDoc%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1><span id="renderdoc-学习">RenderDoc 学习</span></h1><h2><span id="简介">简介</span></h2><p>RenderDoc是一种图形调试器，目前可用于 Windows、Linux、Android、Stadia 和 Nintendo Switch TM 上的 Vulkan、D3D11、D3D12、OpenGL 和 OpenGL ES 开发。</p>
<p><a href="https://renderdoc.org/docs/getting_started/index.html">Renderdoc官方文档</a></p>
<h2><span id="目的">目的</span></h2><ul>
<li><p>优化GPU</p>
</li>
<li><p>逆向游戏</p>
</li>
<li><p>调试Shader</p>
</li>
</ul>
<h2><span id="下载地址">下载地址</span></h2><p><a href="https://renderdoc.org/">RenderDoc</a></p>
<h2><span id="安装使用说明">安装使用说明</span></h2><ul>
<li><p>点击下载好的RenderDoc_版本号.msi，根据需求进行安装设置。</p>
</li>
<li><p>Unity加载设置，点击视窗右上角的设置按钮，然后点击”Load RenderDoc”,如下图所示：</p>
<p>  <img src="LoadRenderDoc.gif" alt="LoadRenderDoc.gif"></p>
</li>
<li><p>点击加载出来UI按钮进行抓帧使用，如上图所示：</p>
</li>
</ul>
<h2><span id="相关参考资料">相关参考资料</span></h2><ul>
<li><a href="RenderDoc%E4%BD%BF%E7%94%A8.pdf">RenderDoc使用</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/354097312">Renderdoc使用说明文档与游戏检测工具简要总结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/404576672">Renderdoc快速入门</a></li>
</ul>
<h2><span id="使用说明">使用说明</span></h2><p>注意：由于目前本人主要是开发PC游戏，所以手机端的相关使用暂时跳过（2021年20月3日）</p>
<h3><span id="电脑端截帧使用方法">电脑端截帧使用方法</span></h3><p><img src="getFrame.png" alt="getFrame.png"></p>
<ol>
<li><p>在引擎中点击UI，跳出RenderDoc主界面，点击上图按钮(Capture Frame(s) Immediately))进行截帧，截取到的帧会保存在“Captures collected”。</p>
</li>
<li><p>双击打开对应的文件，进行相关的渲染分析。</p>
</li>
</ol>
<h3><span id="窗口介绍">窗口介绍</span></h3><ul>
<li><p><strong>Event Browser</strong></p>
<p>  <img src="EventBrowser.png" alt="EventBrowser.png"></p>
<p>  Event Browser是单步执行框架并浏览其中发生的事件的主要方法。第一列EID(Event ID)按时间顺序指示这是帧中的哪个事件或API调用。</p>
</li>
<li><p><strong>TimeLine</strong></p>
<p>  <img src="TimeLine.png" alt="TimeLine.png"></p>
<p>  查看这一帧的时间轴</p>
</li>
<li><p><strong>Texture Viewer</strong></p>
<p>  <img src="TextureViewer.png" alt="TextureViewer.png"></p>
<p>  主要用来查看纹理显示，我们可以用它来查看在Event Browaser中选中的DrawCall或者Pass的输入和输出纹理。2中是输入纹理， 2中是输出纹理，在其中选中一个纹理，可以在 1中放大显示。</p>
</li>
<li><p><strong>Pipline Sate</strong></p>
<p>  <img src="PiplineSate.png" alt="PiplineSate.png"></p>
<p>  主要用来查看渲染管线过程</p>
</li>
<li><p><strong>Mesh Viewer</strong></p>
<p>  <img src="MeshViewer.png" alt="MeshViewer.png"></p>
<p>  主要是用来查看VertexShader中输入输出的顶点数据</p>
</li>
<li><p><strong>Resource Inspector</strong></p>
<p>  <img src="ResourceInspector.jpg" alt="ResourceInspector.jpg"></p>
<p>  查看这一帧中所有的资源</p>
<ul>
<li><p>1 是所有引用到这一个资源的的EID,点击可以跳转到Event Brower中选中。</p>
</li>
<li><p>2 是所有的资源列表</p>
</li>
<li><p>3 是初始化这个资源调用的一些OpenGL API</p>
</li>
</ul>
</li>
</ul>
<p>未完待续</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/24/Unity%20C#%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>\page code_specification 项目编码规范使用文档</p>
<h4><span id="前言">前言</span></h4><p>程序是给人看的，这个人包括团队的其他成员和一段时间后的自己（隔几天自己可能都忘了），所以请慎重命名，根据以下规范命名。</p>
<h4><span id="命名原则">命名原则</span></h4><ul>
<li>名称应该说明“什么”而不是“如何”。小技巧是把需求里面的名词提取出来考察。通常避免使用公开基础实现（它们会发生改变）的名称，可以保留简化复杂性的抽象层。例如，可以使用 GetNextStudent()，而不是GetNextArrayElement()。不要使用拼音进行命名，特别是公共函数。</li>
<li>选择正确名称时的困难可能表明需要进一步分析或定义项的目的。使名称足够长以便有一定的意义，并且足够短以避免冗长。唯一名称在编程上仅用于将各项区分开。表现力强的名称是为了帮助人们阅读；因此，提供人们可以理解的名称是有意义的。不过，请确保选择的名称符合适用语言的规则和标准。</li>
<li>Pascal Case：所有单词第一个字母大写，其他字母小写，例如MyClassName。</li>
<li>Camel Case：除了第一个单词，所有单词第一个字母大写，其他字母小写，例如myMemberName。</li>
<li><strong>不在任何地方使用匈牙利命名法，现代IDE的提示功能已经足够强大，匈牙利命名法已没有意义（匈牙利命名指的是在变量名前面加不同的字母表示类型例如g_s_b_walk）。</strong></li>
</ul>
<h4><span id="namespace-命名">Namespace 命名</span></h4><ul>
<li>使用“公司名.产品名.模块名”这样的格式。</li>
<li>Namespace中类的依赖关系应该体现在命名上，比如System.Web.UI.Design中的类依赖于System.Web.UI。使用 Pascal Case。</li>
<li>当商标（产品名）的命名风格和Pascal风格不符时，以商标（产品名）为准。</li>
<li>在语意合适的情况下使用复数，比如System.Collections。例外是缩写和商标的情况。</li>
<li>Namespace的名字不一定和Assembly一一对应。</li>
</ul>
<h4><span id="class-命名">Class 命名</span></h4><ul>
<li>使用名词或者名词性词组命名class。</li>
<li>使用 Pascal Case。</li>
<li>保守地使用缩写。项目类众所周知的缩写直接使用，其他缩写需要保守点。</li>
<li>不使用type前缀，例如C来标识Class。比如，使用FileStream而不是CFileStream。</li>
<li>除Partial 类外不使用下划线。</li>
<li>Partial类使用原类名+名词，例如Actor_State</li>
<li>偶尔的在Class名称组成中需要使用I开头的时候，比如IdentityStore，避免和Interface发生歧义。</li>
<li>在合适的时候，使用单词复合来标识从某个基类继承而来。比如xxxException。</li>
</ul>
<h4><span id="interface-的命名">Interface 的命名</span></h4><ul>
<li>使用名词或者名词性词组命名Interface。</li>
<li>使用 Pascal case。</li>
<li>保守地使用缩写。</li>
<li>在interface 名称前加上字母I来表示type是interface。</li>
<li>不要使用下划线。</li>
</ul>
<h4><span id="enumeration-type-命名">Enumeration Type 命名</span></h4><ul>
<li>对Enum类型和值使用Pascal case。</li>
<li>不要在Enum类型名称后面加上Enum后缀。</li>
</ul>
<h4><span id="static-field-命名">Static Field 命名</span></h4><ul>
<li>使用名词、名词性词组或者名词地缩写来命名static fields。</li>
<li>使用Pascal case。</li>
<li>在任何可能的情况下推荐你使用静态properties而不是public static fields。</li>
</ul>
<h4><span id="private-field-命名">Private Field 命名</span></h4><ul>
<li>使用名词、名词性词组或者名词地缩写来命名。</li>
<li>使用Camel Case。</li>
<li>变量名中不使用下划线 (_)。</li>
<li>只要合适，在变量名的末尾追加计算限定符（Avg、Sum、Min、Max、Index）。</li>
<li>在变量名中使用互补对，如 min/max、begin/end 和 open/close。</li>
<li>布尔变量包含 Is，这意味着 Yes/No 或 True/False 值，如 fileIsFound。</li>
<li>状态变量命名时，避免使用诸如 Flag 的术语。状态变量不同于布尔变量的地方是它可以具有两个以上的可能值。不是使用 documentFlag，而是使用更具描述性的名称，如 documentFormatType。</li>
</ul>
<h4><span id="局部变量命名">局部变量命名</span></h4><ul>
<li>遵循Private Field 命名规范。</li>
<li>除去for循环,不要轻易使用单字母变量i,j,k等。</li>
</ul>
<h4><span id="parameter-命名">Parameter 命名</span></h4><ul>
<li>使用Camel Case。</li>
<li>使用描述参数的意义的名字而不是描述参数类型的名字。开发工具应该提供有关参数类型的有意义的信息，因而参数的名字可以用于更好的描述意义。</li>
<li>保守地使用基于类型的参数名字，仅仅在它们是合适的场合下使用, 例如intValue。</li>
</ul>
<h4><span id="method-命名">Method 命名</span></h4><ul>
<li>使用动词或者动词性词组命名。</li>
<li>使用Pascal case。</li>
</ul>
<h4><span id="property-命名">Property 命名</span></h4><p>1.使用名词或者名词性词组命名。<br>2.使用Pascal case。<br>3.考虑使用和property type名字相同的名字作为property name。</p>
<h4><span id="event-命名">Event 命名</span></h4><ul>
<li>使用Pascal case。</li>
<li>在event handler名字中使用EventHandler后缀。</li>
<li>使用EventArgs后缀命名事件参数class。</li>
<li>考虑使用动词命名事件。使用进行时态来标识事件正在进行之中，使用完成时态标识事件已经完成。</li>
<li>一般应同时提供一个名字为OnXxx的protected method供派生类来改写。</li>
</ul>
<h4><span id="数据库表命名">数据库表命名</span></h4><ul>
<li>用单数形式表示名称。例如，使用 Employee，而不是 Employees。</li>
<li>在命名表的列时，不要重复表的名称；例如，在名为 Employee 的表中避免使用名为 EmployeeLastName 的字段。</li>
<li>列的名称中不要包含数据类型。如果后来有必要更改数据类型，这将减少工作量。</li>
</ul>
<h4><span id="缩进和间隔">缩进和间隔</span></h4><ul>
<li><p>使用vs.net的格式来格式化代码，位置为“编辑”-&gt;“高级”-&gt;“格式化选定内容。</p>
</li>
<li><p>建议缩进用 TAB，不用 SPACES。</p>
</li>
<li><p>串联运算符(+)放在行尾而不是开头，清楚地表示没有后面的行是不完整的。</p>
</li>
<li><p>注释需和代码对齐。</p>
</li>
<li><p>花括弧 ( {} .需和括号外的代码对齐。</p>
</li>
<li><p>用一个空行来分开代码的逻辑分组（视情况使用）。</p>
</li>
<li><p>在一个类中，各个方法需用一空行，也只能是一行分开。</p>
</li>
<li><p>花括弧需独立一行，而不象if, for 等可以跟括号在同一行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好</span><br><span class="line"><span class="keyword">if</span> ( ... )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line">不好（不是说这个风格不好，只是为了统一风格，决定采用上面的形式，故摒弃）：</span><br><span class="line"><span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line"><span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在每个运算符前后都空一格。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好：</span><br><span class="line"><span class="keyword">if</span> (showResult == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好：</span><br><span class="line"><span class="keyword">if</span>(showResult == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4><span id="编程方法">编程方法</span></h4><ul>
<li>避免使用大文件。如果一个文件里的代码超过300～400行，必须考虑将代码分开到不同类中。</li>
<li>避免写太长的方法。一个典型的方法代码在1～25行之间。如果一个方法发代码超过25行，应该考虑将其分解为不同的方法。</li>
<li>方法名需能看出它作什么。别使用会引起误解的名字。如果名字一目了然，就无需用文档来解释方法的功能了。</li>
<li>方法名需能看出它作什么。别使用会引起误解的名字。如果名字一目了然，就无需用文档来解释方法的功能了。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SavePhoneNumber</span>(<span class="params"><span class="built_in">string</span> phoneNumber</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Save the phone number.</span></span><br><span class="line">&#125;</span><br><span class="line">不好：</span><br><span class="line"><span class="comment">// This method will save the phone number.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveData</span>(<span class="params"><span class="built_in">string</span> phoneNumber</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Save the phone number.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个方法只完成一个任务。不要把多个任务组合到一个方法中，即使那些任务非常小。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好：</span><br><span class="line"><span class="comment">// Save the address.</span></span><br><span class="line">SaveAddress(address);</span><br><span class="line"><span class="comment">// Send an email to the supervisor to inform the address is // updated.</span></span><br><span class="line">SendEmail(address, email);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveAddress</span>(<span class="params"><span class="built_in">string</span> address</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Save the address.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendEmail</span>(<span class="params"><span class="built_in">string</span> address, <span class="built_in">string</span> email</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Send an email to inform the supervisor that the address //is changed.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">不好：</span><br><span class="line"><span class="comment">// Save address and send an email to the supervisor to inform //that the address is updated.</span></span><br><span class="line">SaveAddress(address, email);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveAddress</span> (<span class="params"><span class="built_in">string</span> address, <span class="built_in">string</span> email</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Job</span></span><br><span class="line"><span class="comment">// Save the address.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Job 2.</span></span><br><span class="line"><span class="comment">// Send an email to inform the supervisor that the address is changed.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4><span id="变量的使用">变量的使用</span></h4><ul>
<li>使用C# 特有类型，而不是System命名空间中定义的别名类型。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好：</span><br><span class="line"><span class="built_in">int</span> age;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">object</span> contactInfo;</span><br><span class="line">不好：</span><br><span class="line">Int16 age;</span><br><span class="line">String name;</span><br><span class="line">Object contactInfo;</span><br></pre></td></tr></table></figure></li>
<li>程序中不要使用固定数值，用常量代替。</li>
<li>程序中不要使用字符串常数，用资源文件。</li>
<li>避免使用很多成员变量。声明局部变量，并传递给方法。不要在方法间共享成员变量。如果在几个方法间共享一个成员变量，那就很难知道是哪个方法在什么时候修改了它的值。</li>
<li>必要时使用enum 。别用数字或字符串来指示离散值。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好：</span><br><span class="line"><span class="built_in">enum</span> MailType</span><br><span class="line">&#123;</span><br><span class="line">    Html,</span><br><span class="line">    PlainText,</span><br><span class="line">    Attachment</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMail</span>(<span class="params"><span class="built_in">string</span> message, MailType mailType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(mailType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> MailType.Html:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MailType.PlainText:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MailType.Attachment:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMail</span>(<span class="params"><span class="built_in">string</span> message, <span class="built_in">string</span> mailType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mailType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Html&quot;</span>:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PlainText&quot;</span>:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Attachment&quot;</span>:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>别把成员变量声明为 public 或 protected。都声明为 private 而使用 public/protected 的Properties。</li>
</ul>
<h4><span id="配置文件">配置文件</span></h4><ul>
<li>使用相对路径，代码中不要使用绝对路径，并使路径可编程。</li>
<li>应用程序启动时作些“自检”并确保所需文件和附件在指定的位置。必要时检查数据库连接。出现任何问题给用户一个友好的提示。</li>
<li>如果在配置文件中发现错误值，应用程序要抛出错误，给出提示消息告诉用户正确值。</li>
</ul>
<h4><span id="错误提示">错误提示</span></h4><ul>
<li>错误消息需能帮助用户解决问题。永远别用象”应用程序出错”, “发现一个错误” 等错误消息。而应给出象 “更新数据库失败。请确保登陆id和密码正确。” 的具体消息。</li>
<li>显示错误消息时，除了说哪里错了，还应提示用户如何解决问题。不要用 象 “更新数据库失败。”这样的，要提示用户怎么做：”更新数据库失败。请确保登陆id和密码正确。”</li>
<li>显示给用户的消息要简短而友好。但要把所有可能的信息都记录下来，以助诊断问题。</li>
</ul>
<h4><span id="注释">注释</span></h4><ul>
<li><p>软件文档以两种形式存在：外部的和内部的。外部文档（如规范、帮助文件和设计文档）在源代码的外部维护。内部文档由开发人员在开发时在源代码中编写的注释组成。</p>
</li>
<li><p>不考虑外部文档的可用性，由于硬拷贝文档可能会放错地方，源代码清单应该能够独立存在。外部文档应该由规范、设计文档、更改请求、错误历史记录和使用的编码标准组成。</p>
</li>
<li><p>内部软件文档的一个难题是确保注释的维护与更新与源代码同时进行。尽管正确注释源代码在运行时没有任何用途，但这对于必须维护特别复杂或麻烦的软件片段的开发人员来说却是无价的。</p>
</li>
<li><p>使用vs.net中的“///”添加注释。</p>
</li>
<li><p>语句注释避免在代码行的末尾添加注释。</p>
</li>
<li><p>对一个数值变量采用不是0,-1等的数值初始化，给出选择该值的理由。</p>
</li>
<li><p>如果应为某种原因使用了复杂艰涩的原理，为程序配备良好的文档和充分的注释。</p>
</li>
<li><p>在需要的地方注释。可读性强的代码需要很少的注释。如果所有的变量和方法的命名都很有意义，会使代码可读性很强并无需太多注释。</p>
</li>
</ul>
<h4><span id="异常处理">异常处理</span></h4><ul>
<li>不要”捕捉了异常却什么也不做”。如果隐藏了一个异常，你将永远不知道异常到底发生了没有。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">好：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadFromFile</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// read from file.</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch (FileIOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// log error.</span></span><br><span class="line">    <span class="comment">//  re-throw exception depending on your case.</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadFromFile</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// read from file.</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// Catching general exception is bad... we will never know whether it was a file error or some other error.</span></span><br><span class="line">    <span class="comment">// Here you are hiding an exception.</span></span><br><span class="line">    <span class="comment">// In this case no one will ever know that an exception happened.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>发生异常时，给出友好的消息给用户，但要精确记录错误的所有可能细节，包括发生的时间，和相关方法，类名等。</li>
<li>只捕捉特定的异常，而不是一般的异常。</li>
<li>不必在所有方法中捕捉一般异常。不管它，让程序崩溃。这将帮助你在开发周期发现大多数的错误。</li>
<li>你可以用应用程序级（线程级）错误处理器处理所有一般的异常。遇到一般性错误时，此错误处理器应该捕捉异常，给用户提示消息，在应用程序关闭或 用户选择”忽略并继续“之前记录错误信息。</li>
<li>不必每个方法都用try-catch。当特定的异常可能发生时才使用。比如，当你写文件时，处理异常FileIOException。</li>
<li>别写太大的 try-catch 模块。如果需要，为每个执行的任务编写单独的 try-catch 模块。 这将帮你找出哪一段代码产生异常，并给用户发出特定的错误消息。</li>
<li>如果应用程序需要，可以编写自己的异常类。自定义异常不应从基类SystemException派生，而要继承于IApplicationException。</li>
<li>抛出了异常的方法应该在方法名注释中添加该异常，以方便在代码时直观显示并处理，如图：7 代码自动规范</li>
<li>在Visual studio中，使用快捷键Ctrl + K, Ctrl + F，可以快速格式化代码。</li>
<li>使用CodeMaid插件。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/19/Unity%20MMD%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-08-25 12:23:10
 * @LastEditTime: 2021-08-25 12:29:51
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\Unity MMD动画制作技术总结.md
-->
<h1><span id="unity-mmd动画制作技术总结">Unity MMD动画制作技术总结</span></h1><h2><span id="参考资料">参考资料</span></h2><ul>
<li><a href="https://www.bilibili.com/video/av15322127?t=809">[傅老師/Unity教學] 番外篇Ex2 - 使用MMD模型製作人物(Using MMD model)</a></li>
<li><a href="https://www.jianshu.com/p/ee9befe44a2a">MMD模型导入Unity的解决方案</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/05/Unity%20API%20CommandBuffer%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1><span id="unity-api-commandbuffer-学习">Unity API CommandBuffer 学习</span></h1><h2><span id="简介">简介</span></h2><p>根据<a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html">官方文档</a>的描述，CommandBuffer 就是一个渲染命令缓冲区，而我们可以使用CommandBuffer 的相关API，自定义渲染时的一些事情.</p>
<h2><span id="如何使用">如何使用</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个CommandBuffer</span><br><span class="line">CommandBuffer commandBuffer = new CommandBuffer() &#123; name = &quot;CameraCmdBuffer&quot; &#125;;</span><br><span class="line">//为摄像机添加CommandBuffer</span><br><span class="line">cam.AddCommandBuffer(CameraEvent.BeforeDepthTexture, commandBuffer);</span><br><span class="line"></span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line">public class TestCommandBuffer : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Shader shader;</span><br><span class="line">    private void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        CommandBuffer buf = new CommandBuffer();</span><br><span class="line">        //设置自己的渲染。</span><br><span class="line">        buf.DrawRenderer(GetComponent&lt;Renderer&gt;(), new Material(shader));</span><br><span class="line">        //不透明物体渲染完后执行</span><br><span class="line">        Camera.main.AddCommandBuffer(CameraEvent.AfterForwardOpaque, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>未完待续</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/09/15/Unity%20Shader%20URP%20%E5%AD%A6%E4%B9%A0%20ShadowCaster/</url>
    <content><![CDATA[<h1><span id="unity-shader-urp-学习-shadowcaster">Unity Shader URP 学习 ShadowCaster</span></h1><h2><span id="参考资料">参考资料</span></h2><ul>
<li><a href="https://www.bilibili.com/read/cv6473097/">urp管线的自学hlsl之路 第十二篇 ShadowCaster和SRP batcher</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/156858564">对艺术家的SRP Batcher的简单理解</a></li>
</ul>
<h2><span id="问题阐述">问题阐述</span></h2><p>在URP管线下，需要投影，会采用直接调用官方的ShadowCaster pass(UsePass “Universal Render Pipeline/Lit/ShadowCaster”)。这样会出现问题,会让该shader无法进行SRP Batcher。如下图：</p>
<p><img src="SRPBatcher.png" alt="No SRP Batcher"></p>
<h2><span id="srp-batcher">SRP Batcher</span></h2><h4><span id="什么是srp-batcher">什么是SRP Batcher？</span></h4><p>下面是官方的相关文档：</p>
<p><a href="https://blogs.unity3d.com/2019/02/28/srp-batcher-speed-up-your-rendering/">SRP Batcher：加快渲染速度！</a></p>
<p>SRP 全称为Scriptable Render Pipeline，其中一部分就是SRP Batcher，主要用途在渲染过程中加速CPU。加速的原因如下：</p>
<ul>
<li>Each material content is now persistent in GPU memory</li>
<li>A dedicated code is managing a large “per object” GPU CBUFFER</li>
</ul>
<h4><span id="如何使用srp-batcher">如何使用SRP Batcher？</span></h4><ul>
<li>可以使用C#进行开启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GraphicsSettings.useScriptableRenderPipelineBatching = true;</span><br></pre></td></tr></table></figure></li>
<li>材质兼容的要求<ol>
<li>The object must be in a mesh. It cannot be a particle or a skinned mesh.（对象不能是粒子或者蒙皮mesh）</li>
<li>You must use a Shader that is compatible with the SRP Batcher. All Lit and Unlit Shaders in HDRP and LWRP fit this requirement.(必须使用兼容的SHADER)</li>
</ol>
</li>
<li>Shader的要求<ol>
<li>All built-in engine properties must be declared in a single CBUFFER named “UnityPerDraw”. For example, unity_ObjectToWorld, or unity_SHAr.</li>
<li>All Material properties must be declared in a single CBUFFER named “UnityPerMaterial”.</li>
</ol>
</li>
</ul>
<h2><span id="shadowcaster的问题">ShadowCaster的问题</span></h2><p>通过SRP Batcher的学习，可以猜测出官方默认ShadowCaster 并没有符合SRP Batcher的要求，为了解决这个问题，我们可以自己重写 ShadowCaster 这个pass。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pass</span><br><span class="line">       &#123;</span><br><span class="line">           //该pass只把主灯光空间的深度图写到了shadowmap里 addlight灯光空间目前没有写进去 导致模型无法投射addlight的阴影 但是整shader可以接受addlight的阴影</span><br><span class="line"></span><br><span class="line">           Tags</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;LightMode&quot;=&quot;ShadowCaster&quot;</span><br><span class="line">           &#125;</span><br><span class="line">           HLSLPROGRAM</span><br><span class="line">           #pragma vertex vertshadow</span><br><span class="line">           #pragma fragment fragshadow</span><br><span class="line">           v2f vertshadow(a2v i)</span><br><span class="line">           &#123;</span><br><span class="line">               v2f o;</span><br><span class="line">           </span><br><span class="line">               Light MainLight=GetMainLight();</span><br><span class="line">               float3 posWS=TransformObjectToWorld(i.vertex.xyz);</span><br><span class="line">               float3 nDirWS=TransformObjectToWorldNormal(i.normal.xyz);</span><br><span class="line">               o.pos=TransformWorldToHClip(ApplyShadowBias(posWS,nDirWS,MainLight.direction));</span><br><span class="line">           </span><br><span class="line">               //Z反向 </span><br><span class="line">               #if UNITY_REVERSED_Z</span><br><span class="line">                   o.pos.z=min(o.pos.z,o.pos.w*UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">               #else</span><br><span class="line">                   o.pos.z=max(o.pos.z,o.pos.w*UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">               #endif</span><br><span class="line">               return o;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           half4 fragshadow(v2f i):SV_TARGET&#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           ENDHLSL</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/21/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20C%20for%20Graphics/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-10-20 16:27:50
 * @LastEditTime: 2021-10-21 13:02:59
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\编写中\Unity Shader 学习 宏命令\Unity Shader 学习 宏命令.md
-->
<h1><span id="unity-shader-学习-c-for-graphics">Unity Shader 学习 C for Graphics</span></h1><h2><span id="简介">简介</span></h2><p>C for Graphics（cg）是英伟达为编写顶点着色器、像素着色器、几何着色器和曲面细分着色器程序而创立的一种高级着色器语言.</p>
<h2><span id="语法">语法</span></h2><p>Cg 的语法类似于C编程语言，由于 NVIDIA 和 Microsoft 之间的合作，Cg 的语法非常类似于 HLSL。</p>
<ul>
<li>条件编译<ul>
<li>#define            定义一个预处理宏</li>
<li>#undef            取消宏的定义</li>
<li>#if                   编译预处理中的条件命令，相当于C语法中的if语句</li>
<li>#ifdef              判断某个宏是否被定义，若已定义，执行随后的语句</li>
<li>#ifndef            与#ifdef相反，判断某个宏是否未被定义</li>
<li>#elif                若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if</li>
<li>#else              与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else</li>
<li>#endif             #if, #ifdef, #ifndef这些条件命令的结束标志.</li>
<li>defined         　与#if, #elif配合使用，判断某个宏是否被定义</li>
</ul>
</li>
</ul>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://de.wikipedia.org/wiki/C_for_graphics">C for Graphics - Wikipedia</a></p>
<p>[1] <a href="https://blog.csdn.net/wordwarwordwar/article/details/84932183">条件编译#ifdef的妙用详解</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/04/Unity%20Shader%20URP%20%E5%AD%A6%E4%B9%A0%20%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<h1><span id="unity-shader-urp-学习-基础光照">Unity Shader URP 学习 基础光照</span></h1><p>首先是几种常见的基础光照模型的简单说明</p>
<h2><span id="关于lambert兰伯特光照模型">关于Lambert（兰伯特）光照模型</span></h2><ul>
<li><h3><span id="简介">简介</span></h3><p>  用于模拟漫反射的光照模型，相关的<a href="https://en.wikipedia.org/wiki/Lambertian_reflectance">维基百科</a></p>
</li>
<li><h3><span id="光照公式">光照公式</span></h3><p>  Diffuse = max(0，dot(nDir, LightDir))</p>
</li>
</ul>
<h2><span id="关于halflambert半兰伯特光照模型">关于HalfLambert（半兰伯特）光照模型</span></h2><ul>
<li><h3><span id="简介">简介</span></h3><p>  Half Lambert光照模型是Valve公司在制作”半条命“游戏时发明的，用来给在比较暗的区域显示物体。总体来说，该光照模型提高了物体表面的漫反射光.下图是Alyx对于Lambert和Half Lambert的对比示意图</p>
<p>  <img src="Alyx_lambert_half_lambert.jpg" alt="Alyx_lambert_half_lambert.jpg"></p>
<p>  参考：<a href="https://developer.valvesoftware.com/wiki/Half_Lambert">https://developer.valvesoftware.com/wiki/Half_Lambert</a></p>
</li>
<li><h3><span id="光照公式">光照公式</span></h3><p>  Diffuse = dot(nDir, LightDir)*0.5+0.5</p>
</li>
</ul>
<h2><span id="关于phong冯氏光照模型">关于Phong（冯氏）光照模型</span></h2><ul>
<li><h3><span id="简介">简介</span></h3><p>  冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射 (Diffuse)和镜面(Specular)光照</p>
<ul>
<li>环境光照(Ambient Lighting)：物体几乎永远不会是完全黑暗的。所以环境光照一般是个常量</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响,物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
</li>
<li><h3><span id="光照公式">光照公式</span></h3><p>  最终片段颜色：环境颜色+漫反射颜色+镜面反射颜色</p>
<ul>
<li><p>环境颜色 = 光源的环境光颜色 × 物体的环境材质颜色 </p>
</li>
<li><p>漫反射颜色 = 光源的漫反射光颜色 × 物体的漫反射材质颜色 × 漫反射因子</p>
</li>
<li><p>镜面反射颜色 = 光源的镜面光颜色 × 物体的镜面材质颜色 × 镜面反射因子 </p>
</li>
</ul>
<p>  镜面反射最终颜色 = 直射光颜色 * 反射光颜色 * pow(max(0, dot(反射光方向, 视野方向)), 光泽度(gloss)) + 漫反射颜色 + 环境光颜色</p>
<p>  <img src="Phong_components_version_4.png" alt="Phong_components_version_4.png"></p>
<p>  参考： <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a></p>
</li>
</ul>
<h2><span id="关于blinnphong光照模型">关于BlinnPhong光照模型</span></h2><ul>
<li><h3><span id="简介">简介</span></h3><p>  BlinnPhong光照模型是一种改良的高光模型，采用了半角向量(half-angle vector)，和Phong的对比如下图：z</p>
<p>  <img src="400px-Blinn_phong_comparison.png" alt="400px-Blinn_phong_comparison.png"></p>
<p>  参考：</p>
<ul>
<li><p><a href="https://seblagarde.wordpress.com/2012/03/29/relationship-between-phong-and-blinn-lighting-model/">https://seblagarde.wordpress.com/2012/03/29/relationship-between-phong-and-blinn-lighting-model/</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model">https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model</a></p>
</li>
</ul>
</li>
<li><h3><span id="光照公式">光照公式</span></h3><p>  最终颜色 = 直射光颜色 * 反射光颜色 * pow(max(0, dot(法线方向, 视野与光线中间向量)), 光泽度(gloss)) + 漫反射颜色 + 环境光颜色</p>
</li>
</ul>
<h2><span id="关于fresnel-reflectionterm">关于Fresnel Reflection/Term</span></h2><ul>
<li><h3><span id="简介">简介</span></h3><p>  菲涅尔反射描述的是以不同的视角观察物体得到的反射光比例不同的现象</p>
<p>  参考：</p>
<ul>
<li><p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel">https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/394178688">https://zhuanlan.zhihu.com/p/394178688</a></p>
</li>
</ul>
</li>
<li><h3><span id="光照公式">光照公式</span></h3><p>  Fresnel = pow((1-dot(法线方向, 视方向)),系数);</p>
</li>
</ul>
<h2><span id="关于urp">关于URP</span></h2><ul>
<li><h3><span id="简介">简介</span></h3><p>  URP是一种SRP（可编程渲染管线），全称为Universal Render Pipeline。具体请看<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@11.0/manual/index.html">官方关于URP的文档</a></p>
</li>
<li><h3><span id="urp下的基础光照模型shader">URP下的基础光照模型Shader</span></h3>  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Costom/StandardBlinnPhong&quot;</span><br><span class="line"> &#123;</span><br><span class="line"> Properties&#123;</span><br><span class="line">     </span><br><span class="line">     [MainColor]_DiffuseColor(&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) </span><br><span class="line">     [MainTexture]_MainTex(&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">     </span><br><span class="line">     [Normal]_NormalMap(&quot;Normal Map&quot;,<span class="number">2</span>D) = &quot;bump&quot;&#123;&#125;</span><br><span class="line">     _NormalScale(&quot;NormalScale&quot;,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">     </span><br><span class="line">     [Toggle] _UseCubMap(&quot;Use Cub Map&quot;, Int) = <span class="number">0</span></span><br><span class="line">     _CubMap(&quot;Env Map&quot;,CUBE) = &quot;&quot;&#123;&#125;</span><br><span class="line">     </span><br><span class="line">     _Metallic(&quot;Metallic&quot;,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">     _Smoothness(&quot;Smoothness&quot;,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">     _Fresnel(&quot;Fresnel&quot;,Range(<span class="number">0</span>,<span class="number">100</span>)) = <span class="number">4</span></span><br><span class="line"> &#125;</span><br><span class="line"> SubShader</span><br><span class="line"> &#123;</span><br><span class="line">     Tags&#123;&quot;RenderType&quot; = &quot;Opaque&quot; &quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">     </span><br><span class="line">     HLSLINCLUDE</span><br><span class="line">     </span><br><span class="line">         <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line">         <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot; </span></span><br><span class="line">         <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl&quot;</span></span><br><span class="line">     </span><br><span class="line">         struct a2v</span><br><span class="line">         &#123;</span><br><span class="line">             float4 vertex       : POSITION;</span><br><span class="line">             float2 uv           : TEXCOORD0;</span><br><span class="line">             float3 normal       : NORMAL;</span><br><span class="line">             float4 tangent      : TANGENT;</span><br><span class="line">         &#125;;</span><br><span class="line">     </span><br><span class="line">         struct v2f</span><br><span class="line">         &#123;</span><br><span class="line">             float4 pos          : SV_POSITION;</span><br><span class="line">             float2 uv           : TEXCOORD0;</span><br><span class="line">             float3 posWS        : TEXCOORD1;</span><br><span class="line">             float3 nDirWS       : TEXCOORD2;</span><br><span class="line">             float3 tDirWS       : TEXCOORD3;</span><br><span class="line">             float3 bDirWS       : TEXCOORD4;</span><br><span class="line">             <span class="meta">#ifdef _MAIN_LIGHT_SHADOWS</span></span><br><span class="line">                 float4 shadowCoord  : TEXCOORD5;</span><br><span class="line">             <span class="meta">#endif</span></span><br><span class="line">         &#125;;</span><br><span class="line">     </span><br><span class="line">         CBUFFER_START(UnityPerMaterial)</span><br><span class="line">             float4 _DiffuseColor;</span><br><span class="line">             real4 _MainTex_ST;</span><br><span class="line">             real _NormalScale;</span><br><span class="line">             <span class="type">float</span> _Metallic;</span><br><span class="line">             <span class="type">float</span> _Smoothness;</span><br><span class="line">             <span class="type">float</span> _Fresnel;</span><br><span class="line">         CBUFFER_END</span><br><span class="line"></span><br><span class="line">         TEXTURE2D(_MainTex);</span><br><span class="line">         SAMPLER(sampler_MainTex);</span><br><span class="line">         TEXTURE2D(_NormalMap);</span><br><span class="line">         SAMPLER(sampler_NormalMap);</span><br><span class="line">         TEXTURECUBE(_CubMap);</span><br><span class="line">         SAMPLER(sampler_CubMap);</span><br><span class="line">     </span><br><span class="line">     ENDHLSL</span><br><span class="line">     </span><br><span class="line">     Pass</span><br><span class="line">     &#123;</span><br><span class="line">         Tags&#123;&quot;LightMode&quot; = &quot;UniversalForward&quot;&#125;</span><br><span class="line">         </span><br><span class="line">         HLSLPROGRAM</span><br><span class="line">         </span><br><span class="line">         <span class="meta">#pragma vertex vert</span></span><br><span class="line">         <span class="meta">#pragma fragment frag</span></span><br><span class="line">         </span><br><span class="line">         <span class="meta">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS         </span></span><br><span class="line">         <span class="meta">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE </span></span><br><span class="line">         <span class="meta">#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS</span></span><br><span class="line">         <span class="meta">#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS   </span></span><br><span class="line">         <span class="meta">#pragma multi_compile _ _SHADOWS_SOFT            </span></span><br><span class="line"></span><br><span class="line">         <span class="meta">#pragma shader_feature _USECUBMAP_ON</span></span><br><span class="line">         </span><br><span class="line">         v2f vert(a2v i)</span><br><span class="line">         &#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             o.posWS = TransformObjectToWorld(i.vertex.xyz);</span><br><span class="line">             o.pos = TransformWorldToHClip(o.posWS);</span><br><span class="line">             o.uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">             o.nDirWS = TransformObjectToWorldNormal(i.normal);</span><br><span class="line">             o.tDirWS = <span class="built_in">normalize</span>(TransformObjectToWorldDir(i.tangent.xyz));</span><br><span class="line">             o.bDirWS = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.nDirWS,o.tDirWS)*i.tangent.w);</span><br><span class="line">             <span class="meta">#ifdef _MAIN_LIGHT_SHADOWS</span></span><br><span class="line">                 o.shadowCoord = TransformWorldToShadowCoord(o.posWS);</span><br><span class="line">             <span class="meta">#endif</span></span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         half4 frag(v2f i) : SV_Target</span><br><span class="line">         &#123;</span><br><span class="line">             float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);</span><br><span class="line">             float3 nDirWS = <span class="built_in">normalize</span>(i.nDirWS);</span><br><span class="line">             float4 normalMap = SAMPLE_TEXTURE2D(_NormalMap,sampler_NormalMap,i.uv); </span><br><span class="line">             float3 normal = UnpackNormal(normalMap);</span><br><span class="line">             normal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(normal.xy,normal.xy)));</span><br><span class="line">             normal = TransformTangentToWorld(normal,TBN);</span><br><span class="line">             normal = <span class="built_in">normalize</span>(normal);</span><br><span class="line">             nDirWS = lerp(nDirWS,normal,_NormalScale);</span><br><span class="line">             </span><br><span class="line">             <span class="meta">#ifdef _MAIN_LIGHT_SHADOWS</span></span><br><span class="line">                 Light mainLight = GetMainLight(TransformWorldToShadowCoord(i.posWS));</span><br><span class="line">             <span class="meta">#else</span></span><br><span class="line">                 Light mainLight = GetMainLight();</span><br><span class="line">             <span class="meta">#endif</span></span><br><span class="line">             real4 lightColor = real4(mainLight.color, <span class="number">1</span>);</span><br><span class="line">             float3 lightDir = mainLight.direction;</span><br><span class="line">             </span><br><span class="line">             half shadow = mainLight.shadowAttenuation;</span><br><span class="line">             </span><br><span class="line">             half3 vDirWS = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.posWS);</span><br><span class="line">             float3 refWS = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-vDirWS,nDirWS));</span><br><span class="line">             </span><br><span class="line">             <span class="type">float</span> nDotL = <span class="built_in">dot</span>(nDirWS, lightDir);</span><br><span class="line">             <span class="type">float</span> nDotV = <span class="built_in">dot</span>(nDirWS, vDirWS);</span><br><span class="line">             </span><br><span class="line">             <span class="type">float</span> lambert = <span class="built_in">max</span>(<span class="number">0.0</span>,nDotL);</span><br><span class="line">             <span class="type">float</span> fresnel = <span class="built_in">pow</span>((<span class="number">1</span>-nDotV),_Fresnel);</span><br><span class="line">             </span><br><span class="line">             float3 halfVec = <span class="built_in">normalize</span>(lightDir+vDirWS);</span><br><span class="line">             <span class="type">float</span> blinnPhong = saturate(<span class="built_in">dot</span>(nDirWS, halfVec));</span><br><span class="line">             float3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-lightDir,nDirWS));</span><br><span class="line">             <span class="type">float</span> phong = <span class="built_in">max</span>(<span class="number">0.0</span>,<span class="built_in">dot</span>(reflectDir,vDirWS));</span><br><span class="line">             </span><br><span class="line">             half4 ambientLight = half4(SampleSH(nDirWS),<span class="number">1</span>);</span><br><span class="line">             <span class="meta">#ifdef _USECUBMAP_ON</span></span><br><span class="line">                 ambientLight = SAMPLE_TEXTURECUBE_LOD(_CubMap,sampler_CubMap,refWS,(<span class="number">255</span>-_Smoothness*<span class="number">255</span>)*<span class="number">8</span>/<span class="number">255</span>);</span><br><span class="line">             <span class="meta">#endif</span></span><br><span class="line">             </span><br><span class="line">             _DiffuseColor = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0.02</span>,_DiffuseColor),<span class="number">1.1</span>);</span><br><span class="line">             half4 mainColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">             </span><br><span class="line">             float4 ambient  = ambientLight*_DiffuseColor*_Metallic;</span><br><span class="line">             float4 diffuse = ((lightColor*lambert*shadow+half4(SampleSH(nDirWS),<span class="number">1</span>))*mainColor*_DiffuseColor)*(<span class="number">1</span>-(_Metallic+_Smoothness)*<span class="number">0.5</span>);</span><br><span class="line">             float4 specular = lightColor*lerp(<span class="built_in">smoothstep</span>(<span class="number">0</span>,<span class="number">0.9</span>,<span class="built_in">pow</span>(blinnPhong,_Smoothness*<span class="number">255</span>)),float4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>-_Smoothness))*shadow;</span><br><span class="line">             specular = lerp(specular,_DiffuseColor*specular,_Metallic)+fresnel*ambientLight*_Smoothness;</span><br><span class="line"></span><br><span class="line">             float4 result= (ambient+diffuse+specular);</span><br><span class="line">             <span class="keyword">return</span>  result;</span><br><span class="line">         &#125;</span><br><span class="line">         ENDHLSL</span><br><span class="line">     &#125;</span><br><span class="line">     pass</span><br><span class="line">     &#123;</span><br><span class="line">         Tags</span><br><span class="line">         &#123;</span><br><span class="line">             &quot;LightMode&quot;=&quot;ShadowCaster&quot;</span><br><span class="line">         &#125;</span><br><span class="line">         HLSLPROGRAM</span><br><span class="line">         <span class="meta">#pragma vertex vertshadow</span></span><br><span class="line">         <span class="meta">#pragma fragment fragshadow</span></span><br><span class="line">         v2f vertshadow(a2v i)</span><br><span class="line">         &#123;</span><br><span class="line">             v2f o;</span><br><span class="line">             Light MainLight=GetMainLight();</span><br><span class="line">             float3 posWS=TransformObjectToWorld(i.vertex.xyz);</span><br><span class="line">             float3 nDirWS=TransformObjectToWorldNormal(i.normal.xyz);</span><br><span class="line">             o.pos=TransformWorldToHClip(ApplyShadowBias(posWS,nDirWS,MainLight.direction));</span><br><span class="line">         </span><br><span class="line">             <span class="meta">#if UNITY_REVERSED_Z</span></span><br><span class="line">                 o.pos.z=<span class="built_in">min</span>(o.pos.z,o.pos.w*UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">             <span class="meta">#else</span></span><br><span class="line">                 o.pos.z=<span class="built_in">max</span>(o.pos.z,o.pos.w*UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">             <span class="meta">#endif</span></span><br><span class="line">             <span class="keyword">return</span> o;</span><br><span class="line">         &#125;</span><br><span class="line">         half4 fragshadow(v2f i):SV_TARGET&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ENDHLSL</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/24/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Biplanar%20Shader/</url>
    <content><![CDATA[<h1><span id="unity-shader-学习-biplanar-shader">Unity Shader 学习 Biplanar Shader</span></h1><h2><span id="参考资料">参考资料</span></h2><p><a href="https://iquilezles.org/www/articles/biplanar/biplanar.html">IQ</a></p>
<h2><span id="优缺点">优缺点</span></h2><ul>
<li>优点：<ul>
<li>使用了更少的贴图采样，相较于三向</li>
</ul>
</li>
<li>缺点：<ul>
<li>模型不等比例缩放时，会出现表现错误</li>
</ul>
</li>
</ul>
<h2><span id="效果对比">效果对比</span></h2><p><img src="Biplanar.png" alt="Biplanar"><br><img src="Triplanar.png" alt="Triplanar"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/21/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Bump%20Mapping/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-10-21 12:55:55
 * @LastEditTime: 2021-10-21 13:16:06
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\编写中\Unity Shader 学习 Bump Mapping\Unity Shader 学习 Bump Mapping.md
-->
<h1><span id="unity-shader-学习-bump-mapping">Unity Shader 学习 Bump Mapping</span></h1><h2><span id="简介">简介</span></h2><p>Bump Mapping（凹凸映射） 是计算机图形学中的一种纹理映射技术，用于模拟物体表面的凹凸和皱纹<sup>[1]</sup>。目前有2中方法：</p>
<ul>
<li><p>height map (高度纹理) 通过模拟置换获得修改后的法线值，又名高度映射(height mapping)</p>
</li>
<li><p>noraml map (法线纹理) 通过存储在纹理中的法线信息来实现的，又名法线映射(noraml mapping)</p>
<p>  记录pixel shading过程中每个pixel的法线信息，用来描述像素级的法线信息，而不是直接使用顶点和面法线插值得到的pixel法线，从而得到更好的细节表现<sup>[3]</sup>。</p>
</li>
</ul>
<h2><span id="实现逻辑">实现逻辑</span></h2><ul>
<li><p>noraml map</p>
<ul>
<li><p>实现逻辑<br>  有2种方法：1.在切线空间下计算，2.在世界空间下计算。但是由于通用性问题第二种要优于第一种，例如使用CubeMap我们要在世界空间下进行采样。</p>
<ul>
<li><p>在世界空间下计算</p>
<ul>
<li>在顶点着色器计算从切线空间到世界空间的变换矩阵 TBN矩阵 T切线 B副切线 N法线 B可以由TN叉乘获得  <div align="center">
  <img src="TBN.png" height="330" width="495">
  </div></li>
<li>获得切线空间下的法线纹理数据</li>
<li>将法线纹理数据从切线空间转换到世界空间</li>
</ul>
</li>
</ul>
</li>
<li><p>Coding</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/NoramlShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    [Normal]_NormalMap(&quot;Normal Map&quot;,<span class="number">2</span>D) = &quot;bump&quot;&#123;&#125;</span><br><span class="line">    _NormalScale(&quot;NormalScale&quot;,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        HLSLPROGRAM</span><br><span class="line">        <span class="meta">#pragma vertex vert</span></span><br><span class="line">        <span class="meta">#pragma fragment frag</span></span><br><span class="line">        <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line">        <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot; </span></span><br><span class="line"></span><br><span class="line">        struct appdata</span><br><span class="line">        &#123;</span><br><span class="line">            float4 vertex       : POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">            float3 normal       : NORMAL;</span><br><span class="line">            float4 tangent      : TANGENT;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos          : SV_POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">            float3 posWS        : TEXCOORD1;</span><br><span class="line">            float3 nDirWS       : TEXCOORD2;</span><br><span class="line">            float3 tDirWS       : TEXCOORD3;</span><br><span class="line">            float3 bDirWS       : TEXCOORD4;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            real4 _MainTex_ST;</span><br><span class="line">            real _NormalScale;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line">        TEXTURE2D(_NormalMap);</span><br><span class="line">        SAMPLER(sampler_NormalMap);</span><br><span class="line"></span><br><span class="line">        v2f vert (appdata v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.posWS = TransformObjectToWorld(v.vertex.xyz);</span><br><span class="line">            o.pos = TransformWorldToHClip(o.posWS);</span><br><span class="line">            o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">            o.nDirWS = TransformObjectToWorldNormal(v.normal);</span><br><span class="line">            o.tDirWS = <span class="built_in">normalize</span>(TransformObjectToWorldDir(v.tangent.xyz));</span><br><span class="line">            o.bDirWS = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.nDirWS,o.tDirWS)*v.tangent.w);</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half4 frag (v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float3x3 TBN = float3x3(i.tDirWS,i.bDirWS,i.nDirWS);</span><br><span class="line">            float3 nDirWS = <span class="built_in">normalize</span>(i.nDirWS);</span><br><span class="line">            float4 normalMap = SAMPLE_TEXTURE2D(_NormalMap,sampler_NormalMap,i.uv); </span><br><span class="line">            float3 normal = UnpackNormal(normalMap);</span><br><span class="line">            normal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(normal.xy,normal.xy)));</span><br><span class="line">            normal = TransformTangentToWorld(normal,TBN);</span><br><span class="line">            normal = <span class="built_in">normalize</span>(normal);</span><br><span class="line">            <span class="comment">// 混合法线</span></span><br><span class="line">            nDirWS = lerp(nDirWS,normal,_NormalScale);</span><br><span class="line"></span><br><span class="line">            Light mainLight = GetMainLight();</span><br><span class="line">            real4 lightColor = real4(mainLight.color, <span class="number">1</span>);</span><br><span class="line">            float3 lightDir = mainLight.direction;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> nDotL = <span class="built_in">dot</span>(nDirWS, lightDir);</span><br><span class="line">            <span class="type">float</span> lambert = <span class="built_in">max</span>(<span class="number">0.0</span>,nDotL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lambert.rrrr;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2><span id="问题和思考">问题和思考</span></h2><ol>
<li><p>法线贴图为什么是蓝色的？<br> 模型空间下的法线纹理看起来是“五颜六色”的。这是因为所有法线所在的坐标空间是同一个坐标空间，即模型空间，而每个点存储的法线方向是各异的，有的是(0,1, 0), 经过映射后存储到纹理中就对应了 RGB(0.5, 1, 0.5) 浅绿色，有的是(0, -1, 0), 经过映射后存储到纹理中就对应了 0.5, 0, 0.5)紫色。而切线空间下的法线纹理看起来几乎全部是浅蓝色的这是因为，每个法线方向所在的坐标空间是不一样的，即是表面每点各自的切线空间。这种法线纹理其实就是存储了每个点在各自的切线空间中的法线扰动方向。也就是说，如果一个点的法线方向不变，那么在它的切线空间中 ，新的法线方向就是 轴方向，即值为(0,0, 1), 经过映射后存储在纹理中就对应了 RGB(0.5, 0.5, 1) 浅蓝色 。而这个颜色就是法线纹理中大片的蓝色。</p>
</li>
<li><p>为什么法线贴图一般使用的是切线空间而非模型空间？</p>
<ul>
<li>自由度高</li>
<li>可进行UV动画</li>
<li>可重用法线纹理</li>
<li>可压缩</li>
</ul>
</li>
<li><p>什么是切线空间（Tangent space）？</p>
<p> Tangent space是一个三维空间。对3D空间中的一个顶点来说，切空间的三条座标轴分别对应该点的法线N，切线T，和副法线（binormal）B，显然，对不同的顶点来说，切空间是不同的。</p>
 <div align="center">
 <img src="NTBFromUVs.png">
 </div>

<p> T = normalize(dx/du, dy/du, dz/du)</p>
<p> N = T × normalize(dx/dv, dy/dv, dz/dv)</p>
<p> B = N × T</p>
</li>
<li><p>法线贴图的设置细节。</p>
<ul>
<li>法线贴图的属性 Bump</li>
<li>贴图属性 TextureType-Noraml Map</li>
</ul>
</li>
<li><p>法线贴图的优化方案。</p>
<ol>
<li>使用双通道进行法线数据的处理</li>
</ol>
</li>
</ol>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://en.wikipedia.org/wiki/Bump_mapping">Bump mapping - wikipedia</a></p>
<p>[2] <a href>Unity Shader 入门精要 - 凹凸映射 - 146</a></p>
<p>[3] <a href="https://www.bilibili.com/video/BV1Ub4y1Z765?spm_id_from=333.999.0.0">图形 2.5 BUMP图改进</a></p>
<p>[4] <a href="https://www.bilibili.com/video/BV1Ut4y1m776?spm_id_from=333.999.0.0">庄懂的技术美术入门课(美术向)-直播录屏-第8课</a></p>
<p>[5] <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/">Tutorial 13 : Normal Mapping</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/18/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Glitch%20Art/</url>
    <content><![CDATA[<h1><span id="unity-shader-学习-glitch-art">Unity Shader 学习 Glitch Art</span></h1><div align="center">
<img src="giphy.gif" height="330" width="495">
<center>图 《赛博朋克 2077》 带有强烈故障艺术风格的Logo @ CD Projekt @2019 E3展</center>
</div>

<h2><span id="简介">简介</span></h2><p>Glitch Art(故障艺术)是通过破坏数字数据或物理操作电子设备，将数字或模拟错误用于美学目的的做法<a href="#refer-anchor"><sup>[1]</sup></a>。<br>近年来，故障艺术已经成为了赛博朋克风格的电影和游戏作品中主要的艺术风格之一。</p>
<h2><span id="故障艺术的实现">故障艺术的实现：</span></h2><p>源自毛星云大佬的十种故障艺术(Glitch Art)算法的总结与实现<a href="#refer-anchor"><sup>[2]</sup></a></p>
<ol>
<li><h3><span id="rgb颜色分离故障rgb-split-glitch">RGB颜色分离故障（RGB Split Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="gpxc8u8fv2a2cwfgvo02.png" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  通过不同UV对图形进行三次采样的进行RGB通道重新混合。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> randomNoise(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> frac(<span class="built_in">sin</span>(<span class="built_in">dot</span>(float2(x, y), float2(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 Frag_Horizontal(VaryingsDefault i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> splitAmount = _Indensity * randomNoise(_TimeX, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    half4 ColorR = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(i.texcoord.x + splitAmount, i.texcoord.y));</span><br><span class="line">    half4 ColorG = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord);</span><br><span class="line">    half4 ColorB = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(i.texcoord.x - splitAmount, i.texcoord.y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> half4(ColorR.r, ColorG.g, ColorB.b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="错位图块故障image-block-glitch">错位图块故障（Image Block Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="Image Block Glitch.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  基于uv和噪声函数生成方格块，然后将方块强度随机，然后剔除部分。最后与UV进行混合再对图形进行采样。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline <span class="type">float</span> randomNoise(float2 seed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> frac(<span class="built_in">sin</span>(<span class="built_in">dot</span>(seed * <span class="built_in">floor</span>(_Time.y * _Speed), float2(<span class="number">17.13</span>, <span class="number">3.71</span>))) * <span class="number">43758.5453123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline <span class="type">float</span> randomNoise(<span class="type">float</span> seed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> randomNoise(float2(seed, <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 Frag(VaryingsDefault i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    half2 block = randomNoise(<span class="built_in">floor</span>(i.texcoord * _BlockSize));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> displaceNoise = <span class="built_in">pow</span>(block.x, <span class="number">8.0</span>) * <span class="built_in">pow</span>(block.x, <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">float</span> splitRGBNoise = <span class="built_in">pow</span>(randomNoise(<span class="number">7.2341</span>), <span class="number">17.0</span>);</span><br><span class="line">    <span class="type">float</span> offsetX = displaceNoise - splitRGBNoise * _MaxRGBSplitX;</span><br><span class="line">    <span class="type">float</span> offsetY = displaceNoise - splitRGBNoise * _MaxRGBSplitY;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> noiseX = <span class="number">0.05</span> * randomNoise(<span class="number">13.0</span>);</span><br><span class="line">    <span class="type">float</span> noiseY = <span class="number">0.05</span> * randomNoise(<span class="number">7.0</span>);</span><br><span class="line">    float2 <span class="keyword">offset</span> = float2(offsetX * noiseX, offsetY* noiseY);</span><br><span class="line"></span><br><span class="line">    half4 colorR = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord);</span><br><span class="line">    half4 colorG = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord + <span class="keyword">offset</span>);</span><br><span class="line">    half4 colorB = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord - <span class="keyword">offset</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> half4(colorR.r , colorG.g, colorB.z, (colorR.a + colorG.a + colorB.a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="错位线条故障line-block-glitch">错位线条故障（Line Block Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="6400.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  通过生成随机宽度的线条，再进行随机扰动以及剔除部分，然后和UV混合，最后进行采样。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="built_in">trunc</span>(<span class="type">float</span> x, <span class="type">float</span> num_levels)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">floor</span>(x * num_levels) / num_levels;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成随机强度梯度线条</span></span><br><span class="line"><span class="type">float</span> truncTime = <span class="built_in">trunc</span>(_TimeX, <span class="number">4.0</span>);       </span><br><span class="line"><span class="type">float</span> uv_trunc = randomNoise(<span class="built_in">trunc</span>(uv.yy, float2(<span class="number">8</span>, <span class="number">8</span>)) + <span class="number">100.0</span> * truncTime);</span><br><span class="line"><span class="type">float</span> uv_randomTrunc = <span class="number">6.0</span> * <span class="built_in">trunc</span>(_TimeX, <span class="number">24.0</span> * uv_trunc);</span><br><span class="line"><span class="comment">//生成随机梯度的非等宽线条</span></span><br><span class="line"><span class="type">float</span> blockLine_random = <span class="number">0.5</span> * randomNoise(<span class="built_in">trunc</span>(uv.yy + uv_randomTrunc, float2(<span class="number">8</span> * _LinesWidth, <span class="number">8</span> * _LinesWidth)));</span><br><span class="line">blockLine_random += <span class="number">0.5</span> * randomNoise(<span class="built_in">trunc</span>(uv.yy + uv_randomTrunc, float2(<span class="number">7</span>, <span class="number">7</span>)));</span><br><span class="line">blockLine_random = blockLine_random * <span class="number">2.0</span> - <span class="number">1.0</span>;    </span><br><span class="line">blockLine_random = <span class="built_in">sign</span>(blockLine_random) * saturate((<span class="built_in">abs</span>(blockLine_random) - _Amount) / (<span class="number">0.4</span>));</span><br><span class="line">blockLine_random = lerp(<span class="number">0</span>, blockLine_random, _Offset);</span><br><span class="line">/ 生成源色调的blockLine Glitch</span><br><span class="line">float2 uv_blockLine = uv;</span><br><span class="line">uv_blockLine = saturate(uv_blockLine + float2(<span class="number">0.1</span> * blockLine_random, <span class="number">0</span>));</span><br><span class="line">float4 blockLineColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, <span class="built_in">abs</span>(uv_blockLine));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="4">
<li><h3><span id="图块抖动故障tile-jitter-glitch">图块抖动故障（Tile Jitter Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="v2-644ae2ffbaa0684a5c281c4b99493a0e_b.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  通过余数的形式（fmod(x,y)方法可返回x/y的余数）来对uv进行分层，且对于层内的uv数值，进行三角函数形式的抖动。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#if USING_FREQUENCY_INFINITE</span></span><br><span class="line">    strength = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    strength = <span class="number">0.5</span> + <span class="number">0.5</span> * <span class="built_in">cos</span>(_Time.y * _Frequency);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="keyword">if</span>(fmod(uv.y * _SplittingNumber, <span class="number">2</span>) &lt; <span class="number">1.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#if JITTER_DIRECTION_HORIZONTAL</span></span><br><span class="line">        uv.x += pixelSizeX * <span class="built_in">cos</span>(_Time.y * _JitterSpeed) * _JitterAmount * strength;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">        uv.y += pixelSizeX * <span class="built_in">cos</span>(_Time.y * _JitterSpeed) * _JitterAmount * strength;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">half4 sceneColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="扫描线抖动故障scan-line-jitter-glitch">扫描线抖动故障（Scan Line Jitter Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="tumblr_nqwxq8Kw8a1qio469o2_400.gif" height="330" width="330">
  </div></li>
<li><p>思路</p>
<p>  通过对uv的一个方向进行噪波抖动，再进行图像的采样。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> randomNoise(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> frac(<span class="built_in">sin</span>(<span class="built_in">dot</span>(float2(x, y), float2(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 Frag_Horizontal(VaryingsDefault i): SV_Target</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> jitter = randomNoise(i.texcoord.y, _Time.x) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    jitter *= <span class="built_in">step</span>(_ScanLineJitter.y, <span class="built_in">abs</span>(jitter)) * _ScanLineJitter.x;</span><br><span class="line"></span><br><span class="line">    half4 sceneColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, frac(i.texcoord + float2(jitter, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sceneColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="数字条纹故障digital-stripe-glitch">数字条纹故障（Digital Stripe Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="640.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  基于随机数进行随机颜色条纹贴图的生成</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; _noiseTexture.height; y++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; _noiseTexture.width; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//随机值若大于给定strip随机阈值，重新随机颜色</span></span><br><span class="line">        <span class="keyword">if</span> (UnityEngine.Random.value &gt; stripLength)</span><br><span class="line">        &#123;</span><br><span class="line">            color = XPostProcessingUtility.RandomColor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置贴图像素值</span></span><br><span class="line">        _noiseTexture.SetPixel(x, y, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 Frag(VaryingsDefault i): SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基础数据准备</span></span><br><span class="line">    half4 stripNoise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, i.texcoord);</span><br><span class="line">    half threshold = <span class="number">1.001</span> - _Indensity * <span class="number">1.001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uv偏移</span></span><br><span class="line">    half uvShift = <span class="built_in">step</span>(threshold, <span class="built_in">pow</span>(<span class="built_in">abs</span>(stripNoise.x), <span class="number">3</span>));</span><br><span class="line">    float2 uv = frac(i.texcoord + stripNoise.yz * uvShift);</span><br><span class="line">    half4 source = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#ifndef NEED_TRASH_FRAME</span></span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于废弃帧插值</span></span><br><span class="line">    half stripIndensity = <span class="built_in">step</span>(threshold, <span class="built_in">pow</span>(<span class="built_in">abs</span>(stripNoise.w), <span class="number">3</span>)) * _StripColorAdjustIndensity;</span><br><span class="line">    half3 color = lerp(source, _StripColorAdjustColor, stripIndensity).rgb;</span><br><span class="line">    <span class="keyword">return</span> float4(color, source.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="模拟噪点故障analog-noise-glitch">模拟噪点故障（Analog Noise Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="S6vq.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  通过噪波函数混合贴图颜色。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> noiseX = randomNoise(_TimeX * _Speed + i.texcoord / float2(<span class="number">-213</span>, <span class="number">5.53</span>));</span><br><span class="line"><span class="type">float</span> noiseY = randomNoise(_TimeX * _Speed - i.texcoord / float2(<span class="number">213</span>, <span class="number">-5.53</span>));</span><br><span class="line"><span class="type">float</span> noiseZ = randomNoise(_TimeX * _Speed + i.texcoord / float2(<span class="number">213</span>, <span class="number">5.53</span>));</span><br><span class="line"></span><br><span class="line">sceneColor.rgb += <span class="number">0.25</span> * float3(noiseX,noiseY,noiseZ) - <span class="number">0.125</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="屏幕跳跃故障screen-jump-glitch">屏幕跳跃故障（Screen Jump Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="I3uP.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  通过对UV值进行均匀梯度式扰动再进行采样。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">half4 Frag_Vertical(VaryingsDefault i): SV_Target</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> jump = lerp(i.texcoord.y, frac(i.texcoord.y + _JumpTime), _JumpIndensity);        </span><br><span class="line">    half4 sceneColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, frac(float2(i.texcoord.x, jump)));   </span><br><span class="line">    <span class="keyword">return</span> sceneColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="屏幕抖动故障screen-shake-glitch">屏幕抖动故障（Screen Shake Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="64d0.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  基本和Screen Jump类似，不过抖动不是均匀梯度式。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">half4 Frag_Horizontal(VaryingsDefault i): SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> shake = (randomNoise(_Time.x, <span class="number">2</span>) - <span class="number">0.5</span>) * _ScreenShake;</span><br><span class="line"></span><br><span class="line">    half4 sceneColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, frac(float2(i.texcoord.x + shake, i.texcoord.y)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sceneColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3><span id="波动抖动故障wave-jitter-glitch">波动抖动故障（Wave Jitter Glitch）</span></h3><ul>
<li><p>表现</p>
  <div align="center">
  <img src="4A3a.gif" height="330" width="495">
  </div></li>
<li><p>思路</p>
<p>  利用多重的noise进行实现</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 Frag_Horizontal(VaryingsDefault i): SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    half strength = <span class="number">0.0</span>;</span><br><span class="line">    <span class="meta">#if USING_FREQUENCY_INFINITE</span></span><br><span class="line">        strength = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">        strength = <span class="number">0.5</span> + <span class="number">0.5</span> *<span class="built_in">cos</span>(_Time.y * _Frequency);</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare UV</span></span><br><span class="line">    <span class="type">float</span> uv_y = i.texcoord.y * _Resolution.y;</span><br><span class="line">    <span class="type">float</span> noise_wave_1 = snoise(float2(uv_y * <span class="number">0.01</span>, _Time.y * _Speed * <span class="number">20</span>)) * (strength * _Amount * <span class="number">32.0</span>);</span><br><span class="line">    <span class="type">float</span> noise_wave_2 = snoise(float2(uv_y * <span class="number">0.02</span>, _Time.y * _Speed * <span class="number">10</span>)) * (strength * _Amount * <span class="number">4.0</span>);</span><br><span class="line">    <span class="type">float</span> noise_wave_x = noise_wave_1 * noise_wave_2 / _Resolution.x;</span><br><span class="line">    <span class="type">float</span> uv_x = i.texcoord.x + noise_wave_x;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> rgbSplit_uv_x = (_RGBSplit * <span class="number">50</span> + (<span class="number">20.0</span> * strength + <span class="number">1.0</span>)) * noise_wave_x / _Resolution.x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sample RGB Color</span></span><br><span class="line">    half4 colorG = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(uv_x, i.texcoord.y));</span><br><span class="line">    half4 colorRB = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(uv_x + rgbSplit_uv_x, i.texcoord.y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  half4(colorRB.r, colorG.g, colorRB.b, colorRB.a + colorG.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2><span id="总结">总结</span></h2><h3><span id="故障表现的要点">故障表现的要点</span></h3><ul>
<li>噪声函数的选择：噪声函数是生成各式的干扰信号的源头。</li>
<li>uv抖动方式的选择：将噪声函数作用于屏幕空间uv后，基于新的uv进行采样，以产生故障的抖动表现。</li>
<li>采样通道的选择：对RGB分别采样，或者选取特定通道进行采样，以实现多种风格的故障表现。</li>
<li>颜色空间的转换：善用YUV、CMY、HSV、YIQ、YCbCr 、YC1C2等空间与RGB空间之间的转换，以实现多种风格的故障表现。</li>
</ul>
<h2><span id="参考">参考</span></h2><dir id="refer-anchor">

<p>[1] <a href="https://en.wikipedia.org/wiki/Glitch_art">维基百科</a></p>
<p>[2] <a href="https://zhuanlan.zhihu.com/p/148256756">高品质后处理：十种故障艺术(Glitch Art)算法的总结与实现</a></p>
<p>[3] <a href="https://www.shadertoy.com/view/ldjGzV#">shadertoy</a></p>
<p>[4] <a href="https://awesomeopensource.com/project/keijiro/KinoGlitch">Video glitch effects for Unity - Kinoglitch</a></p>
</dir>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/21/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20MatCap/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-10-20 13:08:42
 * @LastEditTime: 2021-10-20 13:29:39
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\编写中\Unity Shader 学习 MatCap\Unity Shader 学习 MatCap.md
-->
<h1><span id="unity-shader-学习-matcap">Unity Shader 学习 MatCap</span></h1><h2><span id="简介">简介</span></h2><p>MatCap全称MaterailCapture，纹理存储光照信息，通过法线的xy分量去采样MatCap纹理，得到在该方向法线的光照信息，性能好，但表现依靠于纹理制作的好坏。</p>
<h2><span id="实现">实现</span></h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/SimpleMatCapShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _MatCap(&quot;MatCap&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _MatCapFactor(&quot;MatCapFactor&quot;, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">        _EnvTex(&quot;EnvTex (CubeMap)&quot;, Cube) = &quot;_SkyBox&quot; &#123;&#125;</span><br><span class="line">        _EnvFactor(&quot;EnvStrength&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 twoUv : TEXCOORD0;<span class="comment">//主纹理uv存xy,matCapUv存在zw,这算一种优化</span></span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 RefDir : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _MatCap;</span><br><span class="line">            half _MatCapFactor;</span><br><span class="line">            samplerCUBE _EnvTex;</span><br><span class="line">            half _EnvFactor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                o.twoUv.xy = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="comment">//matcap存的其实是：法线中xy分量作为uv，对应的光照颜色信息，即用xy去采样就好，注：xy必须是归一化法线中的分量，故z才没必要</span></span><br><span class="line">                o.twoUv.zw = UnityObjectToWorldNormal(v.normal).xy;</span><br><span class="line">                o.twoUv.zw = o.twoUv.zw * <span class="number">0.5</span> + <span class="number">0.5</span>;<span class="comment">//(-1,1)-&gt;(0,1)</span></span><br><span class="line">                float3 wolrdN = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.RefDir = <span class="built_in">reflect</span>(-WorldSpaceViewDir(v.vertex), wolrdN);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.twoUv.xy);</span><br><span class="line">                fixed4 mapCapCol = tex2D(_MatCap, i.twoUv.zw);</span><br><span class="line">                fixed4 reflection = texCUBE(_EnvTex, i.RefDir);</span><br><span class="line">                col.rgb = col.rgb * mapCapCol.rgb * _MatCapFactor + reflection.rgb * _EnvFactor;</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="问题和思考">问题和思考</span></h2><ol>
<li><p>为什么matcap的图是圆的？</p>
<p> 物体的法线归一化之后可能朝向各个方向(忽略背面)，以顶点为原点,朝向各个方向，就会形成一个半圆。</p>
</li>
<li><p>为什么直接就可以使用法线的xy就可以做uv呢？</p>
</li>
</ol>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://www.cnblogs.com/Tearix/p/6878954.html">尝试MatCap类型shader</a></p>
<p>[2] <a href="https://zhuanlan.zhihu.com/p/43239846">对SSS Matcap贴图的研究 - Chain</a></p>
<p>[3] <a href="https://github.com/emmelleppi/matcaps">MatCaps - A huge library of MatCap textures in PNG and ZMT. - github</a></p>
<p>[4] <a href="https://www.bianchengquan.com/article/236807.html">Matcap Shader 详解【6】-平面渲染与更佳的反射</a>// 需要学习一下</p>
<p>[5] <a href="https://zhuanlan.zhihu.com/p/347947799">matcap 的制作与渲染</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/24/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Normal%20Blend/</url>
    <content><![CDATA[<h1><span id="unity-shader-学习-normal-blend">Unity Shader 学习 Normal Blend</span></h1><p>多张法线贴图叠加的问题的处理办法，<a href="https://blog.selfshadow.com/publications/blending-in-detail/">参考资料</a></p>
<p>目前效果最好的解决办法</p>
<h2><span id="coding">Coding</span></h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 BlendNormal(float3 n1, float3 n2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// float3 t = n1 * float3(2, 2, 2) + float3(-1, -1, 0); // (n1 + 1) / 2</span></span><br><span class="line">    float3 t = n1 + float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);    </span><br><span class="line">    <span class="comment">// float3 u = n2 * float3(-2, -2, 2) + float3(1, 1, -1); // (n2 + 1) / 2</span></span><br><span class="line">    float3 u = n2 * float3(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    float3 r = <span class="built_in">normalize</span>(t * <span class="built_in">dot</span>(t, u) - u * t.z);<span class="comment">// * 0.5 + 0.5;</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/20/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Texture%20Mapping/</url>
    <content><![CDATA[<h1><span id="unity-shader-学习-texture-mapping">Unity Shader 学习 Texture Mapping</span></h1><h2><span id="简介">简介</span></h2><p>Texture Mapping是一种在计算机生成的图形或3D 模型上定义高频细节、表面纹理或颜色信息的方法<sup>[1]</sup>.</p>
<h2><span id="unity中的关于纹理贴图的知识点">Unity中的关于纹理贴图的知识点</span></h2><ul>
<li><p>纹理声明</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST</span><br><span class="line"><span class="comment">// 纹理名_ST 声明的是纹理的缩放和平移，分别存储在 纹理名_ST.xy 和 纹理名_ST.zw</span></span><br></pre></td></tr></table></figure></li>
<li><p>纹理缩放和平移的应用</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br></pre></td></tr></table></figure></li>
<li><p>纹理属性</p>
<ol>
<li><p>Warp Mode </p>
<ul>
<li>Repeat 重复平铺</li>
<li>Clamp 截取</li>
</ul>
</li>
<li><p>Filter Mode </p>
<ul>
<li>Point</li>
<li>Bilinear</li>
<li>Trilinear</li>
</ul>
<p> 滤波效果依次提升，但消耗依次增大。</p>
</li>
<li><p>mipmapping(多级渐远纹理)</p>
<p> 预先计算的的图像序列，目的时为了提高渲染速度，代价时需要额外的存储空间，每个纹理的内存增加33%<sup>[3]</sup>。</p>
</li>
<li><p>纹理长宽需要时二次幂</p>
<p> 如果使用了非二次幂的纹理(NPOT Texture)<sup>[4]</sup>,可能会占用更多的内存空间，GPU读取速度也会有所下降。</p>
</li>
</ol>
</li>
</ul>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://en.wikipedia.org/wiki/Texture_mapping">Texture mapping - wikipedia</a></p>
<p>[2] <a href>Unity Shader 入门精要 - 基础纹理 - 139</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Mipmap">Mipmap - wikipedia</a></p>
<p>[4] <a href="https://www.khronos.org/opengl/wiki/NPOT_Texture">NPOT Texture - wikipedia</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/05/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Tessellation(%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86)/</url>
    <content><![CDATA[<h1><span id="unity-shader-学习-tessellation曲面细分">Unity Shader 学习 Tessellation(曲面细分)</span></h1><h2><span id="简介">简介</span></h2><p>Tessellation，直译的话应该译作”镶嵌化处理技术”，Dx11加入。简单的理解，便是在一个简单的多边形模型中，利用专门的硬件，专门的算法镶嵌入若干多边形，以达到在不耗费CPU资源的情况下，真实的展现曲面的目的。</p>
<h2><span id="关于tessellation-shader">关于Tessellation Shader</span></h2><ul>
<li><h3><span id="应用">应用</span></h3><ul>
<li>海浪，雪地，沙地</li>
<li>置换贴图</li>
</ul>
</li>
<li><h3><span id="tessellation-的应用技术细节">Tessellation 的应用技术细节</span></h3><ul>
<li><h4><span id="渲染流程">渲染流程</span></h4></li>
</ul>
<p>  下图是渲染流程中的Shader顺序：</p>
<p>  <img src="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzEyMTgxMDAxMzE0.png" alt="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzEyMTgxMDAxMzE0.png"></p>
<p>  将Tessellation Shader展开后，请看下图：</p>
<p>  <img src="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzEyMTgxMDU5NzQy.png" alt="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzEyMTgxMDU5NzQy.png"></p>
<p>  也就是说我们要通过 Hull Shader 和 Domain Shader 来控制Tessellation的实现。</p>
<ul>
<li><h5><span id="hull-shader">Hull Shader</span></h5><ul>
<li>负责定义细分等级（LOD）和相关控制点在细分中的“形变”趋势</li>
</ul>
</li>
<li><h5><span id="domain-shader">Domain Shader</span></h5><ul>
<li>对细分后的点进行处理</li>
</ul>
</li>
<li><h4><span id="实例代码">实例代码</span></h4></li>
</ul>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">   Shader &quot;Unlit/Tessellation&quot;</span><br><span class="line">   &#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">	_MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">	Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">	LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	Pass</span><br><span class="line">	&#123;</span><br><span class="line">		CGPROGRAM</span><br><span class="line">		<span class="meta">#pragma vertex tessvert</span></span><br><span class="line">		<span class="meta">#pragma fragment frag</span></span><br><span class="line">		<span class="meta">#pragma hull hs</span></span><br><span class="line">		<span class="meta">#pragma domain ds</span></span><br><span class="line">		<span class="meta">#pragma target 4.6</span></span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">		struct appdata</span><br><span class="line">		&#123;</span><br><span class="line">			float4 vertex : POSITION;</span><br><span class="line">			float4 tangent : TANGENT;</span><br><span class="line">               float3 normal : NORMAL;</span><br><span class="line">               float2 texcoord : TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		struct v2f</span><br><span class="line">		&#123;</span><br><span class="line">			float2 texcoord:TEXCOORD0;</span><br><span class="line">			float4 vertex : SV_POSITION;</span><br><span class="line">			float4 tangent : TANGENT;</span><br><span class="line"> 				float3 normal : NORMAL;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		struct InternalTessInterp_appdata &#123;</span><br><span class="line">		  float4 vertex : INTERNALTESSPOS;</span><br><span class="line">		  float4 tangent : TANGENT;</span><br><span class="line">		  float3 normal : NORMAL;</span><br><span class="line">		  float2 texcoord : TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		float4 _MainTex_ST;</span><br><span class="line">           </span><br><span class="line">		InternalTessInterp_appdata tessvert (appdata v) &#123;</span><br><span class="line">		  InternalTessInterp_appdata o;</span><br><span class="line">		  o.vertex = v.vertex;</span><br><span class="line">		  o.tangent = v.tangent;</span><br><span class="line">		  o.normal = v.normal;</span><br><span class="line">		  o.texcoord = v.texcoord;</span><br><span class="line">		  <span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		v2f vert (appdata v)</span><br><span class="line">		&#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			o.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		UnityTessellationFactors hsconst (InputPatch&lt;InternalTessInterp_appdata,<span class="number">3</span>&gt; v) &#123;</span><br><span class="line">		  UnityTessellationFactors o;</span><br><span class="line">		  float4 tf;</span><br><span class="line">             <span class="comment">//定义曲面细分的参数</span></span><br><span class="line">		  tf = float4(<span class="number">4.0</span>f,<span class="number">4.0</span>f,<span class="number">4.0</span>f,<span class="number">4.0</span>f);</span><br><span class="line">		  o.edge[<span class="number">0</span>] = tf.x; </span><br><span class="line">		  o.edge[<span class="number">1</span>] = tf.y; </span><br><span class="line">		  o.edge[<span class="number">2</span>] = tf.z; </span><br><span class="line">		  o.inside = tf.w;</span><br><span class="line">		  <span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		[UNITY_domain(&quot;tri&quot;)]<span class="comment">//确定图元，quad,triangle等</span></span><br><span class="line">		[UNITY_partitioning(&quot;fractional_odd&quot;)]]<span class="comment">//拆分edge的规则，equal_spacing,fractional_odd,fractional_even</span></span><br><span class="line">		[UNITY_outputtopology(&quot;triangle_cw&quot;)]</span><br><span class="line">		[UNITY_patchconstantfunc(&quot;hsconst&quot;)]<span class="comment">//一个patch一共有三个点，但是这三个点都共用这个函数</span></span><br><span class="line">		[UNITY_outputcontrolpoints(<span class="number">3</span>)]<span class="comment">//不同的图元会对应不同的控制点</span></span><br><span class="line">		InternalTessInterp_appdata hs (InputPatch&lt;InternalTessInterp_appdata,<span class="number">3</span>&gt; v, <span class="type">uint</span> id : SV_OutputControlPointID) &#123;</span><br><span class="line">		  <span class="keyword">return</span> v[id];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		[UNITY_domain(&quot;tri&quot;)]</span><br><span class="line">		v2f ds (UnityTessellationFactors tessFactors, <span class="keyword">const</span> OutputPatch&lt;InternalTessInterp_appdata,<span class="number">3</span>&gt; vi, float3 bary : SV_DomainLocation) &#123;</span><br><span class="line">		  appdata v;</span><br><span class="line"></span><br><span class="line">		  v.vertex = vi[<span class="number">0</span>].vertex*bary.x + vi[<span class="number">1</span>].vertex*bary.y + vi[<span class="number">2</span>].vertex*bary.z;</span><br><span class="line">		  v.tangent = vi[<span class="number">0</span>].tangent*bary.x + vi[<span class="number">1</span>].tangent*bary.y + vi[<span class="number">2</span>].tangent*bary.z;</span><br><span class="line">		  v.normal = vi[<span class="number">0</span>].normal*bary.x + vi[<span class="number">1</span>].normal*bary.y + vi[<span class="number">2</span>].normal*bary.z;</span><br><span class="line">		  v.texcoord = vi[<span class="number">0</span>].texcoord*bary.x + vi[<span class="number">1</span>].texcoord*bary.y + vi[<span class="number">2</span>].texcoord*bary.z;</span><br><span class="line"></span><br><span class="line">		  v2f o = vert (v);</span><br><span class="line">		  <span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		fixed4 frag (v2f i) : SV_Target</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> fixed4(<span class="number">1.0</span>f,<span class="number">1.0</span>f,<span class="number">1.0</span>f,<span class="number">1.0</span>f);</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  根据距离进行不同级别的细分</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">texInput vert(vertexInput0 v)</span><br><span class="line">&#123;</span><br><span class="line">    vertexInput vi;</span><br><span class="line">        //计算距离因子</span><br><span class="line">    float dist = distance(_WorldSpaceCameraPos,mul(unity_ObjectToWorld, v.vertex))/(16*5);</span><br><span class="line">    vi.vertex = v.vertex;</span><br><span class="line">    vi.normal = v.normal;</span><br><span class="line">    vi.tangent = v.tangent;</span><br><span class="line">    float tf = (int)(lerp(5.2, 1.2, clamp(dist, 0.0, 1)));</span><br><span class="line">    if(tf==5)tf=4;</span><br><span class="line">    //tf = ((int)(tf*10))/10.0;</span><br><span class="line">    vi.TessFactor = tf;</span><br><span class="line">    return vi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TessellationFactors patchConstantFunction (InputPatch&lt;vertexInput, 3&gt; patch)</span><br><span class="line">&#123;</span><br><span class="line">    TessellationFactors tf;</span><br><span class="line"></span><br><span class="line">    //tf.edge[0] = _TessellationUniform;</span><br><span class="line">    //tf.edge[1] = _TessellationUniform;</span><br><span class="line">    //tf.edge[2] = _TessellationUniform;</span><br><span class="line">    //tf.inside = _TessellationUniform;</span><br><span class="line"></span><br><span class="line">        //使用基于距离的 Tessellation</span><br><span class="line">    tfTessellation.edge[0] = 0.5fTTTessellation*(patch[1].TessFactor + patch[2].TessFactor);</span><br><span class="line">    tf.edge[1] = 0.5f*(patch[2].TessFactor + patch[0].TessFactor);</span><br><span class="line">    tf.edge[2] = 0.5f*(patch[0].TessFactor + patch[1].TessFactor);</span><br><span class="line">    tf.inside  = tf.edge[0];</span><br><span class="line"></span><br><span class="line">    return tf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/21/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Old%20TV%20Effect/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-10-18 11:01:47
 * @LastEditTime: 2021-10-19 13:08:36
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\Unity Shader 学习 TV Effect\Unity Shader 学习 TV Effect.md
-->
<h1><span id="unity-shader-学习-old-tv-effect">Unity Shader 学习 Old TV Effect</span></h1><h2><span id="简介">简介</span></h2><p>Old TV Effect 即模拟CRT显示器的显示表现，具体表现如下图：</p>
<div align="center">
<img src="crt.gif" height="330" width="495">
</div>

<p>CRT显示器学名为“阴极射线显像管”,是一种使用阴极射线管（Cathode Ray Tube）的显示器。具体显像原理请看<a href="https://en.wikipedia.org/wiki/Cathode-ray_tube">维基百科</a>。</p>
<h2><span id="表现分析">表现分析</span></h2><p>通过各种资料的比对可以将表现分为几大类</p>
<ol>
<li>播放表现</li>
<li>故障表现(另见Unity Shader 学习 Glitch Art)</li>
<li>拍摄表现</li>
</ol>
<h2><span id="实现">实现</span></h2><h3><span id="渐晕效果">渐晕效果</span></h3><ul>
<li><p>实现</p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> Vignette(float2 uv,<span class="type">float</span> time)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> vigAmt = <span class="number">3.0</span> + <span class="number">0.3</span> * <span class="built_in">sin</span>(time + <span class="number">5.0</span> * <span class="built_in">cos</span>(t * <span class="number">5.0</span>));</span><br><span class="line">    <span class="type">float</span> vignette = (<span class="number">1.0</span> - vigAmt * (uv.y - <span class="number">0.5</span>) * (uv.y - <span class="number">0.5</span>)) * (<span class="number">1.0</span> - vigAmt * (uv.x - <span class="number">0.5</span>) * (uv.x - <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> vignette;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <div align="center">
  <img src="Vignette.gif" height="330" width="495">
  </div></li>
</ul>
<h3><span id="畸变">畸变</span></h3><ul>
<li><p>实现</p>
 <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float2 ScreenDistort(float2 uv)</span><br><span class="line">&#123;</span><br><span class="line">    uv -= float2(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    uv = uv * <span class="number">1.2</span> * (<span class="number">1.0</span> / <span class="number">1.2</span> + <span class="number">2.0</span> * uv.x * uv.x * uv.y * uv.y);</span><br><span class="line">    uv += float2(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">return</span> uv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <div align="center">
 <img src="ScreenDistort 0.png" height="330" width="495">
 </div></li>
</ul>
<h3><span id="像素锯齿">像素锯齿</span></h3><pre><code>- 实现
</code></pre>
<h3><span id="边缘的rgb分离">边缘的RGB分离</span></h3><pre><code>- 实现
</code></pre>
<h3><span id="晶体管结构">晶体管结构</span></h3><pre><code>- 实现
</code></pre>
<h3><span id="线扫描">线扫描</span></h3><ul>
<li><p>实现 </p>
  <figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> ScanLine(float2 uv,<span class="type">float</span> freq ,<span class="type">float</span> time)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> frac(uv.y * freq + time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <div align="center">
  <img src="ScanLine.gif" height="330" width="495">
  </div></li>
</ul>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://www.youtube.com/watch?v=jcNJbR85gK0">Old TV Effect in Unity 3D </a></p>
<p>[2] <a href="https://www.shadertoy.com/view/ldjGzV#">VCR distortion </a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Cathode-ray_tube">Cathode-ray tube - Wikipedia</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/09/15/%E7%A8%8B%E5%BA%8F%20%E5%AD%A6%E4%B9%A0%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1><span id="程序-学习-正则表达式">程序 学习 正则表达式</span></h1><h2><span id="目的">目的</span></h2><p>为了处理数据的格式匹配问题，过去的分段式比较过于愚蠢，所以采用正则表达式的方案去进行匹配比较。</p>
<h2><span id="学习资料">学习资料</span></h2><ul>
<li><a href="https://regexr.com/">Untitled Pattern</a></li>
<li><a href="https://c.runoob.com/front-end/854/">正则表达式在线测试</a></li>
<li><a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程</a></li>
</ul>
<h2><span id="常用语法">常用语法</span></h2><ul>
<li>[0-9] 数字</li>
<li>[A-Z] 大写字母</li>
<li>[a-z] 小写字母</li>
<li>^ 首字符匹配</li>
<li>$ 尾字符匹配</li>
<li>+ 多个字符</li>
<li>| 或者</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/24/Unity%20Shader%20%E5%AD%A6%E4%B9%A0%20Texture%20Repetition/</url>
    <content><![CDATA[<h1><span id="unity-shader-学习-texture-repetition">Unity Shader 学习 Texture Repetition</span></h1><h2><span id="目的">目的</span></h2><p>为了解决三向和双向的重复问题</p>
<h2><span id="参考资料">参考资料</span></h2><ul>
<li><a href="https://www.iquilezles.org/www/articles/texturerepetition/texturerepetition.htm">iquilezles</a></li>
<li><a href="http://candycat1992.github.io/2016/11/29/texture-repetition/">消除纹理重复感的两种方法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/66043166">UE4 Shader 简单的消除纹理重复感</a></li>
</ul>
<h2><span id="coding">Coding</span></h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/Biplanar_Texture_Repetition&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _NoramlTex (&quot;Noraml Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _shapek (&quot;shapek&quot;, Range(<span class="number">0</span>,<span class="number">20</span>)) = <span class="number">1</span></span><br><span class="line">        _BlendRatio (&quot;BlendRatio&quot;,Float ) = <span class="number">1</span></span><br><span class="line">        _TriplanarBlendSharpness(&quot;Blend Sharpness&quot;, <span class="type">float</span>)=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 normal   : NORMAL;</span><br><span class="line">                float4 tangent  : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos    : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 posWS    : TEXCOORD1;</span><br><span class="line">                float3 nDirWS   : TEXCOORD2;</span><br><span class="line">                float3 tDirWS   : TEXCOORD3;  <span class="comment">// 世界空间切线方向</span></span><br><span class="line">                float3 bDirWS   : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            Texture2D _MainTex;</span><br><span class="line">            SamplerState sampler_MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            Texture2D _NoramlTex;</span><br><span class="line">            <span class="comment">//sampler2D _MainTex;float4 _MainTex_ST;</span></span><br><span class="line">            <span class="comment">//sampler2D _NoramlTex;</span></span><br><span class="line">            <span class="type">float</span> _shapek;</span><br><span class="line">            <span class="type">float</span> _BlendRatio;</span><br><span class="line">            <span class="type">float</span> _TriplanarBlendSharpness;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos( v.vertex );  </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.posWS = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                o.nDirWS = UnityObjectToWorldNormal(v.normal);  <span class="comment">// 法线方向 OS&gt;WS</span></span><br><span class="line">                o.tDirWS = <span class="built_in">normalize</span>(mul(unity_ObjectToWorld, float4(v.tangent.xyz, <span class="number">0.0</span>)).xyz); <span class="comment">// 切线方向 OS&gt;WS</span></span><br><span class="line">                o.bDirWS = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.nDirWS, o.tDirWS) * v.tangent.w); </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//哈希算法</span></span><br><span class="line">            float4 hash4(float2 p)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="type">float</span> t1 = <span class="number">1.0</span> + <span class="built_in">dot</span>(p, float2(<span class="number">37.0</span>, <span class="number">17.0</span>));</span><br><span class="line">            <span class="type">float</span> t2 = <span class="number">2.0</span> + <span class="built_in">dot</span>(p, float2(<span class="number">11.0</span>, <span class="number">47.0</span>));</span><br><span class="line">            <span class="type">float</span> t3 = <span class="number">3.0</span> + <span class="built_in">dot</span>(p, float2(<span class="number">41.0</span>, <span class="number">29.0</span>));</span><br><span class="line">            <span class="type">float</span> t4 = <span class="number">4.0</span> + <span class="built_in">dot</span>(p, float2(<span class="number">23.0</span>, <span class="number">31.0</span>));</span><br><span class="line">            <span class="keyword">return</span> frac(<span class="built_in">sin</span>(float4(t1, t2, t3, t4)) * <span class="number">103.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除纹理本体</span></span><br><span class="line">            float4 texNoTileTech(Texture2D baseTex, SamplerState baseTexSampler, float2 uv, float2 blendRatio)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// 获取整数部分，即哪个tile</span></span><br><span class="line">            float2 iuv = <span class="built_in">floor</span>(uv);</span><br><span class="line">            <span class="comment">// 获取小数部分，确认采样点在单个tile中的位置</span></span><br><span class="line">            float2 fuv = frac(uv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 产生四次不同的变换</span></span><br><span class="line">            float4 ofa = hash4(iuv + float2(<span class="number">0.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            float4 ofb = hash4(iuv + float2(<span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            float4 ofc = hash4(iuv + float2(<span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">            float4 ofd = hash4(iuv + float2(<span class="number">1.0</span>, <span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算ddx,ddy避免UV跳跃</span></span><br><span class="line">            float2 dx = ddx(uv);</span><br><span class="line">            float2 dy = ddy(uv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 镜像处理</span></span><br><span class="line">            ofa.zw = <span class="built_in">sign</span>(ofa.zw - <span class="number">0.5</span>);</span><br><span class="line">            ofb.zw = <span class="built_in">sign</span>(ofb.zw - <span class="number">0.5</span>);</span><br><span class="line">            ofc.zw = <span class="built_in">sign</span>(ofc.zw - <span class="number">0.5</span>);</span><br><span class="line">            ofd.zw = <span class="built_in">sign</span>(ofd.zw - <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            float2 uva = uv * ofa.zw + ofa.xy, dxa = dx * ofa.zw, dya = dy * ofa.zw;</span><br><span class="line">            float2 uvb = uv * ofb.zw + ofb.xy, dxb = dx * ofb.zw, dyb = dy * ofb.zw;</span><br><span class="line">            float2 uvc = uv * ofc.zw + ofc.xy, dxc = dx * ofc.zw, dyc = dy * ofc.zw;</span><br><span class="line">            float2 uvd = uv * ofd.zw + ofd.xy, dxd = dx * ofd.zw, dyd = dy * ofd.zw;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 采样和混合</span></span><br><span class="line">            float2 b = <span class="built_in">smoothstep</span>(blendRatio, <span class="number">1.0</span> - blendRatio, fuv);</span><br><span class="line"></span><br><span class="line">            float4 sampler1 = baseTex.SampleGrad(baseTexSampler, uva, dxa, dya);</span><br><span class="line">            float4 sampler2 = baseTex.SampleGrad(baseTexSampler, uvb, dxb, dyb);</span><br><span class="line">            float4 sampler3 = baseTex.SampleGrad(baseTexSampler, uvc, dxc, dyc);</span><br><span class="line">            float4 sampler4 = baseTex.SampleGrad(baseTexSampler, uvd, dxd, dyd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lerp(lerp(sampler1, sampler2, b.x), lerp(sampler3, sampler4, b.x), b.y);</span><br><span class="line">            <span class="comment">//return float4(uva,0,0);</span></span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//数据构建</span></span><br><span class="line">                float3 p = i.posWS;</span><br><span class="line">	            float3 dpdx = ddx(p);</span><br><span class="line">                float3 dpdy = ddy(p);</span><br><span class="line">                float3 n = <span class="built_in">abs</span>(i.nDirWS);</span><br><span class="line">                uint3 ma =	(n.x&gt;n.y&amp;&amp;n.x&gt;n.z)	? uint3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">                            (n.y&gt;n.z)			? uint3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>):</span><br><span class="line">                                                  uint3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                uint3 mi =	(n.x&lt;n.y&amp;&amp;n.x&lt;n.z)	? uint3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">                            (n.y&lt;n.z)			? uint3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>):</span><br><span class="line">                                                  uint3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">                uint3 me =	uint3(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)-mi-ma;</span><br><span class="line"></span><br><span class="line">                float2 w = float2(n[ma.x],n[me.x]);</span><br><span class="line">                w = saturate((w<span class="number">-0.5</span>)/(<span class="number">1</span><span class="number">-0.5</span>));</span><br><span class="line">                <span class="type">float</span> k  = _shapek/<span class="number">8.0</span>;</span><br><span class="line">                w = <span class="built_in">pow</span>(w,_TriplanarBlendSharpness);</span><br><span class="line">                w=<span class="built_in">pow</span>(w,float2(k,k));</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                float4 x = _MainTex.SampleGrad(sampler_MainTex,float2(p[ma.y],p[ma.z]),float2(dpdx[ma.y],dpdx[ma.z]),float2(dpdy[ma.y],dpdy[ma.z]));</span><br><span class="line">	            float4 y = _MainTex.SampleGrad(sampler_MainTex,float2(p[me.y],p[me.z]),float2(dpdx[me.y],dpdx[me.z]),float2(dpdy[me.y],dpdy[me.z]));</span><br><span class="line">                <span class="comment">//fixed4 col = tex2D(_MainTex, i.uv);</span></span><br><span class="line">                <span class="comment">//_MainTex.Sample(sampler_MainTex, i.uv);</span></span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line"></span><br><span class="line">                fixed4 cx = texNoTileTech(_MainTex,sampler_MainTex,float2(p[ma.y],p[ma.z]),_BlendRatio);</span><br><span class="line">                fixed4 cy = texNoTileTech(_MainTex,sampler_MainTex,float2(p[me.y],p[me.z]),_BlendRatio);</span><br><span class="line">                float4 col = (cx*w.x+cy*w.y)/(w.x+w.y);</span><br><span class="line">                <span class="comment">//float4 col = (x*w.x+y*w.y)/(w.x+w.y);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//ramp world y</span></span><br><span class="line">                <span class="comment">//NORMAL</span></span><br><span class="line">                </span><br><span class="line">                fixed4 Nx = texNoTileTech(_NoramlTex,sampler_MainTex,float2(p[ma.y],p[ma.z]),_BlendRatio);</span><br><span class="line">                fixed4 Ny = texNoTileTech(_NoramlTex,sampler_MainTex,float2(p[me.y],p[me.z]),_BlendRatio);</span><br><span class="line">                <span class="comment">//float4 Nx = tex2Dgrad(_NoramlTex,float2(p[ma.y],p[ma.z]),float2(dpdx[ma.y],dpdx[ma.z]),float2(dpdy[ma.y],dpdy[ma.z]));</span></span><br><span class="line">	            <span class="comment">//float4 Ny = tex2Dgrad(_NoramlTex,float2(p[me.y],p[me.z]),float2(dpdx[me.y],dpdx[me.z]),float2(dpdy[me.y],dpdy[me.z]));</span></span><br><span class="line">                float3 n1 = UnpackNormal(Nx);</span><br><span class="line">                float3 n2 = UnpackNormal(Ny);</span><br><span class="line"></span><br><span class="line">                float3 nW;</span><br><span class="line">                float3 n1W = float3(n1.y+i.nDirWS[ma.z],n1.x+i.nDirWS[ma.y],<span class="built_in">abs</span>(n1.z)*i.nDirWS[ma.x]);</span><br><span class="line">                float3 n2W = float3(n2.y+i.nDirWS[me.z],n2.x+i.nDirWS[me.y],<span class="built_in">abs</span>(n2.z)*i.nDirWS[me.x]);</span><br><span class="line"></span><br><span class="line">                n1W = float3(n1W[ma.z],n1W[ma.y],n1W[ma.x]);</span><br><span class="line">                n2W = float3(n2W[me.z],n2W[me.y],n2W[me.x]);</span><br><span class="line">                <span class="comment">//nW = normalize(n1*w.x+n2*w.y);</span></span><br><span class="line">                nW = <span class="built_in">normalize</span>(n1W*w.x+n2W*w.y);</span><br><span class="line">                float3 normalT = mul(nW,float3x3(i.tDirWS,i.bDirWS,i.nDirWS));</span><br><span class="line">                half3 lDirWS = _WorldSpaceLightPos0.xyz;</span><br><span class="line"></span><br><span class="line">                half ndotl = <span class="built_in">dot</span>(nW, lDirWS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(col.rgb*ndotl,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/04/Unity%20Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!--
 * @Author: your name
 * @Date: 2021-11-03 13:02:21
 * @LastEditTime: 2021-11-30 13:21:08
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedd:\Private_文档资料\Unity Shader入门精要 读书笔记\Unity Shader入门精要 读书笔记.md
-->
<h1><span id="unity-shader入门精要-读书笔记">Unity Shader入门精要 读书笔记</span></h1><h2><span id="简介">简介</span></h2><p>《Unity Shader入门精要》的作者是冯乐乐，本书是一本在游戏业内广为流传的shader基础入门书籍。</p>
<h2><span id="注意事项">注意事项</span></h2><p>这篇笔记是从第12章开始的，笔记中的代码都是URP管线下的HLSL</p>
<h2><span id="书目">书目</span></h2><ul>
<li>第十二章 屏幕后处理效果</li>
<li>第十三章 使用深度和法线纹理</li>
<li>第十四章 非真实渲染</li>
<li>第十五章 使用噪声</li>
<li>第十六章 Unity中的渲染优化技术</li>
<li>第十七章 Unity的表面着色器探秘</li>
<li>第十八章 基于物理的渲染</li>
<li>第十九章 Unity5 更新了什么</li>
<li>第二十章 还有更多内容么</li>
</ul>
<h2><span id="第十二章-屏幕后处理效果">第十二章 屏幕后处理效果</span></h2><ul>
<li><p>简介</p>
<ul>
<li>屏幕后处理效果（screen post-processing effects）是游戏中实现屏幕特效的常见方法</li>
</ul>
</li>
<li><p>12.1 建立一个基础的屏幕后处理脚本系统</p>
<ul>
<li><p>屏幕后处理：渲染完整个场景得到屏幕图像后，对其进行一系列操作的技术，如：景深，运动模糊，各种故障效果。</p>
</li>
<li><p>后处理的基础基础是获取渲染后的屏幕图像，即抓取屏幕，unity提供了<strong>OnRenderImage</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MonoBehaviour.OnRenderImage(RenderTexture src, RednerTexture dest)</span><br></pre></td></tr></table></figure>
<p>Unity会将当前渲染的图像存储在RenderTexture src，然后函数处理后在输出到RednerTexture dest</p>
<p>通才利用Graphics.Blit函数来处理纹理，函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Blit(Texture src,RenderTexture dest)</span><br><span class="line"></span><br><span class="line">public static void Blit(Texture src,RenderTexture dest,Material mat,int pass = -1)</span><br><span class="line"></span><br><span class="line">public static void Blit(Texture src,Material mat,int pass = -1))</span><br></pre></td></tr></table></figure>
<p>Blit函数调用逻辑：</p>
<ul>
<li>src 是源纹理</li>
<li>dest 是目标渲染纹理,如果为null则直接显示结果</li>
<li>mat 是使用的材质，src会被传递给_MainTex</li>
<li>pass 默认为-1，依次调用pass<br>OnRenderImage函数调用</li>
<li><strong>OnRenderImage</strong>函数会在所有不透明和透明的Pass执行完毕后被调用</li>
<li>如果不想对透明产生应影响 可以在<strong>OnRenderImage</strong>前添加<strong>ImageEffectOpaque</strong><br>Unity实现屏幕后处理的流程</li>
<li>相机添加后处理脚本<ul>
<li>OnRenderImage</li>
<li>Graphics.Blit</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 检查条件脚本</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line">[RequireComponent (typeof(Camera))]</span><br><span class="line">public class PostEffectsBase : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">  // Called when start</span><br><span class="line">  protected void CheckResources() &#123;</span><br><span class="line">    bool isSupported = CheckSupport();</span><br><span class="line">    </span><br><span class="line">    if (isSupported == false) &#123;</span><br><span class="line">      NotSupported();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Called in CheckResources to check support on this platform</span><br><span class="line">  protected bool CheckSupport() &#123;</span><br><span class="line">    if (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) &#123;</span><br><span class="line">      Debug.LogWarning(&quot;This platform does not support image effects or render textures.&quot;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Called when the platform doesn&#x27;t support this effect</span><br><span class="line">  protected void NotSupported() &#123;</span><br><span class="line">    enabled = false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected void Start() &#123;</span><br><span class="line">    CheckResources();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Called when need to create the material used by this effect</span><br><span class="line">  protected Material CheckShaderAndCreateMaterial(Shader shader, Material material) &#123;</span><br><span class="line">    if (shader == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">      return material;</span><br><span class="line">    </span><br><span class="line">    if (!shader.isSupported) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      material = new Material(shader);</span><br><span class="line">      material.hideFlags = HideFlags.DontSave;</span><br><span class="line">      if (material)</span><br><span class="line">        return material;</span><br><span class="line">      else </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.2 调整屏幕亮度，饱和度和对比度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class BrightnessSaturationAndContrast : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader briSatConShader;</span><br><span class="line">    private Material briSatConMaterial;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            return briSatConMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float brightness = 1.0f;</span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float saturation = 1.0f;</span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float contrast = 1.0f;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_Brightness&quot;, brightness);</span><br><span class="line">            material.SetFloat(&quot;_Saturation&quot;, saturation);</span><br><span class="line">            material.SetFloat(&quot;_Contrast&quot;, contrast);</span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上边的脚本用于控制和修改后处理的参数</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/BrightnessSaturationAndContrast&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Base(RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Brightness(&quot;Brightness&quot;,Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Saturation&quot;,Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Contrast&quot;,Float) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                fixed3 finalColor = col.rgb*_Brightness;</span><br><span class="line">                <span class="comment">// 饱和度，灰度像素的值是RGB的加权总和</span></span><br><span class="line">                <span class="comment">// Y = 0.2125 R + 0.7154 G + 0.0721 B</span></span><br><span class="line">                <span class="comment">// https://en.wikipedia.org/wiki/Grayscale</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span>*col.r+<span class="number">0.7154</span>*col.g+<span class="number">0.0721</span>*col.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance,luminance,luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor,finalColor,_Saturation);</span><br><span class="line"></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                finalColor = lerp(avgColor,finalColor,_Contrast); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor,col.a);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该sahder用于修改输入图像的亮度，饱和度和对比度</p>
<ul>
<li>其中关于饱和度就是一个灰度值加权公式具体请看<a href="https://en.wikipedia.org/wiki/Grayscale">Grayscale-Wikipedia</a></li>
</ul>
</li>
<li><p>12.3 边缘检测</p>
<ul>
<li><p>简介</p>
<ul>
<li>边缘检测是描边效果的一种实现方法</li>
<li>边缘检测的原理：<ul>
<li>利用边缘检测算子对图像进行卷积（Convolution）操作</li>
</ul>
</li>
</ul>
</li>
<li><p>12.3.1 什么是卷积</p>
<ul>
<li><p>卷积操作指使用一个卷积核（kernel）对一张图像的每个像素进进行一系列操作</p>
</li>
<li><p>卷积核通常是一个四方形网格结构，该区域每个方格都有一个权重值</p>
<p><img src="%E5%8D%B7%E7%A7%AF.png" alt="卷积.png"></p>
</li>
</ul>
</li>
<li><p>12.3.2 常见的边缘检测算子</p>
<ul>
<li><p>相邻像素之间存在差别明显的颜色，亮度，纹理等属性，这个状态下他们之间就应该有一条边界。</p>
</li>
<li><p>相邻像素之间的差值可以用梯度（gradient）来表示。</p>
<p><img src="%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90.png" alt="边缘检测算子.png"></p>
</li>
</ul>
</li>
<li><p>12.3.3 实现<br>脚本的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetection : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float edgesOnly = 0.0f;</span><br><span class="line"></span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line">            Graphics.Blit(source, destination, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/BrightnessSaturationAndContrast&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Base(RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgesOnly(&quot;EdgesOnly&quot;,Float) = <span class="number">1</span></span><br><span class="line">        _EdgeColor(&quot;EdgeColor&quot;,Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _BackgroundColor(&quot;BackgroundColor&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// UV 定义</span></span><br><span class="line">                float2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            <span class="comment">// 用于访问纹理的每个纹素大小</span></span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">      v2f vert(appdata_img v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        </span><br><span class="line">        half2 uv = v.texcoord;</span><br><span class="line">        </span><br><span class="line">        o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">      &#125;</span><br><span class="line">      fixed luminance(fixed4 color) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用了Sobel算子</span></span><br><span class="line">            half Sobel(v2f i)&#123;</span><br><span class="line">        <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                    <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;	</span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> it=<span class="number">0</span>;it&lt;<span class="number">9</span>;it++)&#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX+=texColor*Gx[it];</span><br><span class="line">                    edgeY+=texColor*Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                half edge = <span class="number">1</span>-<span class="built_in">abs</span>(edgeX)-<span class="built_in">abs</span>(edgeY);</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">      fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">        half edge = Sobel(i);</span><br><span class="line">        </span><br><span class="line">        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">        <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.4 高斯模糊</p>
<ul>
<li><p>简介<br>高斯模糊 通过高斯函数模糊图像的方法叫高斯模糊<sup>[1]</sup></p>
</li>
<li><p>12.4.1<br>高斯函数为 $G(x,y) = \frac{1}{2\pi\sigma^2}e^-{\frac{x^2+y^2}{2\sigma^2}}$</p>
<ul>
<li>$\sigma$ 标准方差</li>
<li>x和y 当前位置到卷积核中心的整数距离</li>
<li>为了图像不变暗，需要高斯核的权重归一化，即每个权重除于所有权重的和。故$e$之前的系数不会对结果造成影响</li>
</ul>
<p>高斯采样如果使用一个NxN的高斯核，需要N * N * W * H次采样</p>
<p>如果使用2个一维函数惊醒采样，只需要 2 * N * W * H 次采样</p>
</li>
<li><p>12.4.2 实现<br>脚本的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class GaussianBlur : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader gaussianBlurShader;</span><br><span class="line">    private Material gaussianBlurMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            return gaussianBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0, 4)]</span><br><span class="line">    public int iterations = 3;</span><br><span class="line"></span><br><span class="line">    [Range(0.2f, 3.0f)]</span><br><span class="line">    public float blurSpread = 0.6f;</span><br><span class="line">    // </span><br><span class="line">    [Range(1, 8)]</span><br><span class="line">    public int downSample = 2;</span><br><span class="line">    // downSample越大需要处理的像素数量越少</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            //降采样优化,过大会像素化</span><br><span class="line">            int rtW = source.width/downSample;</span><br><span class="line">            int rtH = source.height/ downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            // 创建一个buffer</span><br><span class="line">            Graphics.Blit(source, buffer0);</span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f+i*blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 0);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 1);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            Graphics.Blit(buffer0, destination);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            // 释放和缓存</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Shader的实现</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/GaussianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//为了避免重复定义</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">    struct v2f &#123;</span><br><span class="line">      float4 pos : SV_POSITION;</span><br><span class="line">      half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      </span><br><span class="line">      half2 uv = v.texcoord;</span><br><span class="line">      </span><br><span class="line">      o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">      o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      </span><br><span class="line">      half2 uv = v.texcoord;</span><br><span class="line">      </span><br><span class="line">      o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">      o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">      <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">      </span><br><span class="line">      fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">        sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">        sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">    Pass &#123;</span><br><span class="line">      NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">        </span><br><span class="line">      <span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">      <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">        </span><br><span class="line">      ENDCG  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.5 Bloom</p>
<ul>
<li><p>简介<br>Bloom 辉光,模拟真实相机的图像效果，让画面中比较亮的区域“扩散”到周围区域，造成一种朦胧感</p>
<ul>
<li>Bloom实现原理<ul>
<li>根据阈值提取图像中比较亮的区域，存在一个RT中</li>
<li>再使用高斯模糊处理这张RT</li>
<li>与原图像混合<br>后处理脚本的实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Bloom : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader bloomShader;</span><br><span class="line">    private Material bloomMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            return bloomMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0, 4)]</span><br><span class="line">    public int iterations = 3;</span><br><span class="line"></span><br><span class="line">    [Range(0.2f, 3.0f)]</span><br><span class="line">    public float blurSpread = 0.6f;</span><br><span class="line"></span><br><span class="line">    [Range(1, 8)]</span><br><span class="line">    public int downSample = 2;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 4.0f)]</span><br><span class="line">    public float luminanceThreshold = 0.6f;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_LuminanceThreshold&quot;, luminanceThreshold);</span><br><span class="line">            //降采样优化,过大会像素化</span><br><span class="line">            int rtW = source.width / downSample;</span><br><span class="line">            int rtH = source.height / downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            // 创建一个buffer</span><br><span class="line">            Graphics.Blit(source, buffer0, material,0);</span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 1);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 2);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            material.SetTexture(&quot;_Bloom&quot;, buffer0);</span><br><span class="line">            Graphics.Blit(source, destination, material,3);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            // 释放和缓存</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
shader的实现</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/Bloom&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _Bloom (&quot;Bloom&quot;,<span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">    _LuminanceThreshold(&quot;LuminanceThreshold&quot;,Float) = <span class="number">0.5</span></span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">    <span class="type">sampler2D</span> _Bloom;</span><br><span class="line">    <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">    struct v2f &#123;</span><br><span class="line">      float4 pos : SV_POSITION;</span><br><span class="line">      half2 uv: TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line">    v2f vertExtractBrught(appdata_img v)&#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      o.uv = v.texcoord;</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed luminance(fixed4 color) &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">    &#125;</span><br><span class="line">    fixed4 fragExtractBrught(v2f i) : SV_Target&#123;</span><br><span class="line">      fixed4 c = tex2D(_MainTex,i.uv);</span><br><span class="line">      fixed val = <span class="built_in">clamp</span>(luminance(c)-_LuminanceThreshold,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">      <span class="keyword">return</span> c*val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct v2fBloom&#123;</span><br><span class="line">      float4 pos :SV_POSITION;</span><br><span class="line">      half4 uv: TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line">    v2fBloom vertBloom(appdata_img v)&#123;</span><br><span class="line">      v2fBloom o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      o.uv.xy = v.texcoord;</span><br><span class="line">      o.uv.zw = v.texcoord;</span><br><span class="line"></span><br><span class="line">      <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">      <span class="keyword">if</span>(_MainTex_TexelSize.y&lt;<span class="number">0.0</span>)</span><br><span class="line">        o.uv.w = <span class="number">1.0</span>-o.uv.w;</span><br><span class="line">      <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed4 fragBloom(v2fBloom i) :SV_Target&#123;</span><br><span class="line">      <span class="keyword">return</span> tex2D(_MainTex,i.uv.xy)+tex2D(_Bloom,i.uv.zw);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">    Pass &#123;</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">        </span><br><span class="line">      <span class="meta">#pragma vertex vertExtractBrught  </span></span><br><span class="line">      <span class="meta">#pragma fragment fragExtractBrught</span></span><br><span class="line">        </span><br><span class="line">      ENDCG  </span><br><span class="line">    &#125;</span><br><span class="line">    UsePass &quot;Unlit/GaussianBlur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">    UsePass &quot;Unlit/GaussianBlur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">    <span class="comment">//调用指定Shader里的指定pass</span></span><br><span class="line">    <span class="comment">//这个路径是sahder的路径，不是文件夹夹结构</span></span><br><span class="line"></span><br><span class="line">    Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vertBloom</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBloom</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  FallBack off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.6 运动模糊</p>
<ul>
<li>简介<ul>
<li>运动模糊是真实世界的相机的一个效果，当相机曝光时，拍摄场景发生变化，就会发生模糊的画面</li>
<li>运动模糊实现的方法<ul>
<li><ol>
<li>利用累加缓存（accumulation buffer）来混合多张连续的图像，最后取平均值</li>
</ol>
</li>
<li><ol start="2">
<li>创建和使用速度缓存（velocity buffer），存储像素的当前运动速度，利用该值来计算模糊的方向和大小。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>实现，以下时对于第一种方案的实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MotionBlur : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader motionBlurShader;</span><br><span class="line">    private Material motionBlurMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            return motionBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 0.9f)]</span><br><span class="line">    public float blurAmount = 0.5f;</span><br><span class="line">    private RenderTexture accumulationTexture;</span><br><span class="line"></span><br><span class="line">    private void OnDisable()</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(accumulationTexture==null|| accumulationTexture.width!= source.width|| accumulationTexture.height != source.height)</span><br><span class="line">            &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = new RenderTexture(source.width, source.height, 0);</span><br><span class="line">                //隐藏并且不保存</span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(source, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line">            //恢复操作</span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line">            material.SetFloat(&quot;_BlurAmount&quot;, 1.0f-blurAmount);</span><br><span class="line">            Graphics.Blit(source, accumulationTexture,material);</span><br><span class="line">            Graphics.Blit(accumulationTexture, destination);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/MotionBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurAmount(&quot;Blur Amount&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        CGINCLUDE</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            fixed _BlurAmount;</span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            v2f vert(appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 fragRGB(v2f i) :SV_Target&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(tex2D(_MainTex,i.uv).rgb,_BlurAmount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 fragA(v2f i):SV_Target&#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex,i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragRGB</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragA</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.7 拓展阅读</p>
<ul>
<li>Unity Image Effect</li>
<li>GPU Games - GPU Games 3 - 27章</li>
</ul>
</li>
<li><p>总结<br>本章共学习了</p>
<ul>
<li>亮度，饱和度，对比度</li>
<li>边缘检测，后处理描边</li>
<li>高斯模糊</li>
<li>辉光</li>
<li>运动模糊<h2><span id="第十三章-使用深度和法线纹理">第十三章 使用深度和法线纹理</span></h2></li>
</ul>
</li>
<li><p>13.1 获取深度和法线纹理</p>
<ul>
<li><p>13.1.1 背后的原理</p>
<ul>
<li>深度纹理<ul>
<li>深度纹理是一张渲染纹理，存储的是高精度的深度值</li>
<li>深度值范围是[0,1],但通常是非线性分布的。</li>
<li>通过MVP获得</li>
</ul>
</li>
<li>Unity如何获取深度纹理<ul>
<li><ol>
<li>延迟渲染，再G-buffer中</li>
</ol>
</li>
<li><ol start="2">
<li>使用着色器替换技术选择渲染类型为Qpaque的物体，若渲染队列小于等于2500，就渲染到深度和法线中</li>
</ol>
</li>
</ul>
</li>
<li>存储位置<ul>
<li>观察空间下，法线存储在R,G</li>
<li>观察空间下，深度存储在B，A</li>
</ul>
</li>
</ul>
</li>
<li><p>13.1.2 如何获取</p>
<ul>
<li><p>获取深度纹理的方法</p>
<ul>
<li><ol>
<li>在脚本中设置摄像机的depthTextureMode<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>Shader中使用“_CameraDepthTexture”来访问它</li>
</ol>
</li>
</ul>
</li>
<li><p>获取深度和法线纹理 </p>
<ul>
<li><ol>
<li>在脚本中设置摄像机的depthTextureMode<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>Shader中使用“_CameraDepthNoramlsTexture”来访问它</li>
</ol>
</li>
</ul>
</li>
<li><p>如何采样该纹理</p>
<ul>
<li>可以使用 tex2D</li>
<li>也可以用宏 SAMPLE_DEPTH_TEXTURE</li>
</ul>
</li>
<li><p>宏 SAMPLE_DEPTH_TEXTURE_PROJ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// i.srcPos 屏幕坐标 ComputeScreenPos(o.pos)</span><br><span class="line">float result = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture,UNITY_PROJ_COORD(i.srcPos));</span><br></pre></td></tr></table></figure>
<ul>
<li>更多的信息可以在HLSLSupport.cginc 看到</li>
</ul>
</li>
<li><p>如何将深度纹理中的深度信息计算得到视角空间下的深度值</p>
<ul>
<li>推导过程<ul>
<li>裁剪矩阵$P_{clip}$对视角空间的顶点变换，裁剪空间下顶点的$z$和$w$如下：<ul>
<li>$Z_{clip}=-Z_{view}\frac{Far+Near}{Far-Near}-\frac{2 \cdot Far \cdot Near}{Far-Near}$</li>
<li>$w_{clip} = -Z_{view}$<ul>
<li>$Far$远裁剪平面距离</li>
<li>$Near$近裁剪平面距离</li>
</ul>
</li>
</ul>
</li>
<li>通过齐次除法获得NDC的$z$分量<ul>
<li>$z_{ndc} = \frac {z_{clip}}{w_{clip}} = \frac{Far+Near}{Far-Near}+\frac{2Near \cdot Far}{(Far-Near) \cdot z_{view}}$</li>
</ul>
</li>
<li>深度值计算<ul>
<li>$d = 0.5z_{ndc}+0.5$ </li>
</ul>
</li>
<li>通过如上公式获得<ul>
<li>$z_{view} = \frac{1}{\frac{Far-Near}{Near \cdot Far}d+\frac{1}{Near}}$</li>
</ul>
</li>
<li>Unity时间空间中摄像机正向为-z，因此结果取反<ul>
<li>$z_{view} = \frac{1}{\frac{Near-Far}{Near \cdot Far}d+\frac{1}{Near}}$</li>
</ul>
</li>
<li>当0表示该点与摄像机同一位置，1表示该点位于视锥体的远裁剪平面<ul>
<li>$z_{01} = \frac{1}{\frac{Near-Far}{Near}d+\frac{Far}{Near}}$</li>
</ul>
</li>
</ul>
</li>
<li>Unity 提供的转换函数<ul>
<li>LinearEyeDepth:将深度纹理的采样结果转换到视角空间下的深度值</li>
<li>Linear01EyeDepth：返回一个0到1的线性深度值<ul>
<li>内置变量 _ZBufferParams：获得远近裁剪平面的距离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何获得深度+法线纹理</p>
<ul>
<li>tex2D 采样_CameraDepthNoramlsTexture</li>
<li>信息解码函数如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline void DecodeDepthNoraml(float4 enc,out float depth , ouyt float3 normal)&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.zw);</span><br><span class="line">    noraml = DecodeViewNoramlStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得深度值是0到1的线性深度值</li>
<li>法线是视角空间下的法线</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>13.1.3 查看深度和法线纹理</p>
<ul>
<li>如何查看生成的深度和法线纹理<ul>
<li>Frame Debugger</li>
<li>RenderDoc</li>
</ul>
</li>
<li>输出线性空间或者转码后的法线和深度信息<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv);</span><br><span class="line">floar linearDepth = Linear01Depth(depth);</span><br><span class="line"><span class="keyword">return</span> fixed4(linearDepth,linearDepth,linearDepth,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float3 noraml = DecodeViewNoramlStereo(tex2D(_CameraNoramlsTexture,i.uv).xy);</span><br><span class="line">return fixed4(noraml*0.5+0.5,1.0);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>13.2 再谈运动模糊</p>
<ul>
<li><p>Gpu Gems3中提到的方案</p>
<ul>
<li><p>实现逻辑</p>
<ul>
<li>利用深度纹理再片元着色器中计算像素的世界空间位置</li>
<li>使用前一帧的视角*投影矩阵把变换获得的前一帧的NDC左边</li>
<li>计算前一帧和当前帧的位置差，生成速度</li>
</ul>
</li>
<li><p>优点</p>
<p>可以再一个后处理中完成整个模拟</p>
</li>
<li><p>缺点</p>
<p>片元进行了2次矩阵，性能有所影响</p>
</li>
</ul>
</li>
<li><p>实现<br>后处理脚本实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MotionBlurWithDepthTexture : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader motionBlurShader;</span><br><span class="line">    private Material motionBlurMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            return motionBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float blurSize = 0.5f;</span><br><span class="line">    private Camera myCamera;</span><br><span class="line">    public Camera camera</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (myCamera == null)</span><br><span class="line">            &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            return myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_BlurSize&quot;, blurSize);</span><br><span class="line">            material.SetMatrix(&quot;_previousViewProjectionMatrix&quot;, previousViewProjectionMatrix);</span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            // worldToCameraMatrix 摄像机的视角矩阵</span><br><span class="line">            // projectionMatrix 摄像机的投影矩阵</span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            material.SetMatrix(&quot;_CurrentViewProjectionInverseMatrix&quot;, currentViewProjectionInverseMatrix);</span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;</span><br><span class="line">            Graphics.Blit(source, destination, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Shader实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/MotionBlurWithDepthTexture&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;,Float) = 1.0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            half _BlurSize;</span><br><span class="line">            sampler2D _CameraDepthTexture;</span><br><span class="line">            float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">            float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos :SV_POSITION;</span><br><span class="line">                half2 uv:TEXCOORD0;</span><br><span class="line">                half2 uv_depth:TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            v2f vert(appdata_img v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                o.uv_depth = v.texcoord;</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                    o.uv_depth.y = 1-o.uv_depth.y;</span><br><span class="line">                #endif</span><br><span class="line">                //处理兼容问题</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">                float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv_depth);</span><br><span class="line">                float4 H = float4(i.uv.x*2-1,i.uv.y*2-1,d*2-1,1);</span><br><span class="line">                float4 D = mul(_CurrentViewProjectionInverseMatrix,H);</span><br><span class="line">                float4 worldPos = D/D.w;</span><br><span class="line">                float4 currentPos = H;</span><br><span class="line">                float4 previousPos = mul(_PreviousViewProjectionMatrix,worldPos);</span><br><span class="line">                previousPos/=previousPos.w;</span><br><span class="line">                float2 veloctiy = (currentPos.xy-previousPos.xy)/2.0f;</span><br><span class="line"></span><br><span class="line">                float2 uv = i.uv;</span><br><span class="line">                float4 c = tex2D(_MainTex,uv);</span><br><span class="line">                uv+=veloctiy*_BlurSize;</span><br><span class="line">                for(int it=1;it&lt;3;it++,uv+=veloctiy*_BlurSize)&#123;</span><br><span class="line">                </span><br><span class="line">                    float4 currentColor = tex2D(_MainTex,uv);</span><br><span class="line">                    c+=currentColor;</span><br><span class="line">                &#125;</span><br><span class="line">                c/=3;</span><br><span class="line">                return fixed4(c.rgb,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>13.3 全局雾效</p>
<ul>
<li><p>简介</p>
<ul>
<li>雾效（Fog）是游戏中常见的一种效果</li>
<li>基于屏幕后处理的全局雾效的核心，根据深度纹理重建每个像素在世界空间下的位置<ul>
<li>首先对图像空间下的视锥体射线进行插值，射线存储的是该像素在世界空间下到摄像机的方向信息</li>
<li>把该射线和线性化后的视角空间下的深度值相乘，加上摄像机的世界位置，获得该像素的在世界空间的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>13.3.1 重建世界坐标</p>
<ul>
<li><p>如何从深度纹理中重建世界坐标</p>
<ul>
<li><p>思想：坐标系中的顶点位置可以通过它相对于另一个顶点坐标的偏移量获得。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 worldPos = _WorldSpaceCameraPos+linearDepth*interpolatedRay;</span><br><span class="line">// _WorldSpaceCameraPos 摄像机世界空间位置</span><br><span class="line">// linearDepth*interpolatedRay 像素对于相机的偏移量</span><br></pre></td></tr></table></figure>
<ul>
<li><p>interpolatedRay 的获得方法</p>
<ul>
<li><p>interpolatedRay是近裁剪平面4个角的某个特定向量的插值，这4个向量包含了它们到摄像机的距离和方向信息</p>
</li>
<li><p>可以利用摄像机近裁剪平面距离，Fov,纵横比计算获得</p>
</li>
<li><p>toTop 和 toRight 计算公式如下，他们是起点位于近裁剪平面中心，分别指向摄像机正上方和正右方的向量</p>
<ul>
<li>$halfHeight = Near \times \tan(\frac{FOV}{2})$</li>
<li>$toTop = camera.up \times halfHeight$</li>
<li>$toRight = camera.right \times halfHeight \cdot aspect$<ul>
<li>Near 是近裁剪平面距离</li>
<li>FOV 是竖直方向视角范围</li>
<li>camera.up 摄像机正上方</li>
<li>camera.right 摄像机的正右方</li>
</ul>
</li>
</ul>
</li>
<li><p>四个角相对于摄像机的位置的计算公式</p>
<ul>
<li>$TL=camera.forward \cdot Near +toTop-toRight$</li>
<li>$TR=camera.forward \cdot Near +toTop+toRight$</li>
<li>$BL=camera.forward \cdot Near -toTop-toRight$</li>
<li>$BR=camera.forward \cdot Near -toTop+toRight$</li>
</ul>
</li>
<li><p>以上的数据为Z方向上的距离，将深度转为摄像机的欧式距离如下</p>
<ul>
<li>根据相似三角形 TL所在的射线上，像素的深度值和它到摄像机的实际距离比等于近裁剪平面的距离和TL向量的摸的比<ul>
<li>$\frac{depth}{dist} = \frac{Near}{|TL|}$</li>
</ul>
</li>
<li>所以距离如下<ul>
<li>$dist = \frac{|TL|}{Near} \times depth$</li>
</ul>
</li>
</ul>
</li>
<li><p>由于4个点对称，因此模长相同，所以我们用单一的因子进行计算</p>
<ul>
<li>$scale = \frac{|TL|}{|Near|}$</li>
<li>$Ray_{TL}= \frac{TL}{|TL|} \times scale$</li>
<li>$Ray_{TR}= \frac{TR}{|TR|} \times scale$</li>
<li>$Ray_{BL}= \frac{BL}{|BL|} \times scale$</li>
<li>$Ray_{BR}= \frac{BR}{|BR|} \times scale$</li>
</ul>
</li>
<li><p>相关的示意图如下</p>
<p><img src="interpolatedRay.png" alt="interpolatedRay.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>13.3.2 雾的计算</p>
<ul>
<li>首先需要一个雾效系数，作为混合系数<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 afterFog = f*fogColor +(<span class="number">1</span>-f)*origColor;</span><br></pre></td></tr></table></figure>
<ul>
<li>内置的雾效计算方式<ul>
<li>线性（Linear）<ul>
<li>$f = \frac{d_{max}-|z|}{d_{max}-d_{min}}$<ul>
<li>$d_{max}$雾的最大影响范围</li>
<li>$d_{min}$雾的最小影响范围</li>
</ul>
</li>
</ul>
</li>
<li>指数（Exponential）<ul>
<li>$f=e^{-d\cdot|z|}$<ul>
<li>d 是是控制雾浓度的值</li>
</ul>
</li>
</ul>
</li>
<li>指数的平方（Exponential Squared）<ul>
<li>$f = e^{-(d-|z|)^2}$<ul>
<li>d 是是控制雾浓度的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类似线性雾的计算方式，基于高度的雾效<ul>
<li>给定一个点的世界空间下的高度y</li>
<li>公式<ul>
<li>$f = \frac{H_{end}-y}{H_{end}-H_{start}}$<ul>
<li>$H_{end}$ 雾影响的终止高度</li>
<li>$H_{start}$ 雾影响的起始高度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>13.3.3 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class FogWithDepthTexture : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    public Shader fogShader;</span><br><span class="line">    private Material fogMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            return fogMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Camera myCamera;</span><br><span class="line">    public Camera camera</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (myCamera == null)</span><br><span class="line">            &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            return myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Transform myCameraTransform;</span><br><span class="line">    public Transform cameraTransform</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (myCameraTransform == null)</span><br><span class="line">            &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            return myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float fogDensity = 1.0f;</span><br><span class="line"></span><br><span class="line">    public Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    public float fogStart = 0.0f;</span><br><span class="line">    public float fogEnd = 2.0f;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Matrix4x4 frustumCormers = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            float fov = camera.fieldOfView;</span><br><span class="line">            float near = camera.nearClipPlane;</span><br><span class="line">            float far = camera.farClipPlane;</span><br><span class="line">            float aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            float halfHeight = near * Mathf.Tan(fov * 0.5f * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            float sacle = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= sacle;</span><br><span class="line"></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toTop + toRight;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= sacle;</span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= sacle;</span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near - toTop + toRight;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= sacle;</span><br><span class="line"></span><br><span class="line">            frustumCormers.SetRow(0, bottomLeft);</span><br><span class="line">            frustumCormers.SetRow(1, bottomRight);</span><br><span class="line">            frustumCormers.SetRow(2, topRight);</span><br><span class="line">            frustumCormers.SetRow(3, topLeft);</span><br><span class="line">            //将向量存储到矩阵中</span><br><span class="line">            material.SetMatrix(&quot;_FrustumCormers&quot;, frustumCormers);</span><br><span class="line">            material.SetMatrix(&quot;_ViewProjectionInverseMatrix&quot;, (camera.projectionMatrix * camera.worldToCameraMatrix).inverse);</span><br><span class="line">            material.SetFloat(&quot;_FogDensity&quot;, fogDensity);</span><br><span class="line">            material.SetColor(&quot;_FogColor&quot;, fogColor);</span><br><span class="line">            material.SetFloat(&quot;_FogStart&quot;, fogStart);</span><br><span class="line">            material.SetFloat(&quot;_FogEnd&quot;, fogEnd);</span><br><span class="line">            Graphics.Blit(source, destination,material);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/FogWithDepthTexture&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity(&quot;Fog Density&quot;,Float) = 1.0</span><br><span class="line">        _FogColor(&quot;Fog Color&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _FogStart(&quot;Fog Start&quot;,Float) = 0.0</span><br><span class="line">        _FogEnd(&quot;Fog End&quot;,Float) = 1.0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            sampler2D _CameraDepthTexture;</span><br><span class="line">            half _FogDensity;</span><br><span class="line">            fixed4 _FogColor;</span><br><span class="line">            float _FogStart;</span><br><span class="line">            float _FogEnd;</span><br><span class="line">            float4x4 _FrustumCormers;</span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos :SV_POSITION;</span><br><span class="line">                half2 uv :TEXCOORD0;</span><br><span class="line">                half2 uv_depth :TEXCOORD1;</span><br><span class="line">                float4 interpolatedRay :TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                o.uv_depth = v.texcoord;</span><br><span class="line">                // 平台兼容</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                    o.uv_depth.y=1-o.uv_depth.y;</span><br><span class="line">                #endif</span><br><span class="line">                //坐标索引判断</span><br><span class="line">                int index = 0;</span><br><span class="line">                if(v.texcoord.x&lt;0.5 &amp;&amp; v.texcoord.y&lt;0.5)&#123;</span><br><span class="line">                    index=0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(v.texcoord.x&gt;0.5 &amp;&amp; v.texcoord.y&lt;0.5)&#123;</span><br><span class="line">                    index=1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(v.texcoord.x&gt;0.5 &amp;&amp; v.texcoord.y&gt;0.5)&#123;</span><br><span class="line">                    index=2;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    index=3;</span><br><span class="line">                &#125;</span><br><span class="line">                // 平台兼容</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                    if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                        index = 3- index;</span><br><span class="line">                #endif</span><br><span class="line">                o.interpolatedRay = _FrustumCormers[index];</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag(v2f i) :SV_Target&#123;</span><br><span class="line">                float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv_depth));</span><br><span class="line">                float3 worldPos = _WorldSpaceCameraPos+linearDepth*i.interpolatedRay.xyz;</span><br><span class="line">                float fogDensity = (_FogEnd-worldPos.y)/(_FogEnd-_FogStart);</span><br><span class="line">                fogDensity=saturate(fogDensity*_FogDensity);</span><br><span class="line">                fixed4 finalColor = tex2D(_MainTex,i.uv);</span><br><span class="line">                finalColor.rgb = lerp(finalColor.rgb,_FogColor,fogDensity);</span><br><span class="line"></span><br><span class="line">                return finalColor;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>13.4 再谈边缘检测</p>
<ul>
<li><p>简介</p>
<ul>
<li><p>使用深度纹理进行边缘检测更可靠，对比效果如下</p>
<p><img src="%E5%86%8D%E8%B0%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.png" alt="再谈边缘检测.png"></p>
</li>
<li><p>本章使用 Roberts 算子</p>
<ul>
<li>Roberts本质是计算左上角和右下角的插值，乘于右上角和左下角的插值      </li>
</ul>
</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetectNoramlsAndDepth : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float edgesOnly = 0.0f;</span><br><span class="line"></span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line">    public float sampleDistance = 1.0f;</span><br><span class="line">    // 采样距离，值越大，描边越宽</span><br><span class="line">    public float sensitivityDepth = 1.0f;</span><br><span class="line">    public float sensitivityNormals = 1.0f;</span><br><span class="line">    //权重</span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;   </span><br><span class="line">    &#125;</span><br><span class="line">    [ImageEffectOpaque]//定义仅影响不透明物体</span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line">            material.SetFloat(&quot;_SampleDistance&quot;, sampleDistance);</span><br><span class="line">            material.SetVector(&quot;_Sensitivity&quot;, new Vector4(sensitivityDepth, sensitivityNormals,0.0f,0.0f));</span><br><span class="line">            Graphics.Blit(source, destination, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/EdgeDetectNoramlsAndDepth&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Base(RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly(&quot;EdgeOnly&quot;,Float) = 1</span><br><span class="line">        _EdgeColor(&quot;EdgeColor&quot;,Color) = (0,0,0,1)</span><br><span class="line">        _BackgroundColor(&quot;BackgroundColor&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _SampleDistance(&quot;Sample Distance&quot;,Float) = 1.0</span><br><span class="line">        _Sensitivity(&quot;Sensitivity&quot;,Vector) = (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            // 用于访问纹理的每个纹素大小</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            float _SampleDistance;</span><br><span class="line">            half4 _Sensitivity;</span><br><span class="line">            sampler2D _CameraDepthNormalsTexture;</span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                half2 uv[5] :TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            v2f vert(appdata_img v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                o.uv[0]=uv;</span><br><span class="line">                //平台兼容</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                    uv.y=1-uv.y;</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                o.uv[1] = uv+_MainTex_TexelSize.xy*half2(1,1)*_SampleDistance;</span><br><span class="line">                o.uv[2] = uv+_MainTex_TexelSize.xy*half2(-1,-1)*_SampleDistance;</span><br><span class="line">                o.uv[3] = uv+_MainTex_TexelSize.xy*half2(-1,1)*_SampleDistance;</span><br><span class="line">                o.uv[4] = uv+_MainTex_TexelSize.xy*half2(1,-1)*_SampleDistance;</span><br><span class="line">                // 纹理坐标数据</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            half CheckSame(half4 center,half4 sample)&#123;</span><br><span class="line">                half2 centerNoraml = center.xy;</span><br><span class="line">                float centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">                half2 sampleNoraml = sample.xy;</span><br><span class="line">                float sampleDepth = DecodeFloatRG(sample.zw);</span><br><span class="line"></span><br><span class="line">                half2 diffNoraml = abs(centerNoraml-sampleNoraml)*_Sensitivity.x;</span><br><span class="line">                int isSameNoraml = (diffNoraml.x+diffNoraml.y)&lt;0.1;</span><br><span class="line">                float diffDepth = abs(centerDepth-sampleDepth)*_Sensitivity.y;</span><br><span class="line">                int isSameDepth = diffDepth&lt;0.1*centerDepth;</span><br><span class="line"></span><br><span class="line">                return isSameNoraml*isSameDepth ? 1.0:0.0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            fixed4 fragRobertsCrossDepthAndNormal(v2f i) :SV_Target&#123;</span><br><span class="line">                half4 sample1 = tex2D(_CameraDepthNormalsTexture,i.uv[1]);</span><br><span class="line">                half4 sample2 = tex2D(_CameraDepthNormalsTexture,i.uv[2]);</span><br><span class="line">                half4 sample3 = tex2D(_CameraDepthNormalsTexture,i.uv[3]);</span><br><span class="line">                half4 sample4 = tex2D(_CameraDepthNormalsTexture,i.uv[4]);</span><br><span class="line"></span><br><span class="line">                half edge = 1.0;</span><br><span class="line"></span><br><span class="line">                edge*=CheckSame(sample1,sample2);</span><br><span class="line">                edge*=CheckSame(sample3,sample4);</span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor,tex2D(_MainTex,i.uv[0]),edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor,_BackgroundColor,edge);</span><br><span class="line"></span><br><span class="line">                return lerp(withEdgeColor,onlyEdgeColor,_EdgeOnly);</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment fragRobertsCrossDepthAndNormal</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>这是全局的后处理描边</p>
</li>
<li><p>特定物体描边 需要使用 Graphics.DrawMesh或者Graphics.DrawMeshNow</p>
</li>
</ul>
</li>
<li><p>13.5 拓展阅读</p>
<ul>
<li>SIGGRAPH 2011 Unity 有一篇关于利用深度纹理制作各种特效的演讲</li>
<li>Unity 的Image Effect 中包含了许多相关的特效，例如屏幕空间环境遮蔽（SSAO）</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>本章学习了<ul>
<li>基于深度的运动模糊</li>
<li>全局雾效</li>
<li>基于深度的描边<h2><span id="第十四章-非真实渲染">第十四章 非真实渲染</span></h2></li>
</ul>
</li>
</ul>
</li>
<li><p>简介</p>
<ul>
<li>非真实渲染（Non-Photorealistic Rendering,NPR）使用一些方法让画面达到某种特殊绘画风格类似的效果</li>
</ul>
</li>
<li><p>14.1 卡通风格的渲染</p>
<ul>
<li><p>简介</p>
<ul>
<li>卡通渲染的特点：<ul>
<li>描边</li>
<li>分明的变换</li>
</ul>
</li>
<li>技术简介：<ul>
<li>基于色调的作色技术（tone-based shading）,1998年Gooch提出的</li>
</ul>
</li>
</ul>
</li>
<li><p>14.1.1 渲染轮廓线</p>
<ul>
<li><p>渲染轮廓线的方案</p>
<ul>
<li>基于观察角度和表面法线的轮廓线渲染</li>
<li>过程式几何轮廓线渲染</li>
<li>基于图像处理的轮廓线渲染</li>
<li>基于轮廓边检测的轮廓线渲染</li>
<li>混合以上的方案</li>
</ul>
</li>
<li><p>本章的方案是 过程式几何轮廓线渲染</p>
<ul>
<li><p>双Pass，第一个pass渲染背面，然后在视角空间下沿法线方向扩张，另一个pass渲染正面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewPos = viewPos +viewNormal *_Outline;</span><br></pre></td></tr></table></figure></li>
<li><p>为了处理一些内凹的模型，背面面片遮挡正面面片的情况，需要处理法线的Z分量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewNormal.z = -0.5;</span><br><span class="line">viewNormal = normalize(viewNormal);</span><br><span class="line">viewPos = viewPos + viewNormal * _Outline;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>14.1.2 添加高光</p>
<ul>
<li><p>和Blinn-Phong 不同，需要进行阈值比较，小于阈值，反射系数为0，否则返回1.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float spec = dot(worldNoraml,worldHalfDir);</span><br><span class="line">spec = step(threshold,spec);</span><br></pre></td></tr></table></figure></li>
<li><p>抗锯齿优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float spec = dot(worldNoraml,worldHalfDir);</span><br><span class="line">spec = lerp(0,1,smppthstep(-w,w,spec-threshold));</span><br></pre></td></tr></table></figure></li>
<li><p>拓展参考</p>
<ul>
<li>风格化高光参考：2003年 ANJYO</li>
<li><a href="https://blog.csdn.net/candycat1992/article/details/47284289">https://blog.csdn.net/candycat1992/article/details/47284289</a></li>
</ul>
</li>
</ul>
</li>
<li><p>14.1.3 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Toon&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Ramp (&quot;Ramp Texture&quot;,2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Outline (&quot;Outline&quot;,Range(0,1)) = 0.1</span><br><span class="line">        _OutlineColor (&quot;Outline Color&quot;,Color) = (0,0,0,1)</span><br><span class="line">        _Specular (&quot;Spacular&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _SpecularScale (&quot;Spacular Scale&quot;,Range(0,0.1)) = 0.01</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        pass&#123;</span><br><span class="line">            NAME &quot;OUTLINE&quot;//定义名称为了以后调用</span><br><span class="line">            Cull Front</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            float _Outline;</span><br><span class="line">      fixed4 _OutlineColor;</span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                float3 normal :NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">      v2f vert (a2v v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        </span><br><span class="line">        float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">        float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  </span><br><span class="line">        normal.z = -0.5;</span><br><span class="line">        pos = pos + float4(normalize(normal), 0) * _Outline;</span><br><span class="line">        o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">      &#125;</span><br><span class="line">            float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                return float4(_OutlineColor.rgb,1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">      #include &quot;AutoLight.cginc&quot;</span><br><span class="line">      #include &quot;UnityShaderVariables.cginc&quot;</span><br><span class="line">      fixed4 _Color;</span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      float4 _MainTex_ST;</span><br><span class="line">      sampler2D _Ramp;</span><br><span class="line">      fixed4 _Specular;</span><br><span class="line">      fixed _SpecularScale;</span><br><span class="line"></span><br><span class="line">            struct a2v &#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float3 normal : NORMAL;</span><br><span class="line">        float4 texcoord : TEXCOORD0;</span><br><span class="line">        float4 tangent : TANGENT;</span><br><span class="line">      &#125;; </span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">                float3 worldNormal :TEXCOORD1;</span><br><span class="line">                float3 worldPos :TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(3)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f vert (a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal = mul(v.normal,(float3x3)unity_ObjectToWorld);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW (o);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">        fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">        fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">        fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);</span><br><span class="line"></span><br><span class="line">                fixed4 c = tex2D(_MainTex,i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb*_Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line"></span><br><span class="line">                fixed diff = dot(worldNormal,worldLightDir);</span><br><span class="line">                diff=(diff*0.5+0.5)*atten;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo*tex2D(_Ramp,float2(diff,diff)).rgb;</span><br><span class="line"></span><br><span class="line">                fixed spec = dot(worldNormal,worldHalfDir);</span><br><span class="line">                fixed w = fwidth(spec)*2.0;</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient+diffuse+specular,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>14.2 素描风格的渲染</p>
<ul>
<li><p>简介 </p>
<ul>
<li>2001年，微软研究院的Praum等人在SIGGRAPH提出</li>
<li>色调艺术映射（Tonal Art Map,TAM）</li>
</ul>
</li>
<li><p>实现思路</p>
<ul>
<li>使用6张素描纹理进行渲染</li>
<li>根据光照结果来决定6张纹理的混合权重</li>
<li>在片元中根据权重混合采样结果</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Hatching&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _TileFactor (&quot;Tile Factor&quot;,Float) = 1</span><br><span class="line">        _Outline(&quot;Outline&quot;,Range(0,1)) = 0.1</span><br><span class="line">        _Hatch0 (&quot;Hatch 0&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch1 (&quot;Hatch 1&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch2 (&quot;Hatch 2&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch3 (&quot;Hatch 3&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch4 (&quot;Hatch 4&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch5 (&quot;Hatch 5&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Opaque&quot; =&quot;Geometry&quot;&#125;</span><br><span class="line">        UsePass &quot;Unlit/Toon/OUTLINE&quot;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">      #include &quot;AutoLight.cginc&quot;</span><br><span class="line">      #include &quot;UnityShaderVariables.cginc&quot;</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                //float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">        float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                fixed3 hatchWeights0 :TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 :TEXCOORD2;</span><br><span class="line">                float3 worldPos :TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(4)</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _TileFactor;</span><br><span class="line">            fixed _Outline;</span><br><span class="line">            sampler2D _Hatch0;</span><br><span class="line">            sampler2D _Hatch1;</span><br><span class="line">            sampler2D _Hatch2;</span><br><span class="line">            sampler2D _Hatch3;</span><br><span class="line">            sampler2D _Hatch4;</span><br><span class="line">            sampler2D _Hatch5;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord.xy*_TileFactor;</span><br><span class="line">                fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNoraml = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = max(0,dot(worldLightDir,worldNoraml));</span><br><span class="line">                o.hatchWeights0 = fixed3(0,0,0);</span><br><span class="line">                o.hatchWeights1 = fixed3(0,0,0);</span><br><span class="line">                float hatchFactor = diff*7.0;</span><br><span class="line">                if(hatchFactor&gt;6.0)&#123;</span><br><span class="line">                    //</span><br><span class="line">                &#125;else if(hatchFactor&gt;5.0)&#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor-5.0;</span><br><span class="line">                &#125;else if(hatchFactor&gt;4.0)&#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor-4.0;</span><br><span class="line">                    o.hatchWeights0.y = 1- o.hatchWeights0.x;</span><br><span class="line">                &#125;else if(hatchFactor&gt;3.0)&#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor-3.0;</span><br><span class="line">                    o.hatchWeights0.z = 1.0- o.hatchWeights0.y;</span><br><span class="line">                &#125;else if(hatchFactor&gt;2.0)&#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor-2.0;</span><br><span class="line">                    o.hatchWeights1.x = 1.0- o.hatchWeights0.z;</span><br><span class="line">                &#125;else if(hatchFactor&gt;1.0)&#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor-1.0;</span><br><span class="line">                    o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW (o);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0,i.uv)*i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1,i.uv)*i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2,i.uv)*i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3,i.uv)*i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4,i.uv)*i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5,i.uv)*i.hatchWeights1.z;</span><br><span class="line">                fixed4 whiteColor = fixed4(1,1,1,1)*(1-i.hatchWeights0.x-i.hatchWeights0.y-i.hatchWeights0.z-i.hatchWeights1.x-i.hatchWeights1.y-i.hatchWeights1.z);</span><br><span class="line">                fixed4 hatchColor = hatchTex0+hatchTex1+hatchTex2+hatchTex3+hatchTex4+hatchTex5+whiteColor;</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line"></span><br><span class="line">                return fixed4(hatchColor.rgb*_Color.rgb*atten,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>14.3 扩招阅读</p>
<ul>
<li>国际讨论会 NPAR( Non-Photorealistic Animation and Rendering 上有许多关于非真实感渲染的论文</li>
<li>《艺术化绘制的图形学原理与方法》 是一本不错的参考书</li>
<li>Unity 资源包<ul>
<li>Toon Shader Free是一个免费卡通资源包</li>
<li>Toon Styles Shader Pack  付费</li>
<li>Hnad-Drawn Shader Pack 付费</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="第十五章-使用噪声">第十五章 使用噪声</span></h2><ul>
<li><p>15.1 消融效果</p>
<ul>
<li><p>简介</p>
<ul>
<li>消融（dissolve）效果常见于游戏中的角色死亡，地图烧毁效果</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Dissolve&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _BurnAmount (&quot;Burn Amount&quot;,Range(0.0,1.0)) = 0.0</span><br><span class="line">        _LineWidth(&quot;Burn Line Width&quot;,Range(0.0,0.2)) = 0.1</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap(&quot;Noraml Map&quot;,2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BurnFirstColor (&quot;Burn First Color&quot;,Color) = (1,0,0,1)</span><br><span class="line">        _BurnSecondColor (&quot;Burn Second Color&quot;,Color) = (1,0,0,1)</span><br><span class="line">        _BurnMap (&quot;Burn Map&quot;,2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            Cull Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">      #include &quot;Lighting.cginc&quot;</span><br><span class="line">      #include &quot;AutoLight.cginc&quot;</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">        float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">        float4 pos : SV_POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">        float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">        float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">        float3 lightDir : TEXCOORD3;</span><br><span class="line">        float3 worldPos : TEXCOORD4;</span><br><span class="line">        SHADOW_COORDS(5)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float _BurnAmount;</span><br><span class="line">            float _LineWidth;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnFirstColor;</span><br><span class="line">            float4 _BurnSecondColor;</span><br><span class="line">            sampler2D _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        </span><br><span class="line">        o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">        o.uvBumpMap = TRANSFORM_TEX(v.uv, _BumpMap);</span><br><span class="line">        o.uvBurnMap = TRANSFORM_TEX(v.uv, _BurnMap);</span><br><span class="line">        </span><br><span class="line">        TANGENT_SPACE_ROTATION;</span><br><span class="line">          o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">          </span><br><span class="line">          o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">          </span><br><span class="line">          TRANSFER_SHADOW(o);</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;   </span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                //fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r-_BurnAmount);</span><br><span class="line">                float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">        fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb* albedo * max(0, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                fixed t = 1-smoothstep(0.0,_LineWidth,burn.r-_BurnAmount);</span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor,_BurnSecondColor,t);</span><br><span class="line">                burnColor=pow(burnColor,5);</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                float3 result = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));</span><br><span class="line">              </span><br><span class="line">                return fixed4(result,1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        // Pass to render object as a shadow caster</span><br><span class="line">    Pass &#123;</span><br><span class="line">      Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">      </span><br><span class="line">      #pragma vertex vert</span><br><span class="line">      #pragma fragment frag</span><br><span class="line">      </span><br><span class="line">      #pragma multi_compile_shadowcaster</span><br><span class="line">      </span><br><span class="line">      #include &quot;UnityCG.cginc&quot;</span><br><span class="line">      </span><br><span class="line">      fixed _BurnAmount;</span><br><span class="line">      sampler2D _BurnMap;</span><br><span class="line">      float4 _BurnMap_ST;</span><br><span class="line">      </span><br><span class="line">      struct v2f &#123;</span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">        float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      v2f vert(appdata_base v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        </span><br><span class="line">        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">        </span><br><span class="line">        o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">        fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">        </span><br><span class="line">        clip(burn.r - _BurnAmount);</span><br><span class="line">        </span><br><span class="line">        SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>15.2 水波效果</p>
<ul>
<li><p>实现思路</p>
<ul>
<li>使用噪声纹理作为高度图，改变水面的法相方向</li>
<li>使用时间相关的变量对噪波采样</li>
</ul>
</li>
<li><p>使用的计算菲涅耳系数的公式：<br>$frensnel = pow(1-max(0,v \cdot n),4)$</p>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ```</span><br><span class="line">- 15.3 再谈全局雾效</span><br><span class="line">  - 使用之前的高度雾增加噪声贴图</span><br><span class="line">  - 实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 15.4 拓展阅读</span><br><span class="line">  - 噪声纹理是一种程序纹理（Procedure Texture）,利用计算机算法生成</span><br><span class="line">  - 常用的噪声</span><br><span class="line">    - Perlin 噪声</span><br><span class="line">      - http://f1afla2.github.io/2014/08/09/perlinnoise.html</span><br><span class="line">    - Worley 噪声</span><br><span class="line">      - http://scrawkblog.com/category/procedural-noise/</span><br><span class="line">## 第十六章 Unity中的渲染优化技术</span><br><span class="line">- 16.1 移动平台的特点</span><br><span class="line">  - 特点</span><br><span class="line">    - 1. GPU架构专注于尽可能使用更小的带宽和功能</span><br><span class="line">      - 造成的优化手段</span><br><span class="line">        - 1. 使用基于瓦片的延迟渲染（Tiled-based-Deferred Rendering，TBDR）架构，为了较少OverDraw</span><br><span class="line">        - 2. Early-Z或者相似技术进行一个低精度的深度检测，来剔除那些不需要的片元，Adreno和Mali芯片</span><br><span class="line">    - IOS硬件指南http://docs.unity3d.com/Manual/iphone-Hardware.htrnl</span><br><span class="line">- 16.2 影响性能的因素</span><br><span class="line">  - 性能瓶颈的主要原因</span><br><span class="line">    - CPU</span><br><span class="line">      - 过多的Draw Call</span><br><span class="line">      - 复杂的脚本或者物理模拟</span><br><span class="line">    - GPU</span><br><span class="line">      - 顶点处理</span><br><span class="line">        - 过多的顶点</span><br><span class="line">        - 过多的逐顶点计算</span><br><span class="line">      - 片元</span><br><span class="line">        - 过多的片元（分辨率或者overdraw）</span><br><span class="line">        - 过多的逐片元计算</span><br><span class="line">    - 带宽</span><br><span class="line">      - 使用了储存很大且未压缩的纹理</span><br><span class="line">      - 分辨率过高的帧缓存</span><br><span class="line">  - 优化手段</span><br><span class="line">    - cpu优化</span><br><span class="line">      - 使用批处理减少draw call数目</span><br><span class="line">    - gpu优化</span><br><span class="line">      - 减少需要处理的顶点数目</span><br><span class="line">        - 优化几何体</span><br><span class="line">        - 使用lod</span><br><span class="line">        - 使用遮挡剔除（Occlus ion Culling）技术</span><br><span class="line">      - 减少需要处理的片元数目</span><br><span class="line">        - 控制绘制顺序</span><br><span class="line">        - 警惕透明物体</span><br><span class="line">        - 减少实时光照</span><br><span class="line">      - 减少计算复杂度</span><br><span class="line">        - 使用shader的lod</span><br><span class="line">        - 代码优化</span><br><span class="line">    - 带宽优化</span><br><span class="line">      - 减少纹理大小</span><br><span class="line">      - 利用分辨率缩放</span><br><span class="line">- 16.3 Unity中的渲染分析工具</span><br><span class="line">  - 简介</span><br><span class="line">    - 渲染统计窗口（Rendering Statistics Window）</span><br><span class="line">    - 性能分析器（Profiler）</span><br><span class="line">    - 帧调试器（Frame Debugger）</span><br><span class="line">  - 16.3.1 认识Unity5的渲染统计窗口</span><br><span class="line">    - 位置：Game视窗右上方的菜单（Stats）</span><br><span class="line">      - 音频（Audio）</span><br><span class="line">      - 图像（Graphics）</span><br><span class="line">      - 网络（Network）</span><br><span class="line">    - 重要信息</span><br><span class="line">      - FPS 处理和渲染一帧的时间和FPS（Frames Per Second）</span><br><span class="line">      - Batches 一帧需要进行的批处理数目</span><br><span class="line">      - saved by batching 合并的批处理数目，表明节省了多少draw call</span><br><span class="line">      - Tris和Verts 需要绘制的三角面片和顶点数目</span><br><span class="line">      - screen 屏幕大小以及占用内存大小</span><br><span class="line">      - SetPass pass数目</span><br><span class="line">      - Visible Skinned Meshes 渲染的蒙皮网格的数目</span><br><span class="line">      - Animations 动画数目</span><br><span class="line">      - Shadow Casters 可以投射阴影的物体数量</span><br><span class="line">  - 16.3.2 性能分析器的渲染区域</span><br><span class="line">    - 位置 Window-Analysis-Profiler(Unity 2019)</span><br><span class="line">    - Rendering Area</span><br><span class="line"></span><br><span class="line">      ![RenderingArea.png](RenderingArea.png)</span><br><span class="line"></span><br><span class="line">        - 注意：Draw call数目和批处理数目，pass数目并不相等，并且大于估算数目，因为Unity背后有很多工作，例如初始化各个缓存，为阴影更新深度纹理和阴影映射纹理</span><br><span class="line">  - 16.3.3 再谈帧调试器</span><br><span class="line">    - 位置 Window-Analysis-Frame Debugger(Unity 2019)</span><br><span class="line">    - 作用 显示渲染这一帧所需要的所有的渲染事件，单机面板每个时间，可以在Game试图查看该事件绘制结果</span><br><span class="line">  - 16.3.4 其他性能分析工具</span><br><span class="line">    - Android</span><br><span class="line">      - 高通的Adreno分析工具</span><br><span class="line">    - 英伟达 NvPerfHUD工具</span><br><span class="line">    - ios</span><br><span class="line">      - PowerVRAM的PVRUniSCo shader 大致性能评估</span><br><span class="line">      - Xcode 的 OpenGL ES Driver Instruments 宏观性能信息，设备利用率和渲染器利用率</span><br><span class="line">    - 补充</span><br><span class="line">      - 现在（2021）流行使用RenderDoc进行分析</span><br><span class="line">- 16.4 减少draw call数目</span><br><span class="line">  - 批处理（batching）</span><br><span class="line">    - 目的 为了较少每帧的draw call数目</span><br><span class="line">    - 原理 ：</span><br><span class="line">      - 每次调用draw call 尽可能处理多个物体</span><br><span class="line">    - 使用条件：</span><br><span class="line">      - 使用相同材质的物体</span><br><span class="line">      - 顶点不同可以合并顶点数据</span><br><span class="line">    - 方式：</span><br><span class="line">      - 动态批处理</span><br><span class="line">        - 自动完成</span><br><span class="line">        - 限制很多</span><br><span class="line">      - 静态批处理</span><br><span class="line">        - 自由度搞，限制少</span><br><span class="line">        - 占用内存多</span><br><span class="line">        - 处理后无法被移动</span><br><span class="line">    - 16.4.1 动态批处理</span><br><span class="line">      - 优点</span><br><span class="line">        - 实现方便</span><br><span class="line">        - 经过批处理的物体仍然可以移动（因为处理每帧时unity都会重新合并一次网格）</span><br><span class="line">      - 条件：</span><br><span class="line">        - 能够进行动态批处理的网格的顶点属性规模要小于900</span><br><span class="line">        - 保证指向光纹理中的位置相同，lightmap</span><br><span class="line">        - 多pass的shader会中断批处理</span><br><span class="line">    - 16.4.2 静态批处理</span><br><span class="line">      - 适用范围：</span><br><span class="line">        - 任何大小的几何模型</span><br><span class="line">      - 问题：</span><br><span class="line">        - 内存增大</span><br><span class="line">        - 不可移动</span><br><span class="line">    - 16.4.3 共享材质</span><br><span class="line">      - 注意：是同一个材质，而非同一种</span><br><span class="line">      - 纹理不同可以合并纹理</span><br><span class="line">      - 数据不同，部分可以移动到顶点数据里</span><br><span class="line">    - 16.4.4 批处理的注意事项</span><br><span class="line">      - 建议</span><br><span class="line">        - 尽可能选择静态批处理，小心内存</span><br><span class="line">        - 如果要使用动态批处理</span><br><span class="line">        - 对于游戏中的小道具可以使用动态批处理</span><br><span class="line">        - 对于包含动画这类物体，我们无法全部使用静态批处理，如果不动的的部分可以标为“Static”</span><br><span class="line">- 16.5 减少需要处理的顶点数目</span><br><span class="line">  - 16.5.1 优化几何体</span><br><span class="line">    - 移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离</span><br><span class="line">  - 16.5.2 模型的LOD技术</span><br><span class="line">    - 使用lodGroup</span><br><span class="line">    - 模型准备多个不同细节程度的模型</span><br><span class="line">  - 16.5.3 遮挡剔除技术</span><br><span class="line">    - 遮挡剔除技术（Occlusion culling）</span><br><span class="line">      - 用来消除那些在其他物件后面看不到的物体</span><br><span class="line">      - 与视锥体剔除（Frustum culling）不同</span><br><span class="line">    - 优化了什么</span><br><span class="line">      - 减少需要处理的顶点数目</span><br><span class="line">      - 减少overdraw·</span><br><span class="line">- 16.6 减少需要处理的片元数目</span><br><span class="line">  - 16.6.1 控制绘制顺序</span><br><span class="line">    - 因为深度测试的存在，可以保证物体都是从前往后绘制的，能很大程度减少Overdraw（红棉绘制的物体无法通过深度测试，不会进行后面的渲染处理）</span><br><span class="line">  - 16.6.2 时刻警惕透明物体</span><br><span class="line">    - 原因，半透明对象没开启深度写入，必须从后往前渲染，几乎一定会造成Overdaw。</span><br><span class="line">  - 16.6.3 减少实时光照和阴影</span><br><span class="line">    - 原因，对于逐像素的光源来说，被这些光源照亮的物体需要再被渲染一次，而且无法批处理，会中断批处理。</span><br><span class="line">    - 解决办法，使用烘焙技术或者使用God Ray。</span><br><span class="line">    - LUT</span><br><span class="line">-  16.7 节省带宽</span><br><span class="line">   -  16.7.1 减少纹理大小</span><br><span class="line">      -  长宽最好是二次幂</span><br><span class="line">      -  mipmapping 多级渐远纹理技术</span><br><span class="line">      -  纹理压缩，不同平台压缩格式不同。</span><br><span class="line">-  16.7.2 利用分辨率缩放</span><br><span class="line">   -  对于特定机器进行分辨率的缩放，</span><br><span class="line">-  16.8 减少计算复杂度</span><br><span class="line">   -  计算复杂度会影响游戏的渲染性能</span><br><span class="line">   - 16.8.1 Shader的LOD技术</span><br><span class="line">    - 当Shader的LOD值小于某个设定的值时,该Shader才会被使用</span><br><span class="line"></span><br><span class="line">      ```C</span><br><span class="line">      SubShader&#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Qpaque&quot;&#125;</span><br><span class="line">        LOD 200</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>16.8.2 代码方面的优化<br>对象&lt;顶点&lt;像素<ol>
<li>尽可能使用低精度的浮点值运算，float 存储（顶点坐标），half适合标量纹理坐标，fixed 适合颜色变量和归一化的方向矢量，避免使用swizzle计算</li>
<li>减少插值变量</li>
<li>尽可能不要使用全屏的屏幕后处理效果</li>
<li>尽可能把多个特效合并到一个Shader中</li>
<li>尽可能不要使用分支语句和循环语句</li>
<li>尽可能避免使用sin,tan,pow,log等复杂的数学计算</li>
<li>尽可能不要使用discard操作，会影响硬件的某些优化</li>
</ol>
</li>
<li>16.8.3 根据硬件条件进行缩放<br>scaiing 放缩思路</li>
</ul>
</li>
<li><p>16.9 拓展阅读</p>
<ul>
<li>官方手册 移动平台永华实践指南</li>
<li><h2><span id="第十七章-unity的表面着色器探秘">第十七章 Unity的表面着色器探秘</span></h2></li>
</ul>
</li>
</ul>
<p>表面着色器（Surface Shader）是顶点/片元着色器的抽象。</p>
</li>
<li><p>17.1 表面着色器的一个例子</p>
</li>
<li><p>17.2 编译命令<br>编译命令的作用指明该表面着色器使用的表面函数和光照函数，并设置一些可选参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> surface surfaceFunction lightModel [optionalarams]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>17.2.1 表面函数<br>名称surf</li>
<li>17.2.2 光照函数</li>
</ul>
<p>自由度低，不好优化，不如用顶点片元</p>
<h2><span id="第十八章-基于物理的渲染">第十八章 基于物理的渲染</span></h2><p>基于物理的渲染技术 （Physlcally Based Shading，PBS）</p>
</li>
<li><p>18.1 PBS的理论和数学基础</p>
<ul>
<li>18.1.1 光是什么？<br>电磁波，光纤具有吸收和散射的特性。 影响光传播的重要特质是材质的折射率。<br>光被折射到非金属物体内部，被散射出去的是次表面散射光</li>
<li>18.1.2 双向反射分布函数（BRDF）<ul>
<li>辐射率radiance 是单位面积，单位方向上光源的辐射通量，通常用L表述<br>BRDF的理解 给定入射角度后，BRDF可以给出所有出射方向上的反射和散射光线的相对分布情况<br>当给定观察方向（出射角度），BRDF可以给出所有入射方向到该出射方向的光线分布。<h2><span id="第十九章-unity5-更新了什么">第十九章 Unity5 更新了什么</span></h2><h2><span id="第二十章-还有更多内容么">第二十章 还有更多内容么</span></h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="参考">参考</span></h2><p>[1] <a href="https://en.wikipedia.org/wiki/Gaussian_blur">Gaussian blur - wikipedia</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom (shader effect) - wikipedia</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Cel_shading">Cel shading - wikipedia</a></p>
]]></content>
  </entry>
</search>
