<!DOCTYPE html>
<html lang="zh-CN">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  
  <title>Unity Shader入门精要 读书笔记 - 宫湦 - Technical Art</title>
  
    <link rel="shortcut icon" href="/friends/icon.jpg">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
    
    <body style="background-image: url(theme-img/background.jpg) ;
        background-attachment: fixed;
        background-size: cover;">



        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">主页</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">主页</a>
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item" href="/archives">文档</a>
            
            
            
            <a class="nav-item" href="/demo">Demo</a>
            
            
            
            <a class="nav-item" href="/friends">友链</a>
            
            
            
            <a class="nav-item" href="/about">关于我</a>
            
            
            
            <a class="nav-item" href="/resume">简历</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/GongShengs" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://www.artstation.com/ub010b709" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.zhihu.com/people/hu-xx-24-88" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            <span>February</span>
            
            
            
            
            
            
            
            
            
            
            
            <span>19,</span>
            <span>2023</span>
        </div>
        

        <h2 class="title">Unity Shader入门精要 读书笔记</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h1><span id="unity-shader入门精要-读书笔记">Unity Shader入门精要 读书笔记</span></h1><h2><span id="简介">简介</span></h2><p>《Unity Shader入门精要》的作者是冯乐乐，本书是一本在游戏业内广为流传的shader基础入门书籍。</p>
<h2><span id="注意事项">注意事项</span></h2><p>这篇笔记是从第12章开始的，笔记中的代码都是URP管线下的HLSL</p>
<h2><span id="书目">书目</span></h2><ul>
<li>第十二章 屏幕后处理效果</li>
<li>第十三章 使用深度和法线纹理</li>
<li>第十四章 非真实渲染</li>
<li>第十五章 使用噪声</li>
<li>第十六章 Unity中的渲染优化技术</li>
<li>第十七章 Unity的表面着色器探秘</li>
<li>第十八章 基于物理的渲染</li>
<li>第十九章 Unity5 更新了什么</li>
<li>第二十章 还有更多内容么</li>
</ul>
<h2><span id="第十二章-屏幕后处理效果">第十二章 屏幕后处理效果</span></h2><ul>
<li><p>简介</p>
<ul>
<li>屏幕后处理效果（screen post-processing effects）是游戏中实现屏幕特效的常见方法</li>
</ul>
</li>
<li><p>12.1 建立一个基础的屏幕后处理脚本系统</p>
<ul>
<li><p>屏幕后处理：渲染完整个场景得到屏幕图像后，对其进行一系列操作的技术，如：景深，运动模糊，各种故障效果。</p>
</li>
<li><p>后处理的基础基础是获取渲染后的屏幕图像，即抓取屏幕，unity提供了<strong>OnRenderImage</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonoBehaviour.OnRenderImage(RenderTexture src, RednerTexture dest)</span><br></pre></td></tr></table></figure>
<p>Unity会将当前渲染的图像存储在RenderTexture src，然后函数处理后在输出到RednerTexture dest</p>
<p>通才利用Graphics.Blit函数来处理纹理，函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void Blit(Texture src,RenderTexture dest)</span><br><span class="line"></span><br><span class="line">public static void Blit(Texture src,RenderTexture dest,Material mat,int pass = -1)</span><br><span class="line"></span><br><span class="line">public static void Blit(Texture src,Material mat,int pass = -1))</span><br></pre></td></tr></table></figure>
<p>Blit函数调用逻辑：</p>
<ul>
<li>src 是源纹理</li>
<li>dest 是目标渲染纹理,如果为null则直接显示结果</li>
<li>mat 是使用的材质，src会被传递给_MainTex</li>
<li>pass 默认为-1，依次调用pass<br>OnRenderImage函数调用</li>
<li><strong>OnRenderImage</strong>函数会在所有不透明和透明的Pass执行完毕后被调用</li>
<li>如果不想对透明产生应影响 可以在<strong>OnRenderImage</strong>前添加<strong>ImageEffectOpaque</strong><br>Unity实现屏幕后处理的流程</li>
<li>相机添加后处理脚本<ul>
<li>OnRenderImage</li>
<li>Graphics.Blit</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 检查条件脚本</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line">[RequireComponent (typeof(Camera))]</span><br><span class="line">public class PostEffectsBase : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">  // Called when start</span><br><span class="line">  protected void CheckResources() &#123;</span><br><span class="line">    bool isSupported = CheckSupport();</span><br><span class="line">    </span><br><span class="line">    if (isSupported == false) &#123;</span><br><span class="line">      NotSupported();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Called in CheckResources to check support on this platform</span><br><span class="line">  protected bool CheckSupport() &#123;</span><br><span class="line">    if (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) &#123;</span><br><span class="line">      Debug.LogWarning(&quot;This platform does not support image effects or render textures.&quot;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Called when the platform doesn&#x27;t support this effect</span><br><span class="line">  protected void NotSupported() &#123;</span><br><span class="line">    enabled = false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected void Start() &#123;</span><br><span class="line">    CheckResources();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Called when need to create the material used by this effect</span><br><span class="line">  protected Material CheckShaderAndCreateMaterial(Shader shader, Material material) &#123;</span><br><span class="line">    if (shader == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">      return material;</span><br><span class="line">    </span><br><span class="line">    if (!shader.isSupported) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      material = new Material(shader);</span><br><span class="line">      material.hideFlags = HideFlags.DontSave;</span><br><span class="line">      if (material)</span><br><span class="line">        return material;</span><br><span class="line">      else </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.2 调整屏幕亮度，饱和度和对比度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class BrightnessSaturationAndContrast : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader briSatConShader;</span><br><span class="line">    private Material briSatConMaterial;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            return briSatConMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float brightness = 1.0f;</span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float saturation = 1.0f;</span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float contrast = 1.0f;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_Brightness&quot;, brightness);</span><br><span class="line">            material.SetFloat(&quot;_Saturation&quot;, saturation);</span><br><span class="line">            material.SetFloat(&quot;_Contrast&quot;, contrast);</span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上边的脚本用于控制和修改后处理的参数</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/BrightnessSaturationAndContrast&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Base(RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Brightness(&quot;Brightness&quot;,Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Saturation&quot;,Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Contrast&quot;,Float) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                fixed3 finalColor = col.rgb*_Brightness;</span><br><span class="line">                <span class="comment">// 饱和度，灰度像素的值是RGB的加权总和</span></span><br><span class="line">                <span class="comment">// Y = 0.2125 R + 0.7154 G + 0.0721 B</span></span><br><span class="line">                <span class="comment">// https://en.wikipedia.org/wiki/Grayscale</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span>*col.r+<span class="number">0.7154</span>*col.g+<span class="number">0.0721</span>*col.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance,luminance,luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor,finalColor,_Saturation);</span><br><span class="line"></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                finalColor = lerp(avgColor,finalColor,_Contrast); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor,col.a);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该sahder用于修改输入图像的亮度，饱和度和对比度</p>
<ul>
<li>其中关于饱和度就是一个灰度值加权公式具体请看<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Grayscale">Grayscale-Wikipedia</a></li>
</ul>
</li>
<li><p>12.3 边缘检测</p>
<ul>
<li><p>简介</p>
<ul>
<li>边缘检测是描边效果的一种实现方法</li>
<li>边缘检测的原理：<ul>
<li>利用边缘检测算子对图像进行卷积（Convolution）操作</li>
</ul>
</li>
</ul>
</li>
<li><p>12.3.1 什么是卷积</p>
<ul>
<li><p>卷积操作指使用一个卷积核（kernel）对一张图像的每个像素进进行一系列操作</p>
</li>
<li><p>卷积核通常是一个四方形网格结构，该区域每个方格都有一个权重值</p>
<p><img src="%E5%8D%B7%E7%A7%AF.png" alt="卷积.png"></p>
</li>
</ul>
</li>
<li><p>12.3.2 常见的边缘检测算子</p>
<ul>
<li><p>相邻像素之间存在差别明显的颜色，亮度，纹理等属性，这个状态下他们之间就应该有一条边界。</p>
</li>
<li><p>相邻像素之间的差值可以用梯度（gradient）来表示。</p>
<p><img src="%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90.png" alt="边缘检测算子.png"></p>
</li>
</ul>
</li>
<li><p>12.3.3 实现<br>脚本的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetection : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float edgesOnly = 0.0f;</span><br><span class="line"></span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line">            Graphics.Blit(source, destination, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/BrightnessSaturationAndContrast&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Base(RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgesOnly(&quot;EdgesOnly&quot;,Float) = <span class="number">1</span></span><br><span class="line">        _EdgeColor(&quot;EdgeColor&quot;,Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _BackgroundColor(&quot;BackgroundColor&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// UV 定义</span></span><br><span class="line">                float2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            <span class="comment">// 用于访问纹理的每个纹素大小</span></span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">      v2f vert(appdata_img v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        </span><br><span class="line">        half2 uv = v.texcoord;</span><br><span class="line">        </span><br><span class="line">        o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">      &#125;</span><br><span class="line">      fixed luminance(fixed4 color) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用了Sobel算子</span></span><br><span class="line">            half Sobel(v2f i)&#123;</span><br><span class="line">        <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                    <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                    <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;	</span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> it=<span class="number">0</span>;it&lt;<span class="number">9</span>;it++)&#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX+=texColor*Gx[it];</span><br><span class="line">                    edgeY+=texColor*Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                half edge = <span class="number">1</span>-<span class="built_in">abs</span>(edgeX)-<span class="built_in">abs</span>(edgeY);</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">      fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">        half edge = Sobel(i);</span><br><span class="line">        </span><br><span class="line">        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">        <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.4 高斯模糊</p>
<ul>
<li><p>简介<br>高斯模糊 通过高斯函数模糊图像的方法叫高斯模糊<sup>[1]</sup></p>
</li>
<li><p>12.4.1<br>高斯函数为 $G(x,y) = \frac{1}{2\pi\sigma^2}e^-{\frac{x^2+y^2}{2\sigma^2}}$</p>
<ul>
<li>$\sigma$ 标准方差</li>
<li>x和y 当前位置到卷积核中心的整数距离</li>
<li>为了图像不变暗，需要高斯核的权重归一化，即每个权重除于所有权重的和。故$e$之前的系数不会对结果造成影响</li>
</ul>
<p>高斯采样如果使用一个NxN的高斯核，需要N * N * W * H次采样</p>
<p>如果使用2个一维函数惊醒采样，只需要 2 * N * W * H 次采样</p>
</li>
<li><p>12.4.2 实现<br>脚本的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class GaussianBlur : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader gaussianBlurShader;</span><br><span class="line">    private Material gaussianBlurMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            return gaussianBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0, 4)]</span><br><span class="line">    public int iterations = 3;</span><br><span class="line"></span><br><span class="line">    [Range(0.2f, 3.0f)]</span><br><span class="line">    public float blurSpread = 0.6f;</span><br><span class="line">    // </span><br><span class="line">    [Range(1, 8)]</span><br><span class="line">    public int downSample = 2;</span><br><span class="line">    // downSample越大需要处理的像素数量越少</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            //降采样优化,过大会像素化</span><br><span class="line">            int rtW = source.width/downSample;</span><br><span class="line">            int rtH = source.height/ downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            // 创建一个buffer</span><br><span class="line">            Graphics.Blit(source, buffer0);</span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f+i*blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 0);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 1);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            Graphics.Blit(buffer0, destination);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            // 释放和缓存</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Shader的实现</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/GaussianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//为了避免重复定义</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">    struct v2f &#123;</span><br><span class="line">      float4 pos : SV_POSITION;</span><br><span class="line">      half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      </span><br><span class="line">      half2 uv = v.texcoord;</span><br><span class="line">      </span><br><span class="line">      o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">      o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      </span><br><span class="line">      half2 uv = v.texcoord;</span><br><span class="line">      </span><br><span class="line">      o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">      o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">      o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">      <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">      </span><br><span class="line">      fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">        sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">        sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">    Pass &#123;</span><br><span class="line">      NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">        </span><br><span class="line">      <span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">      <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">        </span><br><span class="line">      ENDCG  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.5 Bloom</p>
<ul>
<li><p>简介<br>Bloom 辉光,模拟真实相机的图像效果，让画面中比较亮的区域“扩散”到周围区域，造成一种朦胧感</p>
<ul>
<li>Bloom实现原理<ul>
<li>根据阈值提取图像中比较亮的区域，存在一个RT中</li>
<li>再使用高斯模糊处理这张RT</li>
<li>与原图像混合<br>后处理脚本的实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Bloom : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader bloomShader;</span><br><span class="line">    private Material bloomMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            return bloomMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0, 4)]</span><br><span class="line">    public int iterations = 3;</span><br><span class="line"></span><br><span class="line">    [Range(0.2f, 3.0f)]</span><br><span class="line">    public float blurSpread = 0.6f;</span><br><span class="line"></span><br><span class="line">    [Range(1, 8)]</span><br><span class="line">    public int downSample = 2;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 4.0f)]</span><br><span class="line">    public float luminanceThreshold = 0.6f;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_LuminanceThreshold&quot;, luminanceThreshold);</span><br><span class="line">            //降采样优化,过大会像素化</span><br><span class="line">            int rtW = source.width / downSample;</span><br><span class="line">            int rtH = source.height / downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            // 创建一个buffer</span><br><span class="line">            Graphics.Blit(source, buffer0, material,0);</span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 1);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 2);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            material.SetTexture(&quot;_Bloom&quot;, buffer0);</span><br><span class="line">            Graphics.Blit(source, destination, material,3);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            // 释放和缓存</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
shader的实现</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/Bloom&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _Bloom (&quot;Bloom&quot;,<span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">    _LuminanceThreshold(&quot;LuminanceThreshold&quot;,Float) = <span class="number">0.5</span></span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">    <span class="type">sampler2D</span> _Bloom;</span><br><span class="line">    <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">    struct v2f &#123;</span><br><span class="line">      float4 pos : SV_POSITION;</span><br><span class="line">      half2 uv: TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line">    v2f vertExtractBrught(appdata_img v)&#123;</span><br><span class="line">      v2f o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      o.uv = v.texcoord;</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed luminance(fixed4 color) &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">    &#125;</span><br><span class="line">    fixed4 fragExtractBrught(v2f i) : SV_Target&#123;</span><br><span class="line">      fixed4 c = tex2D(_MainTex,i.uv);</span><br><span class="line">      fixed val = <span class="built_in">clamp</span>(luminance(c)-_LuminanceThreshold,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">      <span class="keyword">return</span> c*val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct v2fBloom&#123;</span><br><span class="line">      float4 pos :SV_POSITION;</span><br><span class="line">      half4 uv: TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line">    v2fBloom vertBloom(appdata_img v)&#123;</span><br><span class="line">      v2fBloom o;</span><br><span class="line">      o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">      o.uv.xy = v.texcoord;</span><br><span class="line">      o.uv.zw = v.texcoord;</span><br><span class="line"></span><br><span class="line">      <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">      <span class="keyword">if</span>(_MainTex_TexelSize.y&lt;<span class="number">0.0</span>)</span><br><span class="line">        o.uv.w = <span class="number">1.0</span>-o.uv.w;</span><br><span class="line">      <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed4 fragBloom(v2fBloom i) :SV_Target&#123;</span><br><span class="line">      <span class="keyword">return</span> tex2D(_MainTex,i.uv.xy)+tex2D(_Bloom,i.uv.zw);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">    Pass &#123;</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">        </span><br><span class="line">      <span class="meta">#pragma vertex vertExtractBrught  </span></span><br><span class="line">      <span class="meta">#pragma fragment fragExtractBrught</span></span><br><span class="line">        </span><br><span class="line">      ENDCG  </span><br><span class="line">    &#125;</span><br><span class="line">    UsePass &quot;Unlit/GaussianBlur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">    UsePass &quot;Unlit/GaussianBlur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">    <span class="comment">//调用指定Shader里的指定pass</span></span><br><span class="line">    <span class="comment">//这个路径是sahder的路径，不是文件夹夹结构</span></span><br><span class="line"></span><br><span class="line">    Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vertBloom</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBloom</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  FallBack off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.6 运动模糊</p>
<ul>
<li>简介<ul>
<li>运动模糊是真实世界的相机的一个效果，当相机曝光时，拍摄场景发生变化，就会发生模糊的画面</li>
<li>运动模糊实现的方法<ul>
<li><ol>
<li>利用累加缓存（accumulation buffer）来混合多张连续的图像，最后取平均值</li>
</ol>
</li>
<li><ol start="2">
<li>创建和使用速度缓存（velocity buffer），存储像素的当前运动速度，利用该值来计算模糊的方向和大小。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>实现，以下时对于第一种方案的实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MotionBlur : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader motionBlurShader;</span><br><span class="line">    private Material motionBlurMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            return motionBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 0.9f)]</span><br><span class="line">    public float blurAmount = 0.5f;</span><br><span class="line">    private RenderTexture accumulationTexture;</span><br><span class="line"></span><br><span class="line">    private void OnDisable()</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(accumulationTexture==null|| accumulationTexture.width!= source.width|| accumulationTexture.height != source.height)</span><br><span class="line">            &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = new RenderTexture(source.width, source.height, 0);</span><br><span class="line">                //隐藏并且不保存</span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(source, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line">            //恢复操作</span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line">            material.SetFloat(&quot;_BlurAmount&quot;, 1.0f-blurAmount);</span><br><span class="line">            Graphics.Blit(source, accumulationTexture,material);</span><br><span class="line">            Graphics.Blit(accumulationTexture, destination);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/MotionBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurAmount(&quot;Blur Amount&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        CGINCLUDE</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            fixed _BlurAmount;</span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            v2f vert(appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 fragRGB(v2f i) :SV_Target&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(tex2D(_MainTex,i.uv).rgb,_BlurAmount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 fragA(v2f i):SV_Target&#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex,i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragRGB</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragA</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12.7 拓展阅读</p>
<ul>
<li>Unity Image Effect</li>
<li>GPU Games - GPU Games 3 - 27章</li>
</ul>
</li>
<li><p>总结<br>本章共学习了</p>
<ul>
<li>亮度，饱和度，对比度</li>
<li>边缘检测，后处理描边</li>
<li>高斯模糊</li>
<li>辉光</li>
<li>运动模糊<h2><span id="第十三章-使用深度和法线纹理">第十三章 使用深度和法线纹理</span></h2></li>
</ul>
</li>
<li><p>13.1 获取深度和法线纹理</p>
<ul>
<li><p>13.1.1 背后的原理</p>
<ul>
<li>深度纹理<ul>
<li>深度纹理是一张渲染纹理，存储的是高精度的深度值</li>
<li>深度值范围是[0,1],但通常是非线性分布的。</li>
<li>通过MVP获得</li>
</ul>
</li>
<li>Unity如何获取深度纹理<ul>
<li><ol>
<li>延迟渲染，再G-buffer中</li>
</ol>
</li>
<li><ol start="2">
<li>使用着色器替换技术选择渲染类型为Qpaque的物体，若渲染队列小于等于2500，就渲染到深度和法线中</li>
</ol>
</li>
</ul>
</li>
<li>存储位置<ul>
<li>观察空间下，法线存储在R,G</li>
<li>观察空间下，深度存储在B，A</li>
</ul>
</li>
</ul>
</li>
<li><p>13.1.2 如何获取</p>
<ul>
<li><p>获取深度纹理的方法</p>
<ul>
<li><ol>
<li>在脚本中设置摄像机的depthTextureMode<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>Shader中使用“_CameraDepthTexture”来访问它</li>
</ol>
</li>
</ul>
</li>
<li><p>获取深度和法线纹理 </p>
<ul>
<li><ol>
<li>在脚本中设置摄像机的depthTextureMode<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>Shader中使用“_CameraDepthNoramlsTexture”来访问它</li>
</ol>
</li>
</ul>
</li>
<li><p>如何采样该纹理</p>
<ul>
<li>可以使用 tex2D</li>
<li>也可以用宏 SAMPLE_DEPTH_TEXTURE</li>
</ul>
</li>
<li><p>宏 SAMPLE_DEPTH_TEXTURE_PROJ</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// i.srcPos 屏幕坐标 ComputeScreenPos(o.pos)</span><br><span class="line">float result = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture,UNITY_PROJ_COORD(i.srcPos));</span><br></pre></td></tr></table></figure>
<ul>
<li>更多的信息可以在HLSLSupport.cginc 看到</li>
</ul>
</li>
<li><p>如何将深度纹理中的深度信息计算得到视角空间下的深度值</p>
<ul>
<li>推导过程<ul>
<li>裁剪矩阵$P_{clip}$对视角空间的顶点变换，裁剪空间下顶点的$z$和$w$如下：<ul>
<li>$Z_{clip}=-Z_{view}\frac{Far+Near}{Far-Near}-\frac{2 \cdot Far \cdot Near}{Far-Near}$</li>
<li>$w_{clip} = -Z_{view}$<ul>
<li>$Far$远裁剪平面距离</li>
<li>$Near$近裁剪平面距离</li>
</ul>
</li>
</ul>
</li>
<li>通过齐次除法获得NDC的$z$分量<ul>
<li>$z_{ndc} = \frac {z_{clip}}{w_{clip}} = \frac{Far+Near}{Far-Near}+\frac{2Near \cdot Far}{(Far-Near) \cdot z_{view}}$</li>
</ul>
</li>
<li>深度值计算<ul>
<li>$d = 0.5z_{ndc}+0.5$ </li>
</ul>
</li>
<li>通过如上公式获得<ul>
<li>$z_{view} = \frac{1}{\frac{Far-Near}{Near \cdot Far}d+\frac{1}{Near}}$</li>
</ul>
</li>
<li>Unity时间空间中摄像机正向为-z，因此结果取反<ul>
<li>$z_{view} = \frac{1}{\frac{Near-Far}{Near \cdot Far}d+\frac{1}{Near}}$</li>
</ul>
</li>
<li>当0表示该点与摄像机同一位置，1表示该点位于视锥体的远裁剪平面<ul>
<li>$z_{01} = \frac{1}{\frac{Near-Far}{Near}d+\frac{Far}{Near}}$</li>
</ul>
</li>
</ul>
</li>
<li>Unity 提供的转换函数<ul>
<li>LinearEyeDepth:将深度纹理的采样结果转换到视角空间下的深度值</li>
<li>Linear01EyeDepth：返回一个0到1的线性深度值<ul>
<li>内置变量 _ZBufferParams：获得远近裁剪平面的距离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何获得深度+法线纹理</p>
<ul>
<li>tex2D 采样_CameraDepthNoramlsTexture</li>
<li>信息解码函数如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline void DecodeDepthNoraml(float4 enc,out float depth , ouyt float3 normal)&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.zw);</span><br><span class="line">    noraml = DecodeViewNoramlStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得深度值是0到1的线性深度值</li>
<li>法线是视角空间下的法线</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>13.1.3 查看深度和法线纹理</p>
<ul>
<li>如何查看生成的深度和法线纹理<ul>
<li>Frame Debugger</li>
<li>RenderDoc</li>
</ul>
</li>
<li>输出线性空间或者转码后的法线和深度信息<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv);</span><br><span class="line">floar linearDepth = Linear01Depth(depth);</span><br><span class="line"><span class="keyword">return</span> fixed4(linearDepth,linearDepth,linearDepth,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 noraml = DecodeViewNoramlStereo(tex2D(_CameraNoramlsTexture,i.uv).xy);</span><br><span class="line">return fixed4(noraml*0.5+0.5,1.0);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>13.2 再谈运动模糊</p>
<ul>
<li><p>Gpu Gems3中提到的方案</p>
<ul>
<li><p>实现逻辑</p>
<ul>
<li>利用深度纹理再片元着色器中计算像素的世界空间位置</li>
<li>使用前一帧的视角*投影矩阵把变换获得的前一帧的NDC左边</li>
<li>计算前一帧和当前帧的位置差，生成速度</li>
</ul>
</li>
<li><p>优点</p>
<p>可以再一个后处理中完成整个模拟</p>
</li>
<li><p>缺点</p>
<p>片元进行了2次矩阵，性能有所影响</p>
</li>
</ul>
</li>
<li><p>实现<br>后处理脚本实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MotionBlurWithDepthTexture : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader motionBlurShader;</span><br><span class="line">    private Material motionBlurMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            return motionBlurMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float blurSize = 0.5f;</span><br><span class="line">    private Camera myCamera;</span><br><span class="line">    public Camera camera</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (myCamera == null)</span><br><span class="line">            &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            return myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_BlurSize&quot;, blurSize);</span><br><span class="line">            material.SetMatrix(&quot;_previousViewProjectionMatrix&quot;, previousViewProjectionMatrix);</span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            // worldToCameraMatrix 摄像机的视角矩阵</span><br><span class="line">            // projectionMatrix 摄像机的投影矩阵</span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            material.SetMatrix(&quot;_CurrentViewProjectionInverseMatrix&quot;, currentViewProjectionInverseMatrix);</span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;</span><br><span class="line">            Graphics.Blit(source, destination, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Shader实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/MotionBlurWithDepthTexture&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;,Float) = 1.0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            half _BlurSize;</span><br><span class="line">            sampler2D _CameraDepthTexture;</span><br><span class="line">            float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">            float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos :SV_POSITION;</span><br><span class="line">                half2 uv:TEXCOORD0;</span><br><span class="line">                half2 uv_depth:TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            v2f vert(appdata_img v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                o.uv_depth = v.texcoord;</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                    o.uv_depth.y = 1-o.uv_depth.y;</span><br><span class="line">                #endif</span><br><span class="line">                //处理兼容问题</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">                float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv_depth);</span><br><span class="line">                float4 H = float4(i.uv.x*2-1,i.uv.y*2-1,d*2-1,1);</span><br><span class="line">                float4 D = mul(_CurrentViewProjectionInverseMatrix,H);</span><br><span class="line">                float4 worldPos = D/D.w;</span><br><span class="line">                float4 currentPos = H;</span><br><span class="line">                float4 previousPos = mul(_PreviousViewProjectionMatrix,worldPos);</span><br><span class="line">                previousPos/=previousPos.w;</span><br><span class="line">                float2 veloctiy = (currentPos.xy-previousPos.xy)/2.0f;</span><br><span class="line"></span><br><span class="line">                float2 uv = i.uv;</span><br><span class="line">                float4 c = tex2D(_MainTex,uv);</span><br><span class="line">                uv+=veloctiy*_BlurSize;</span><br><span class="line">                for(int it=1;it&lt;3;it++,uv+=veloctiy*_BlurSize)&#123;</span><br><span class="line">                </span><br><span class="line">                    float4 currentColor = tex2D(_MainTex,uv);</span><br><span class="line">                    c+=currentColor;</span><br><span class="line">                &#125;</span><br><span class="line">                c/=3;</span><br><span class="line">                return fixed4(c.rgb,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>13.3 全局雾效</p>
<ul>
<li><p>简介</p>
<ul>
<li>雾效（Fog）是游戏中常见的一种效果</li>
<li>基于屏幕后处理的全局雾效的核心，根据深度纹理重建每个像素在世界空间下的位置<ul>
<li>首先对图像空间下的视锥体射线进行插值，射线存储的是该像素在世界空间下到摄像机的方向信息</li>
<li>把该射线和线性化后的视角空间下的深度值相乘，加上摄像机的世界位置，获得该像素的在世界空间的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>13.3.1 重建世界坐标</p>
<ul>
<li><p>如何从深度纹理中重建世界坐标</p>
<ul>
<li><p>思想：坐标系中的顶点位置可以通过它相对于另一个顶点坐标的偏移量获得。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4 worldPos = _WorldSpaceCameraPos+linearDepth*interpolatedRay;</span><br><span class="line">// _WorldSpaceCameraPos 摄像机世界空间位置</span><br><span class="line">// linearDepth*interpolatedRay 像素对于相机的偏移量</span><br></pre></td></tr></table></figure>
<ul>
<li><p>interpolatedRay 的获得方法</p>
<ul>
<li><p>interpolatedRay是近裁剪平面4个角的某个特定向量的插值，这4个向量包含了它们到摄像机的距离和方向信息</p>
</li>
<li><p>可以利用摄像机近裁剪平面距离，Fov,纵横比计算获得</p>
</li>
<li><p>toTop 和 toRight 计算公式如下，他们是起点位于近裁剪平面中心，分别指向摄像机正上方和正右方的向量</p>
<ul>
<li>$halfHeight = Near \times \tan(\frac{FOV}{2})$</li>
<li>$toTop = camera.up \times halfHeight$</li>
<li>$toRight = camera.right \times halfHeight \cdot aspect$<ul>
<li>Near 是近裁剪平面距离</li>
<li>FOV 是竖直方向视角范围</li>
<li>camera.up 摄像机正上方</li>
<li>camera.right 摄像机的正右方</li>
</ul>
</li>
</ul>
</li>
<li><p>四个角相对于摄像机的位置的计算公式</p>
<ul>
<li>$TL=camera.forward \cdot Near +toTop-toRight$</li>
<li>$TR=camera.forward \cdot Near +toTop+toRight$</li>
<li>$BL=camera.forward \cdot Near -toTop-toRight$</li>
<li>$BR=camera.forward \cdot Near -toTop+toRight$</li>
</ul>
</li>
<li><p>以上的数据为Z方向上的距离，将深度转为摄像机的欧式距离如下</p>
<ul>
<li>根据相似三角形 TL所在的射线上，像素的深度值和它到摄像机的实际距离比等于近裁剪平面的距离和TL向量的摸的比<ul>
<li>$\frac{depth}{dist} = \frac{Near}{|TL|}$</li>
</ul>
</li>
<li>所以距离如下<ul>
<li>$dist = \frac{|TL|}{Near} \times depth$</li>
</ul>
</li>
</ul>
</li>
<li><p>由于4个点对称，因此模长相同，所以我们用单一的因子进行计算</p>
<ul>
<li>$scale = \frac{|TL|}{|Near|}$</li>
<li>$Ray_{TL}= \frac{TL}{|TL|} \times scale$</li>
<li>$Ray_{TR}= \frac{TR}{|TR|} \times scale$</li>
<li>$Ray_{BL}= \frac{BL}{|BL|} \times scale$</li>
<li>$Ray_{BR}= \frac{BR}{|BR|} \times scale$</li>
</ul>
</li>
<li><p>相关的示意图如下</p>
<p><img src="interpolatedRay.png" alt="interpolatedRay.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>13.3.2 雾的计算</p>
<ul>
<li>首先需要一个雾效系数，作为混合系数<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 afterFog = f*fogColor +(<span class="number">1</span>-f)*origColor;</span><br></pre></td></tr></table></figure>
<ul>
<li>内置的雾效计算方式<ul>
<li>线性（Linear）<ul>
<li>$f = \frac{d_{max}-|z|}{d_{max}-d_{min}}$<ul>
<li>$d_{max}$雾的最大影响范围</li>
<li>$d_{min}$雾的最小影响范围</li>
</ul>
</li>
</ul>
</li>
<li>指数（Exponential）<ul>
<li>$f=e^{-d\cdot|z|}$<ul>
<li>d 是是控制雾浓度的值</li>
</ul>
</li>
</ul>
</li>
<li>指数的平方（Exponential Squared）<ul>
<li>$f = e^{-(d-|z|)^2}$<ul>
<li>d 是是控制雾浓度的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类似线性雾的计算方式，基于高度的雾效<ul>
<li>给定一个点的世界空间下的高度y</li>
<li>公式<ul>
<li>$f = \frac{H_{end}-y}{H_{end}-H_{start}}$<ul>
<li>$H_{end}$ 雾影响的终止高度</li>
<li>$H_{start}$ 雾影响的起始高度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>13.3.3 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class FogWithDepthTexture : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    public Shader fogShader;</span><br><span class="line">    private Material fogMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            return fogMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Camera myCamera;</span><br><span class="line">    public Camera camera</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (myCamera == null)</span><br><span class="line">            &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            return myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Transform myCameraTransform;</span><br><span class="line">    public Transform cameraTransform</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (myCameraTransform == null)</span><br><span class="line">            &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            return myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 3.0f)]</span><br><span class="line">    public float fogDensity = 1.0f;</span><br><span class="line"></span><br><span class="line">    public Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    public float fogStart = 0.0f;</span><br><span class="line">    public float fogEnd = 2.0f;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Matrix4x4 frustumCormers = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            float fov = camera.fieldOfView;</span><br><span class="line">            float near = camera.nearClipPlane;</span><br><span class="line">            float far = camera.farClipPlane;</span><br><span class="line">            float aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            float halfHeight = near * Mathf.Tan(fov * 0.5f * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            float sacle = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= sacle;</span><br><span class="line"></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toTop + toRight;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= sacle;</span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= sacle;</span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near - toTop + toRight;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= sacle;</span><br><span class="line"></span><br><span class="line">            frustumCormers.SetRow(0, bottomLeft);</span><br><span class="line">            frustumCormers.SetRow(1, bottomRight);</span><br><span class="line">            frustumCormers.SetRow(2, topRight);</span><br><span class="line">            frustumCormers.SetRow(3, topLeft);</span><br><span class="line">            //将向量存储到矩阵中</span><br><span class="line">            material.SetMatrix(&quot;_FrustumCormers&quot;, frustumCormers);</span><br><span class="line">            material.SetMatrix(&quot;_ViewProjectionInverseMatrix&quot;, (camera.projectionMatrix * camera.worldToCameraMatrix).inverse);</span><br><span class="line">            material.SetFloat(&quot;_FogDensity&quot;, fogDensity);</span><br><span class="line">            material.SetColor(&quot;_FogColor&quot;, fogColor);</span><br><span class="line">            material.SetFloat(&quot;_FogStart&quot;, fogStart);</span><br><span class="line">            material.SetFloat(&quot;_FogEnd&quot;, fogEnd);</span><br><span class="line">            Graphics.Blit(source, destination,material);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/FogWithDepthTexture&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity(&quot;Fog Density&quot;,Float) = 1.0</span><br><span class="line">        _FogColor(&quot;Fog Color&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _FogStart(&quot;Fog Start&quot;,Float) = 0.0</span><br><span class="line">        _FogEnd(&quot;Fog End&quot;,Float) = 1.0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            sampler2D _CameraDepthTexture;</span><br><span class="line">            half _FogDensity;</span><br><span class="line">            fixed4 _FogColor;</span><br><span class="line">            float _FogStart;</span><br><span class="line">            float _FogEnd;</span><br><span class="line">            float4x4 _FrustumCormers;</span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos :SV_POSITION;</span><br><span class="line">                half2 uv :TEXCOORD0;</span><br><span class="line">                half2 uv_depth :TEXCOORD1;</span><br><span class="line">                float4 interpolatedRay :TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                o.uv_depth = v.texcoord;</span><br><span class="line">                // 平台兼容</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                    o.uv_depth.y=1-o.uv_depth.y;</span><br><span class="line">                #endif</span><br><span class="line">                //坐标索引判断</span><br><span class="line">                int index = 0;</span><br><span class="line">                if(v.texcoord.x&lt;0.5 &amp;&amp; v.texcoord.y&lt;0.5)&#123;</span><br><span class="line">                    index=0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(v.texcoord.x&gt;0.5 &amp;&amp; v.texcoord.y&lt;0.5)&#123;</span><br><span class="line">                    index=1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(v.texcoord.x&gt;0.5 &amp;&amp; v.texcoord.y&gt;0.5)&#123;</span><br><span class="line">                    index=2;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    index=3;</span><br><span class="line">                &#125;</span><br><span class="line">                // 平台兼容</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                    if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                        index = 3- index;</span><br><span class="line">                #endif</span><br><span class="line">                o.interpolatedRay = _FrustumCormers[index];</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag(v2f i) :SV_Target&#123;</span><br><span class="line">                float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv_depth));</span><br><span class="line">                float3 worldPos = _WorldSpaceCameraPos+linearDepth*i.interpolatedRay.xyz;</span><br><span class="line">                float fogDensity = (_FogEnd-worldPos.y)/(_FogEnd-_FogStart);</span><br><span class="line">                fogDensity=saturate(fogDensity*_FogDensity);</span><br><span class="line">                fixed4 finalColor = tex2D(_MainTex,i.uv);</span><br><span class="line">                finalColor.rgb = lerp(finalColor.rgb,_FogColor,fogDensity);</span><br><span class="line"></span><br><span class="line">                return finalColor;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>13.4 再谈边缘检测</p>
<ul>
<li><p>简介</p>
<ul>
<li><p>使用深度纹理进行边缘检测更可靠，对比效果如下</p>
<p><img src="%E5%86%8D%E8%B0%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.png" alt="再谈边缘检测.png"></p>
</li>
<li><p>本章使用 Roberts 算子</p>
<ul>
<li>Roberts本质是计算左上角和右下角的插值，乘于右上角和左下角的插值      </li>
</ul>
</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetectNoramlsAndDepth : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [Range(0.0f, 1.0f)]</span><br><span class="line">    public float edgesOnly = 0.0f;</span><br><span class="line"></span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line">    public float sampleDistance = 1.0f;</span><br><span class="line">    // 采样距离，值越大，描边越宽</span><br><span class="line">    public float sensitivityDepth = 1.0f;</span><br><span class="line">    public float sensitivityNormals = 1.0f;</span><br><span class="line">    //权重</span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;   </span><br><span class="line">    &#125;</span><br><span class="line">    [ImageEffectOpaque]//定义仅影响不透明物体</span><br><span class="line">    void OnRenderImage(RenderTexture source, RenderTexture destination)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line">            material.SetFloat(&quot;_SampleDistance&quot;, sampleDistance);</span><br><span class="line">            material.SetVector(&quot;_Sensitivity&quot;, new Vector4(sensitivityDepth, sensitivityNormals,0.0f,0.0f));</span><br><span class="line">            Graphics.Blit(source, destination, material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/EdgeDetectNoramlsAndDepth&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Base(RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly(&quot;EdgeOnly&quot;,Float) = 1</span><br><span class="line">        _EdgeColor(&quot;EdgeColor&quot;,Color) = (0,0,0,1)</span><br><span class="line">        _BackgroundColor(&quot;BackgroundColor&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _SampleDistance(&quot;Sample Distance&quot;,Float) = 1.0</span><br><span class="line">        _Sensitivity(&quot;Sensitivity&quot;,Vector) = (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            // 用于访问纹理的每个纹素大小</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            float _SampleDistance;</span><br><span class="line">            half4 _Sensitivity;</span><br><span class="line">            sampler2D _CameraDepthNormalsTexture;</span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                half2 uv[5] :TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            v2f vert(appdata_img v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                o.uv[0]=uv;</span><br><span class="line">                //平台兼容</span><br><span class="line">                #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                if(_MainTex_TexelSize.y&lt;0)</span><br><span class="line">                    uv.y=1-uv.y;</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                o.uv[1] = uv+_MainTex_TexelSize.xy*half2(1,1)*_SampleDistance;</span><br><span class="line">                o.uv[2] = uv+_MainTex_TexelSize.xy*half2(-1,-1)*_SampleDistance;</span><br><span class="line">                o.uv[3] = uv+_MainTex_TexelSize.xy*half2(-1,1)*_SampleDistance;</span><br><span class="line">                o.uv[4] = uv+_MainTex_TexelSize.xy*half2(1,-1)*_SampleDistance;</span><br><span class="line">                // 纹理坐标数据</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            half CheckSame(half4 center,half4 sample)&#123;</span><br><span class="line">                half2 centerNoraml = center.xy;</span><br><span class="line">                float centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">                half2 sampleNoraml = sample.xy;</span><br><span class="line">                float sampleDepth = DecodeFloatRG(sample.zw);</span><br><span class="line"></span><br><span class="line">                half2 diffNoraml = abs(centerNoraml-sampleNoraml)*_Sensitivity.x;</span><br><span class="line">                int isSameNoraml = (diffNoraml.x+diffNoraml.y)&lt;0.1;</span><br><span class="line">                float diffDepth = abs(centerDepth-sampleDepth)*_Sensitivity.y;</span><br><span class="line">                int isSameDepth = diffDepth&lt;0.1*centerDepth;</span><br><span class="line"></span><br><span class="line">                return isSameNoraml*isSameDepth ? 1.0:0.0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            fixed4 fragRobertsCrossDepthAndNormal(v2f i) :SV_Target&#123;</span><br><span class="line">                half4 sample1 = tex2D(_CameraDepthNormalsTexture,i.uv[1]);</span><br><span class="line">                half4 sample2 = tex2D(_CameraDepthNormalsTexture,i.uv[2]);</span><br><span class="line">                half4 sample3 = tex2D(_CameraDepthNormalsTexture,i.uv[3]);</span><br><span class="line">                half4 sample4 = tex2D(_CameraDepthNormalsTexture,i.uv[4]);</span><br><span class="line"></span><br><span class="line">                half edge = 1.0;</span><br><span class="line"></span><br><span class="line">                edge*=CheckSame(sample1,sample2);</span><br><span class="line">                edge*=CheckSame(sample3,sample4);</span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor,tex2D(_MainTex,i.uv[0]),edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor,_BackgroundColor,edge);</span><br><span class="line"></span><br><span class="line">                return lerp(withEdgeColor,onlyEdgeColor,_EdgeOnly);</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment fragRobertsCrossDepthAndNormal</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>这是全局的后处理描边</p>
</li>
<li><p>特定物体描边 需要使用 Graphics.DrawMesh或者Graphics.DrawMeshNow</p>
</li>
</ul>
</li>
<li><p>13.5 拓展阅读</p>
<ul>
<li>SIGGRAPH 2011 Unity 有一篇关于利用深度纹理制作各种特效的演讲</li>
<li>Unity 的Image Effect 中包含了许多相关的特效，例如屏幕空间环境遮蔽（SSAO）</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>本章学习了<ul>
<li>基于深度的运动模糊</li>
<li>全局雾效</li>
<li>基于深度的描边<h2><span id="第十四章-非真实渲染">第十四章 非真实渲染</span></h2></li>
</ul>
</li>
</ul>
</li>
<li><p>简介</p>
<ul>
<li>非真实渲染（Non-Photorealistic Rendering,NPR）使用一些方法让画面达到某种特殊绘画风格类似的效果</li>
</ul>
</li>
<li><p>14.1 卡通风格的渲染</p>
<ul>
<li><p>简介</p>
<ul>
<li>卡通渲染的特点：<ul>
<li>描边</li>
<li>分明的变换</li>
</ul>
</li>
<li>技术简介：<ul>
<li>基于色调的作色技术（tone-based shading）,1998年Gooch提出的</li>
</ul>
</li>
</ul>
</li>
<li><p>14.1.1 渲染轮廓线</p>
<ul>
<li><p>渲染轮廓线的方案</p>
<ul>
<li>基于观察角度和表面法线的轮廓线渲染</li>
<li>过程式几何轮廓线渲染</li>
<li>基于图像处理的轮廓线渲染</li>
<li>基于轮廓边检测的轮廓线渲染</li>
<li>混合以上的方案</li>
</ul>
</li>
<li><p>本章的方案是 过程式几何轮廓线渲染</p>
<ul>
<li><p>双Pass，第一个pass渲染背面，然后在视角空间下沿法线方向扩张，另一个pass渲染正面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPos = viewPos +viewNormal *_Outline;</span><br></pre></td></tr></table></figure></li>
<li><p>为了处理一些内凹的模型，背面面片遮挡正面面片的情况，需要处理法线的Z分量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewNormal.z = -0.5;</span><br><span class="line">viewNormal = normalize(viewNormal);</span><br><span class="line">viewPos = viewPos + viewNormal * _Outline;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>14.1.2 添加高光</p>
<ul>
<li><p>和Blinn-Phong 不同，需要进行阈值比较，小于阈值，反射系数为0，否则返回1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float spec = dot(worldNoraml,worldHalfDir);</span><br><span class="line">spec = step(threshold,spec);</span><br></pre></td></tr></table></figure></li>
<li><p>抗锯齿优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float spec = dot(worldNoraml,worldHalfDir);</span><br><span class="line">spec = lerp(0,1,smppthstep(-w,w,spec-threshold));</span><br></pre></td></tr></table></figure></li>
<li><p>拓展参考</p>
<ul>
<li>风格化高光参考：2003年 ANJYO</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/candycat1992/article/details/47284289">https://blog.csdn.net/candycat1992/article/details/47284289</a></li>
</ul>
</li>
</ul>
</li>
<li><p>14.1.3 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Toon&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Ramp (&quot;Ramp Texture&quot;,2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Outline (&quot;Outline&quot;,Range(0,1)) = 0.1</span><br><span class="line">        _OutlineColor (&quot;Outline Color&quot;,Color) = (0,0,0,1)</span><br><span class="line">        _Specular (&quot;Spacular&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _SpecularScale (&quot;Spacular Scale&quot;,Range(0,0.1)) = 0.01</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        pass&#123;</span><br><span class="line">            NAME &quot;OUTLINE&quot;//定义名称为了以后调用</span><br><span class="line">            Cull Front</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            float _Outline;</span><br><span class="line">      fixed4 _OutlineColor;</span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                float3 normal :NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">      v2f vert (a2v v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        </span><br><span class="line">        float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">        float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  </span><br><span class="line">        normal.z = -0.5;</span><br><span class="line">        pos = pos + float4(normalize(normal), 0) * _Outline;</span><br><span class="line">        o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">      &#125;</span><br><span class="line">            float4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                return float4(_OutlineColor.rgb,1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">      #include &quot;AutoLight.cginc&quot;</span><br><span class="line">      #include &quot;UnityShaderVariables.cginc&quot;</span><br><span class="line">      fixed4 _Color;</span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      float4 _MainTex_ST;</span><br><span class="line">      sampler2D _Ramp;</span><br><span class="line">      fixed4 _Specular;</span><br><span class="line">      fixed _SpecularScale;</span><br><span class="line"></span><br><span class="line">            struct a2v &#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float3 normal : NORMAL;</span><br><span class="line">        float4 texcoord : TEXCOORD0;</span><br><span class="line">        float4 tangent : TANGENT;</span><br><span class="line">      &#125;; </span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos:POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">                float3 worldNormal :TEXCOORD1;</span><br><span class="line">                float3 worldPos :TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(3)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f vert (a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal = mul(v.normal,(float3x3)unity_ObjectToWorld);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW (o);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">        fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">        fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">        fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);</span><br><span class="line"></span><br><span class="line">                fixed4 c = tex2D(_MainTex,i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb*_Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line"></span><br><span class="line">                fixed diff = dot(worldNormal,worldLightDir);</span><br><span class="line">                diff=(diff*0.5+0.5)*atten;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo*tex2D(_Ramp,float2(diff,diff)).rgb;</span><br><span class="line"></span><br><span class="line">                fixed spec = dot(worldNormal,worldHalfDir);</span><br><span class="line">                fixed w = fwidth(spec)*2.0;</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient+diffuse+specular,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>14.2 素描风格的渲染</p>
<ul>
<li><p>简介 </p>
<ul>
<li>2001年，微软研究院的Praum等人在SIGGRAPH提出</li>
<li>色调艺术映射（Tonal Art Map,TAM）</li>
</ul>
</li>
<li><p>实现思路</p>
<ul>
<li>使用6张素描纹理进行渲染</li>
<li>根据光照结果来决定6张纹理的混合权重</li>
<li>在片元中根据权重混合采样结果</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Hatching&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _TileFactor (&quot;Tile Factor&quot;,Float) = 1</span><br><span class="line">        _Outline(&quot;Outline&quot;,Range(0,1)) = 0.1</span><br><span class="line">        _Hatch0 (&quot;Hatch 0&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch1 (&quot;Hatch 1&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch2 (&quot;Hatch 2&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch3 (&quot;Hatch 3&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch4 (&quot;Hatch 4&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch5 (&quot;Hatch 5&quot;,2D)= &quot;white&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Opaque&quot; =&quot;Geometry&quot;&#125;</span><br><span class="line">        UsePass &quot;Unlit/Toon/OUTLINE&quot;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">      #include &quot;AutoLight.cginc&quot;</span><br><span class="line">      #include &quot;UnityShaderVariables.cginc&quot;</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                //float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">        float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                fixed3 hatchWeights0 :TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 :TEXCOORD2;</span><br><span class="line">                float3 worldPos :TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(4)</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _TileFactor;</span><br><span class="line">            fixed _Outline;</span><br><span class="line">            sampler2D _Hatch0;</span><br><span class="line">            sampler2D _Hatch1;</span><br><span class="line">            sampler2D _Hatch2;</span><br><span class="line">            sampler2D _Hatch3;</span><br><span class="line">            sampler2D _Hatch4;</span><br><span class="line">            sampler2D _Hatch5;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord.xy*_TileFactor;</span><br><span class="line">                fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNoraml = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = max(0,dot(worldLightDir,worldNoraml));</span><br><span class="line">                o.hatchWeights0 = fixed3(0,0,0);</span><br><span class="line">                o.hatchWeights1 = fixed3(0,0,0);</span><br><span class="line">                float hatchFactor = diff*7.0;</span><br><span class="line">                if(hatchFactor&gt;6.0)&#123;</span><br><span class="line">                    //</span><br><span class="line">                &#125;else if(hatchFactor&gt;5.0)&#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor-5.0;</span><br><span class="line">                &#125;else if(hatchFactor&gt;4.0)&#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor-4.0;</span><br><span class="line">                    o.hatchWeights0.y = 1- o.hatchWeights0.x;</span><br><span class="line">                &#125;else if(hatchFactor&gt;3.0)&#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor-3.0;</span><br><span class="line">                    o.hatchWeights0.z = 1.0- o.hatchWeights0.y;</span><br><span class="line">                &#125;else if(hatchFactor&gt;2.0)&#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor-2.0;</span><br><span class="line">                    o.hatchWeights1.x = 1.0- o.hatchWeights0.z;</span><br><span class="line">                &#125;else if(hatchFactor&gt;1.0)&#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor-1.0;</span><br><span class="line">                    o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW (o);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0,i.uv)*i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1,i.uv)*i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2,i.uv)*i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3,i.uv)*i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4,i.uv)*i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5,i.uv)*i.hatchWeights1.z;</span><br><span class="line">                fixed4 whiteColor = fixed4(1,1,1,1)*(1-i.hatchWeights0.x-i.hatchWeights0.y-i.hatchWeights0.z-i.hatchWeights1.x-i.hatchWeights1.y-i.hatchWeights1.z);</span><br><span class="line">                fixed4 hatchColor = hatchTex0+hatchTex1+hatchTex2+hatchTex3+hatchTex4+hatchTex5+whiteColor;</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line"></span><br><span class="line">                return fixed4(hatchColor.rgb*_Color.rgb*atten,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>14.3 扩招阅读</p>
<ul>
<li>国际讨论会 NPAR( Non-Photorealistic Animation and Rendering 上有许多关于非真实感渲染的论文</li>
<li>《艺术化绘制的图形学原理与方法》 是一本不错的参考书</li>
<li>Unity 资源包<ul>
<li>Toon Shader Free是一个免费卡通资源包</li>
<li>Toon Styles Shader Pack  付费</li>
<li>Hnad-Drawn Shader Pack 付费</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="第十五章-使用噪声">第十五章 使用噪声</span></h2><ul>
<li><p>15.1 消融效果</p>
<ul>
<li><p>简介</p>
<ul>
<li>消融（dissolve）效果常见于游戏中的角色死亡，地图烧毁效果</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Dissolve&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _BurnAmount (&quot;Burn Amount&quot;,Range(0.0,1.0)) = 0.0</span><br><span class="line">        _LineWidth(&quot;Burn Line Width&quot;,Range(0.0,0.2)) = 0.1</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap(&quot;Noraml Map&quot;,2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BurnFirstColor (&quot;Burn First Color&quot;,Color) = (1,0,0,1)</span><br><span class="line">        _BurnSecondColor (&quot;Burn Second Color&quot;,Color) = (1,0,0,1)</span><br><span class="line">        _BurnMap (&quot;Burn Map&quot;,2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            Cull Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">      #include &quot;Lighting.cginc&quot;</span><br><span class="line">      #include &quot;AutoLight.cginc&quot;</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">        float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">        float4 pos : SV_POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">        float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">        float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">        float3 lightDir : TEXCOORD3;</span><br><span class="line">        float3 worldPos : TEXCOORD4;</span><br><span class="line">        SHADOW_COORDS(5)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float _BurnAmount;</span><br><span class="line">            float _LineWidth;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnFirstColor;</span><br><span class="line">            float4 _BurnSecondColor;</span><br><span class="line">            sampler2D _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        </span><br><span class="line">        o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">        o.uvBumpMap = TRANSFORM_TEX(v.uv, _BumpMap);</span><br><span class="line">        o.uvBurnMap = TRANSFORM_TEX(v.uv, _BurnMap);</span><br><span class="line">        </span><br><span class="line">        TANGENT_SPACE_ROTATION;</span><br><span class="line">          o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">          </span><br><span class="line">          o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">          </span><br><span class="line">          TRANSFER_SHADOW(o);</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;   </span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                //fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r-_BurnAmount);</span><br><span class="line">                float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">        fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb* albedo * max(0, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                fixed t = 1-smoothstep(0.0,_LineWidth,burn.r-_BurnAmount);</span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor,_BurnSecondColor,t);</span><br><span class="line">                burnColor=pow(burnColor,5);</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                float3 result = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));</span><br><span class="line">              </span><br><span class="line">                return fixed4(result,1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        // Pass to render object as a shadow caster</span><br><span class="line">    Pass &#123;</span><br><span class="line">      Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">      </span><br><span class="line">      #pragma vertex vert</span><br><span class="line">      #pragma fragment frag</span><br><span class="line">      </span><br><span class="line">      #pragma multi_compile_shadowcaster</span><br><span class="line">      </span><br><span class="line">      #include &quot;UnityCG.cginc&quot;</span><br><span class="line">      </span><br><span class="line">      fixed _BurnAmount;</span><br><span class="line">      sampler2D _BurnMap;</span><br><span class="line">      float4 _BurnMap_ST;</span><br><span class="line">      </span><br><span class="line">      struct v2f &#123;</span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">        float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      v2f vert(appdata_base v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        </span><br><span class="line">        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">        </span><br><span class="line">        o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">        fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">        </span><br><span class="line">        clip(burn.r - _BurnAmount);</span><br><span class="line">        </span><br><span class="line">        SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>15.2 水波效果</p>
<ul>
<li><p>实现思路</p>
<ul>
<li>使用噪声纹理作为高度图，改变水面的法相方向</li>
<li>使用时间相关的变量对噪波采样</li>
</ul>
</li>
<li><p>使用的计算菲涅耳系数的公式：<br>$frensnel = pow(1-max(0,v \cdot n),4)$</p>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    ```</span><br><span class="line">- 15.3 再谈全局雾效</span><br><span class="line">  - 使用之前的高度雾增加噪声贴图</span><br><span class="line">  - 实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">- 15.4 拓展阅读</span><br><span class="line">  - 噪声纹理是一种程序纹理（Procedure Texture）,利用计算机算法生成</span><br><span class="line">  - 常用的噪声</span><br><span class="line">    - Perlin 噪声</span><br><span class="line">      - http://f1afla2.github.io/2014/08/09/perlinnoise.html</span><br><span class="line">    - Worley 噪声</span><br><span class="line">      - http://scrawkblog.com/category/procedural-noise/</span><br><span class="line">## 第十六章 Unity中的渲染优化技术</span><br><span class="line">- 16.1 移动平台的特点</span><br><span class="line">  - 特点</span><br><span class="line">    - 1. GPU架构专注于尽可能使用更小的带宽和功能</span><br><span class="line">      - 造成的优化手段</span><br><span class="line">        - 1. 使用基于瓦片的延迟渲染（Tiled-based-Deferred Rendering，TBDR）架构，为了较少OverDraw</span><br><span class="line">        - 2. Early-Z或者相似技术进行一个低精度的深度检测，来剔除那些不需要的片元，Adreno和Mali芯片</span><br><span class="line">    - IOS硬件指南http://docs.unity3d.com/Manual/iphone-Hardware.htrnl</span><br><span class="line">- 16.2 影响性能的因素</span><br><span class="line">  - 性能瓶颈的主要原因</span><br><span class="line">    - CPU</span><br><span class="line">      - 过多的Draw Call</span><br><span class="line">      - 复杂的脚本或者物理模拟</span><br><span class="line">    - GPU</span><br><span class="line">      - 顶点处理</span><br><span class="line">        - 过多的顶点</span><br><span class="line">        - 过多的逐顶点计算</span><br><span class="line">      - 片元</span><br><span class="line">        - 过多的片元（分辨率或者overdraw）</span><br><span class="line">        - 过多的逐片元计算</span><br><span class="line">    - 带宽</span><br><span class="line">      - 使用了储存很大且未压缩的纹理</span><br><span class="line">      - 分辨率过高的帧缓存</span><br><span class="line">  - 优化手段</span><br><span class="line">    - cpu优化</span><br><span class="line">      - 使用批处理减少draw call数目</span><br><span class="line">    - gpu优化</span><br><span class="line">      - 减少需要处理的顶点数目</span><br><span class="line">        - 优化几何体</span><br><span class="line">        - 使用lod</span><br><span class="line">        - 使用遮挡剔除（Occlus ion Culling）技术</span><br><span class="line">      - 减少需要处理的片元数目</span><br><span class="line">        - 控制绘制顺序</span><br><span class="line">        - 警惕透明物体</span><br><span class="line">        - 减少实时光照</span><br><span class="line">      - 减少计算复杂度</span><br><span class="line">        - 使用shader的lod</span><br><span class="line">        - 代码优化</span><br><span class="line">    - 带宽优化</span><br><span class="line">      - 减少纹理大小</span><br><span class="line">      - 利用分辨率缩放</span><br><span class="line">- 16.3 Unity中的渲染分析工具</span><br><span class="line">  - 简介</span><br><span class="line">    - 渲染统计窗口（Rendering Statistics Window）</span><br><span class="line">    - 性能分析器（Profiler）</span><br><span class="line">    - 帧调试器（Frame Debugger）</span><br><span class="line">  - 16.3.1 认识Unity5的渲染统计窗口</span><br><span class="line">    - 位置：Game视窗右上方的菜单（Stats）</span><br><span class="line">      - 音频（Audio）</span><br><span class="line">      - 图像（Graphics）</span><br><span class="line">      - 网络（Network）</span><br><span class="line">    - 重要信息</span><br><span class="line">      - FPS 处理和渲染一帧的时间和FPS（Frames Per Second）</span><br><span class="line">      - Batches 一帧需要进行的批处理数目</span><br><span class="line">      - saved by batching 合并的批处理数目，表明节省了多少draw call</span><br><span class="line">      - Tris和Verts 需要绘制的三角面片和顶点数目</span><br><span class="line">      - screen 屏幕大小以及占用内存大小</span><br><span class="line">      - SetPass pass数目</span><br><span class="line">      - Visible Skinned Meshes 渲染的蒙皮网格的数目</span><br><span class="line">      - Animations 动画数目</span><br><span class="line">      - Shadow Casters 可以投射阴影的物体数量</span><br><span class="line">  - 16.3.2 性能分析器的渲染区域</span><br><span class="line">    - 位置 Window-Analysis-Profiler(Unity 2019)</span><br><span class="line">    - Rendering Area</span><br><span class="line"></span><br><span class="line">      ![RenderingArea.png](RenderingArea.png)</span><br><span class="line"></span><br><span class="line">        - 注意：Draw call数目和批处理数目，pass数目并不相等，并且大于估算数目，因为Unity背后有很多工作，例如初始化各个缓存，为阴影更新深度纹理和阴影映射纹理</span><br><span class="line">  - 16.3.3 再谈帧调试器</span><br><span class="line">    - 位置 Window-Analysis-Frame Debugger(Unity 2019)</span><br><span class="line">    - 作用 显示渲染这一帧所需要的所有的渲染事件，单机面板每个时间，可以在Game试图查看该事件绘制结果</span><br><span class="line">  - 16.3.4 其他性能分析工具</span><br><span class="line">    - Android</span><br><span class="line">      - 高通的Adreno分析工具</span><br><span class="line">    - 英伟达 NvPerfHUD工具</span><br><span class="line">    - ios</span><br><span class="line">      - PowerVRAM的PVRUniSCo shader 大致性能评估</span><br><span class="line">      - Xcode 的 OpenGL ES Driver Instruments 宏观性能信息，设备利用率和渲染器利用率</span><br><span class="line">    - 补充</span><br><span class="line">      - 现在（2021）流行使用RenderDoc进行分析</span><br><span class="line">- 16.4 减少draw call数目</span><br><span class="line">  - 批处理（batching）</span><br><span class="line">    - 目的 为了较少每帧的draw call数目</span><br><span class="line">    - 原理 ：</span><br><span class="line">      - 每次调用draw call 尽可能处理多个物体</span><br><span class="line">    - 使用条件：</span><br><span class="line">      - 使用相同材质的物体</span><br><span class="line">      - 顶点不同可以合并顶点数据</span><br><span class="line">    - 方式：</span><br><span class="line">      - 动态批处理</span><br><span class="line">        - 自动完成</span><br><span class="line">        - 限制很多</span><br><span class="line">      - 静态批处理</span><br><span class="line">        - 自由度搞，限制少</span><br><span class="line">        - 占用内存多</span><br><span class="line">        - 处理后无法被移动</span><br><span class="line">    - 16.4.1 动态批处理</span><br><span class="line">      - 优点</span><br><span class="line">        - 实现方便</span><br><span class="line">        - 经过批处理的物体仍然可以移动（因为处理每帧时unity都会重新合并一次网格）</span><br><span class="line">      - 条件：</span><br><span class="line">        - 能够进行动态批处理的网格的顶点属性规模要小于900</span><br><span class="line">        - 保证指向光纹理中的位置相同，lightmap</span><br><span class="line">        - 多pass的shader会中断批处理</span><br><span class="line">    - 16.4.2 静态批处理</span><br><span class="line">      - 适用范围：</span><br><span class="line">        - 任何大小的几何模型</span><br><span class="line">      - 问题：</span><br><span class="line">        - 内存增大</span><br><span class="line">        - 不可移动</span><br><span class="line">    - 16.4.3 共享材质</span><br><span class="line">      - 注意：是同一个材质，而非同一种</span><br><span class="line">      - 纹理不同可以合并纹理</span><br><span class="line">      - 数据不同，部分可以移动到顶点数据里</span><br><span class="line">    - 16.4.4 批处理的注意事项</span><br><span class="line">      - 建议</span><br><span class="line">        - 尽可能选择静态批处理，小心内存</span><br><span class="line">        - 如果要使用动态批处理</span><br><span class="line">        - 对于游戏中的小道具可以使用动态批处理</span><br><span class="line">        - 对于包含动画这类物体，我们无法全部使用静态批处理，如果不动的的部分可以标为“Static”</span><br><span class="line">- 16.5 减少需要处理的顶点数目</span><br><span class="line">  - 16.5.1 优化几何体</span><br><span class="line">    - 移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离</span><br><span class="line">  - 16.5.2 模型的LOD技术</span><br><span class="line">    - 使用lodGroup</span><br><span class="line">    - 模型准备多个不同细节程度的模型</span><br><span class="line">  - 16.5.3 遮挡剔除技术</span><br><span class="line">    - 遮挡剔除技术（Occlusion culling）</span><br><span class="line">      - 用来消除那些在其他物件后面看不到的物体</span><br><span class="line">      - 与视锥体剔除（Frustum culling）不同</span><br><span class="line">    - 优化了什么</span><br><span class="line">      - 减少需要处理的顶点数目</span><br><span class="line">      - 减少overdraw·</span><br><span class="line">- 16.6 减少需要处理的片元数目</span><br><span class="line">  - 16.6.1 控制绘制顺序</span><br><span class="line">    - 因为深度测试的存在，可以保证物体都是从前往后绘制的，能很大程度减少Overdraw（红棉绘制的物体无法通过深度测试，不会进行后面的渲染处理）</span><br><span class="line">  - 16.6.2 时刻警惕透明物体</span><br><span class="line">    - 原因，半透明对象没开启深度写入，必须从后往前渲染，几乎一定会造成Overdaw。</span><br><span class="line">  - 16.6.3 减少实时光照和阴影</span><br><span class="line">    - 原因，对于逐像素的光源来说，被这些光源照亮的物体需要再被渲染一次，而且无法批处理，会中断批处理。</span><br><span class="line">    - 解决办法，使用烘焙技术或者使用God Ray。</span><br><span class="line">    - LUT</span><br><span class="line">-  16.7 节省带宽</span><br><span class="line">   -  16.7.1 减少纹理大小</span><br><span class="line">      -  长宽最好是二次幂</span><br><span class="line">      -  mipmapping 多级渐远纹理技术</span><br><span class="line">      -  纹理压缩，不同平台压缩格式不同。</span><br><span class="line">-  16.7.2 利用分辨率缩放</span><br><span class="line">   -  对于特定机器进行分辨率的缩放，</span><br><span class="line">-  16.8 减少计算复杂度</span><br><span class="line">   -  计算复杂度会影响游戏的渲染性能</span><br><span class="line">   - 16.8.1 Shader的LOD技术</span><br><span class="line">    - 当Shader的LOD值小于某个设定的值时,该Shader才会被使用</span><br><span class="line"></span><br><span class="line">      ```C</span><br><span class="line">      SubShader&#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Qpaque&quot;&#125;</span><br><span class="line">        LOD 200</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>16.8.2 代码方面的优化<br>对象&lt;顶点&lt;像素<ol>
<li>尽可能使用低精度的浮点值运算，float 存储（顶点坐标），half适合标量纹理坐标，fixed 适合颜色变量和归一化的方向矢量，避免使用swizzle计算</li>
<li>减少插值变量</li>
<li>尽可能不要使用全屏的屏幕后处理效果</li>
<li>尽可能把多个特效合并到一个Shader中</li>
<li>尽可能不要使用分支语句和循环语句</li>
<li>尽可能避免使用sin,tan,pow,log等复杂的数学计算</li>
<li>尽可能不要使用discard操作，会影响硬件的某些优化</li>
</ol>
</li>
<li>16.8.3 根据硬件条件进行缩放<br>scaiing 放缩思路</li>
</ul>
</li>
<li><p>16.9 拓展阅读</p>
<ul>
<li>官方手册 移动平台永华实践指南</li>
<li><h2><span id="第十七章-unity的表面着色器探秘">第十七章 Unity的表面着色器探秘</span></h2></li>
</ul>
</li>
</ul>
<p>表面着色器（Surface Shader）是顶点/片元着色器的抽象。</p>
</li>
<li><p>17.1 表面着色器的一个例子</p>
</li>
<li><p>17.2 编译命令<br>编译命令的作用指明该表面着色器使用的表面函数和光照函数，并设置一些可选参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> surface surfaceFunction lightModel [optionalarams]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>17.2.1 表面函数<br>名称surf</li>
<li>17.2.2 光照函数</li>
</ul>
<p>自由度低，不好优化，不如用顶点片元</p>
<h2><span id="第十八章-基于物理的渲染">第十八章 基于物理的渲染</span></h2><p>基于物理的渲染技术 （Physlcally Based Shading，PBS）</p>
</li>
<li><p>18.1 PBS的理论和数学基础</p>
<ul>
<li>18.1.1 光是什么？<br>电磁波，光纤具有吸收和散射的特性。 影响光传播的重要特质是材质的折射率。<br>光被折射到非金属物体内部，被散射出去的是次表面散射光</li>
<li>18.1.2 双向反射分布函数（BRDF）<ul>
<li>辐射率radiance 是单位面积，单位方向上光源的辐射通量，通常用L表述<br>BRDF的理解 给定入射角度后，BRDF可以给出所有出射方向上的反射和散射光线的相对分布情况<br>当给定观察方向（出射角度），BRDF可以给出所有入射方向到该出射方向的光线分布。<h2><span id="第十九章-unity5-更新了什么">第十九章 Unity5 更新了什么</span></h2><h2><span id="第二十章-还有更多内容么">第二十章 还有更多内容么</span></h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="参考">参考</span></h2><p>[1] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gaussian_blur">Gaussian blur - wikipedia</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom (shader effect) - wikipedia</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cel_shading">Cel shading - wikipedia</a></p>

    </div>

    <div class="about">
        <h1>关于本文</h1>
        <p>本文作者 Master Gong Sheng, 许可由 <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>

    
        
    
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
        </div>
        &copy; 2023 Master Gong Sheng<br />
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
</footer>

        
<script src="/js/main.js"></script>

        
    </body>
</html>